#!/usr/bin/env python3

import re
import os
import csv
import sys
import time
import json
import logging
import argparse
import requests
import itertools
from packageurl import PackageURL
from requests.auth import HTTPBasicAuth
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry


class LogFilter:  # pragma: no cover
    def __init__(self, level):
        self.__level = level

    def filter(self, log_record):
        return log_record.levelno <= self.__level


class Cache:  # pragma: no cover
    def __init__(self, not_found_obj=None):
        self.cache = {}
        self.not_found_obj = not_found_obj

    def set(self, key, value):
        self.cache[key] = {"value": value}

    def get(self, key):
        if key in self.cache:
            entry = self.cache[key]
            return entry["value"]
        return self.not_found_obj

    def clear(self):
        self.cache = {}


default_not_found_value = "N/A"

# OpenCVE API is rate limited, caching CWE details to reduce API calls
cwe_name_cache = Cache()
cwe_description_cache = Cache()

# NVD API is rate limited, caching CVE details to reduce API calls
cve_published_date_cache = Cache()
cve_last_modified_date = Cache()
cve_cwe_id_cache = Cache()
cve_status_cache = Cache()
cve_cvss_v2_vector_cache = Cache()
cve_cvss_v3_vector_cache = Cache()
cve_cvss_v4_vector_cache = Cache()


def get_args(args: argparse.Namespace) -> argparse.Namespace:
    """Parse and return the arguments of the application

    :parameter
        args:argparse.Namespace -- Submitted arguments to parse

    :return
        argparse.Namespace -- Parsed arguments
    """
    parser = argparse.ArgumentParser(description="Generate Vulnerability Results Report.")
    parser.add_argument(
        "--nvd-api-key",
        action="store",
        required=True,
        help="NIST NVD API key",
    )
    parser.add_argument(
        "--opencve-username",
        action="store",
        required=True,
        help="OpenCVE registered username",
    )
    parser.add_argument(
        "--opencve-password",
        action="store",
        required=True,
        help="OpenCVE registered password",
    )
    parser.add_argument(
        "--github-token",
        action="store",
        required=True,
        help="GitHub API token",
    )
    parser.add_argument(
        "--github-organisation",
        nargs="?",
        const="",
        required=False,
        help="GitHub organisation name",
    )
    parser.add_argument(
        "--github-repository",
        nargs="?",
        const="",
        required=False,
        help="GitHub repository name",
    )
    parser.add_argument(
        "--sast-codeql-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting CodeQL CSV report",
    )
    parser.add_argument(
        "--sast-horusec-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Horusec JSON report",
    )
    parser.add_argument(
        "--sast-horusec-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Horusec CSV report",
    )
    parser.add_argument(
        "--sast-semgrep-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Semgrep JSON report",
    )
    parser.add_argument(
        "--sast-semgrep-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Semgrep CSV report",
    )
    parser.add_argument(
        "--sast-snyk-code-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Snyk Code JSON report",
    )
    parser.add_argument(
        "--sast-snyk-code-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Snyk Code CSV report",
    )
    parser.add_argument(
        "--sca-grype-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Grype report",
    )
    parser.add_argument(
        "--sca-grype-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Grype CSV report",
    )
    parser.add_argument(
        "--sca-snyk-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Snyk report",
    )
    parser.add_argument(
        "--sca-snyk-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Snyk CSV report",
    )
    parser.add_argument(
        "--sca-owasp-dependency-check-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of OWASP Dependency Check JSON report",
    )
    parser.add_argument(
        "--sca-owasp-dependency-check-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting OWASP Dependency Check CSV report",
    )
    return parser.parse_args(args)


# =====================
# API Request functions
# =====================
def send_get_request(
    url: str, api_key: str = None, github_token=None, username: str = None, password: str = None, sleep: int = 5
) -> requests:  # pragma: no cover
    """Send GET request to URL

    :parameter
        url:str -- URL to make GET request
        api_key:str -- API key for authentication
        github_token:str -- GitHub API token
        username:str -- Username for authentication
        password:str -- Password for authentication
        sleep:int -- Time to sleep before making request

    :return
        requests.models.Response -- Response from GET request
    """
    session = requests.Session()
    retries = Retry(
        total=3,
        backoff_factor=3,
        status_forcelist=[404, 408, 500, 502, 503, 504],
    )
    session.mount("https://", HTTPAdapter(max_retries=retries))
    if api_key:
        headers = {"Accept": "application/json", "apiKey": api_key}
        request = session.get(url, headers=headers)
    elif github_token:
        headers = {"Accept": "application/vnd.github+json", "X-GitHub-Api-Version": "2022-11-28", "Authorization": f"Bearer {github_token}"}
        request = session.get(url, headers=headers)
    else:
        headers = {"Accept": "application/json"}
        request = session.get(url, headers=headers, auth=HTTPBasicAuth(username, password))

    if request.ok:
        log.info(f"GET request successful: {url}")

        if sleep:
            log.info(f"Sleeping for {sleep} seconds before making next request")
            time.sleep(sleep)

        return request
    log.error(f"GET request failed: \n{request.text.encode('utf8')}")
    return None


# =================
# Top CWE functions
# =================
def get_mitre_top_25_cwe() -> list:
    """Top 25 CWE of 2024

    :return
        list -- Top 25 CWE IDs
    """
    return [
        "CWE-787",
        "CWE-79",
        "CWE-89",
        "CWE-416",
        "CWE-78",
        "CWE-20",
        "CWE-125",
        "CWE-22",
        "CWE-352",
        "CWE-434",
        "CWE-862",
        "CWE-476",
        "CWE-287",
        "CWE-190",
        "CWE-502",
        "CWE-77",
        "CWE-119",
        "CWE-798",
        "CWE-918",
        "CWE-306",
        "CWE-362",
        "CWE-269",
        "CWE-94",
        "CWE-863",
        "CWE-276",
    ]


def get_owasp_top_10_cwe() -> set:
    """Top 10 OWASP CWE of 2024

    :return
        list -- CWE IDs corresponding to the OWASP security category
    """
    return {
        "A01 Broken Access Control": [
            "CWE-22",
            "CWE-23",
            "CWE-35",
            "CWE-59",
            "CWE-200",
            "CWE-201",
            "CWE-219",
            "CWE-264",
            "CWE-275",
            "CWE-276",
            "CWE-284",
            "CWE-285",
            "CWE-352",
            "CWE-359",
            "CWE-377",
            "CWE-402",
            "CWE-425",
            "CWE-441",
            "CWE-497",
            "CWE-538",
            "CWE-540",
            "CWE-548",
            "CWE-552",
            "CWE-566",
            "CWE-601",
            "CWE-639",
            "CWE-651",
            "CWE-668",
            "CWE-706",
            "CWE-862",
            "CWE-863",
            "CWE-913",
            "CWE-922",
            "CWE-1275",
        ],
        "A02 Cryptographic Failures": [
            "CWE-261",
            "CWE-296",
            "CWE-310",
            "CWE-319",
            "CWE-321",
            "CWE-322",
            "CWE-323",
            "CWE-324",
            "CWE-325",
            "CWE-326",
            "CWE-327",
            "CWE-328",
            "CWE-329",
            "CWE-330",
            "CWE-331",
            "CWE-335",
            "CWE-336",
            "CWE-337",
            "CWE-338",
            "CWE-339",
            "CWE-340",
            "CWE-347",
            "CWE-523",
            "CWE-720",
            "CWE-757",
            "CWE-759",
            "CWE-760",
            "CWE-780",
            "CWE-818",
            "CWE-916",
        ],
        "A03 Injection": [
            "CWE-20",
            "CWE-74",
            "CWE-75",
            "CWE-77",
            "CWE-78",
            "CWE-79",
            "CWE-80",
            "CWE-83",
            "CWE-87",
            "CWE-88",
            "CWE-89",
            "CWE-90",
            "CWE-91",
            "CWE-93",
            "CWE-94",
            "CWE-95",
            "CWE-96",
            "CWE-97",
            "CWE-98",
            "CWE-99",
            "CWE-100",
            "CWE-113",
            "CWE-116",
            "CWE-138",
            "CWE-184",
            "CWE-470",
            "CWE-471",
            "CWE-564",
            "CWE-610",
            "CWE-643",
            "CWE-644",
            "CWE-652",
            "CWE-917",
        ],
        "A04 Insecure Design": [
            "CWE-73",
            "CWE-183",
            "CWE-209",
            "CWE-213",
            "CWE-235",
            "CWE-256",
            "CWE-257",
            "CWE-266",
            "CWE-269",
            "CWE-280",
            "CWE-311",
            "CWE-312",
            "CWE-313",
            "CWE-316",
            "CWE-419",
            "CWE-430",
            "CWE-434",
            "CWE-444",
            "CWE-451",
            "CWE-472",
            "CWE-501",
            "CWE-522",
            "CWE-525",
            "CWE-539",
            "CWE-579",
            "CWE-598",
            "CWE-602",
            "CWE-642",
            "CWE-646",
            "CWE-650",
            "CWE-653",
            "CWE-656",
            "CWE-657",
            "CWE-799",
            "CWE-807",
            "CWE-840",
            "CWE-841",
            "CWE-927",
            "CWE-1021",
            "CWE-1173",
        ],
        "A05 Security Misconfiguration": [
            "CWE-2",
            "CWE-11",
            "CWE-13",
            "CWE-15",
            "CWE-16",
            "CWE-260",
            "CWE-315",
            "CWE-266",
            "CWE-520",
            "CWE-526",
            "CWE-537",
            "CWE-541",
            "CWE-547",
            "CWE-611",
            "CWE-614",
            "CWE-756",
            "CWE-776",
            "CWE-942",
            "CWE-1004",
            "CWE-1032",
            "CWE-1174",
        ],
        "A06 Vulnerable And Outdated Components": [
            "Drupal",
            "WordPress",
            "Joomla",
        ],
        "A07 Identification and Authentication Failures": [
            "CWE-255",
            "CWE-259",
            "CWE-287",
            "CWE-288",
            "CWE-290",
            "CWE-294",
            "CWE-295",
            "CWE-297",
            "CWE-300",
            "CWE-302",
            "CWE-304",
            "CWE-306",
            "CWE-307",
            "CWE-346",
            "CWE-384",
            "CWE-521",
            "CWE-613",
            "CWE-620",
            "CWE-640",
            "CWE-798",
            "CWE-940",
            "CWE-1216",
        ],
        "A08 Software and Data Integrity Failures": [
            "CWE-345",
            "CWE-353",
            "CWE-426",
            "CWE-494",
            "CWE-502",
            "CWE-565",
            "CWE-784",
            "CWE-829",
            "CWE-830",
            "CWE-913",
        ],
        "A09 Security Logging and Monitoring Failures": [
            "CWE-117",
            "CWE-223",
            "CWE-532",
            "CWE-778",
        ],
        "A10 Server Side Request Forgery (SSRF)": ["CWE-918"],
    }


# ====================
# CSV header functions
# ====================
def get_csv_sca_column_headers() -> str:
    """Get column headers for SCA CSV report

    :return
        list -- Column headers for SCA CSV report
    """
    csv_headers = [
        "Tool Type",
        "Tool Name",
        "Tool Version",
        "Tool Classification",
        "Language",
        "Severity",
        "Confidence",
        "Component Type",
        "Component Name",
        "Component Version",
        "Component PURL",
        "Component License",
        "Component Location",
        "CVE ID",
        "CVE Description",
        "CVE Source",
        "CVE Published Date",
        "CVE Last Modified Date",
        "CVE Status",
        "CVE Malicious",
        "CVE Disputed",
        "CVSS V2 Vector",
        "CVSS V3 Vector",
        "CVSS V4 Vector",
        "CWE ID",
    ]
    return f"{convert_list_to_csv_row(csv_headers)}\n"


def get_csv_sast_column_headers() -> str:
    """Get column headers for SAST CSV report

    :return
        list -- Column headers for SAST CSV report
    """
    csv_headers = [
        "Tool Type",
        "Tool Name",
        "Tool Version",
        "Tool Classification",
        "Language",
        "Severity",
        "Confidence",
        "CWE ID",
        "CWE Name",
        "CWE Description",
        "CWE Impact",
        "CWE Likelihood",
        "OWASP Top 10",
        "Mitre Top 25",
        "Rule ID",
        "File",
        "Line",
    ]
    return f"{convert_list_to_csv_row(csv_headers)}\n"


# ====================
# CSV writer functions
# ====================
def write_csv_report_header(tool_type: str, csv_output_filename: str) -> None:
    """Write CSV report header

    :parameter
        tool_type:str -- Type of tool to write header for (sca or sast)
        csv_output_filename:str -- Name of CSV report to write
    """
    log.info(f"Writing CSV report header to {get_directory_path()}/{csv_output_filename}")

    with open(f"{get_directory_path()}/{csv_output_filename}", "w") as file:
        if tool_type.upper() == "SAST":
            file.write(get_csv_sast_column_headers())
        elif tool_type.upper() == "SCA":
            file.write(get_csv_sca_column_headers())
        else:
            log.error(f"Tool type {tool_type} not supported")
            sys.exit(1)

    log.info(f"Successfully wrote CSV report header to {get_directory_path()}/{csv_output_filename}")


def write_to_csv_report(csv_data: list, csv_output_filename: str) -> None:
    """Write parsed vulnerability data to CSV report

    :parameter
        csv_data:list -- Data to write to CSV report
        csv_output_filename:str -- Name of CSV report to write
    """
    log.info(f"Writing parsed vulnerability data to {get_directory_path()}/{csv_output_filename}")

    csv_data.sort()
    csv_data = list(item for item, _ in itertools.groupby(csv_data))

    with open(f"{get_directory_path()}/{csv_output_filename}", "a") as csv_file:
        writer = csv.writer(csv_file)
        writer.writerows(csv_data)

    log.info(f"Successfully wrote SBOM and OSV data to {get_directory_path()}/{csv_output_filename}")


# ================
# Helper functions
# ================
def get_directory_path() -> str:
    """Get directory path of script

    :return
        str -- Directory path of script
    """
    return os.path.dirname(os.path.realpath(__file__))


def convert_list_to_string(data: list) -> str:
    """Convert list to string

    :parameter
        data:list -- Data to convert to string

    :return
        str -- Data as string
    """
    if data is not default_not_found_value:
        return ",".join(data)
    return data


def convert_list_to_csv_row(data: list) -> str:
    """Convert list to CSV row

    :parameter
        data:list -- Data to convert to CSV row

    :return
        str -- CSV row
    """
    return ",".join(map(str, data))


def get_json_value(
    json_data: dict,
    data_key_1: str,
    data_key_2: str = None,
    data_key_3: str = None,
    default_value: str = default_not_found_value,
) -> str:
    """Get JSON value if exists

    :parameter
        json_data:dict -- JSON response data
        data_key_1:str -- Primary key of JSON response data
        data_key_2:str -- Optional second key of JSON response data
        data_key_3:str -- Optional third key of JSON response data
        default_value:str -- Default value if key not found

    :return
        str -- JSON value
    """
    if data_key_3 is not None:
        if data_key_1 in json_data:
            if data_key_2 in json_data[data_key_1]:
                if data_key_3 in json_data[data_key_1][data_key_2]:
                    # Check if value is not empty
                    if json_data[data_key_1][data_key_2][data_key_3]:
                        return json_data[data_key_1][data_key_2][data_key_3]
    elif data_key_2 is not None:
        if data_key_1 in json_data:
            if data_key_2 in json_data[data_key_1]:
                # Check if value is not empty
                if json_data[data_key_1][data_key_2]:
                    return json_data[data_key_1][data_key_2]
    elif data_key_1 in json_data:
        # Check if value is not empty
        if json_data[data_key_1]:
            return json_data[data_key_1]
    return default_value


def get_cwe_regex() -> str:
    """Get regex pattern for CWE ID

    :return
        str -- CWE ID regex pattern
    """
    return r"CWE-(\d{1,9})"


def search_owasp_top_10(cwe_id: str) -> str:
    """Search OWASP Top 10 for CWE ID

    :parameter
        cwe_id:str -- CWE ID to check if in OWASP top 10

    :return
        str -- OWASP category associated with CWE ID
    """
    for key, value in get_owasp_top_10_cwe().items():
        if cwe_id in value:
            log.info(f"{cwe_id} found in OWASP Top 10: {key}")
            return key
    log.info(f"{cwe_id} not found in OWASP Top 10")
    return default_not_found_value


def search_mitre_top_25(cwe_id: str) -> str:
    """Search MITRE Top 25 for CWE ID

    :parameter
        cwe_id:str -- CWE ID to check if in MITRE top 25

    :return
        str -- MITRE ranking for CWE ID
    """
    if cwe_id in get_mitre_top_25_cwe():
        cwe_index = str(get_mitre_top_25_cwe().index(cwe_id) + 1)
        log.info(f"{cwe_id} found in MITRE Top 25 at index {cwe_index}")
        return cwe_index
    log.info(f"{cwe_id} not found in MITRE Top 25")
    return default_not_found_value


# OpenCVE API is rate limited
def get_opencve_api_url(cwe_id: str) -> str:
    """Get OpenCVE API URL for CWE ID

    :parameter
        cwe_id:str -- CWE ID to search in OpenCVE

    :return
        str -- OpenCVE API URL for CWE ID
    """
    return f"https://www.opencve.io/api/cwe/{cwe_id}"


# OpenCVE extracts CVE details from NVD but NVD API rate limiting is less restrictive
def get_nvd_api_url(cve_id: str) -> str:
    """Get NVD API URL for CVE ID

    :parameter
        cwe_id:str -- CVE ID to search in NVD

    :return
        str -- NVD API URL for CVE ID
    """
    return f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={cve_id}"


def get_github_api_url(github_organisation: str, github_repository: str) -> str:
    """Get GitHub API URL for repository

    :parameter
        github_organisation:str -- GitHub organisation name
        github_repository:str -- GitHub repository name

    :return
        str -- GitHub API URL for repository
    """
    return f"https://api.github.com/repos/{github_organisation}/{github_repository}/code-scanning/alerts"


def get_snyk_code_severity_levels(level: str) -> str:
    """
    Get Snyk Code severity levels

    :param
        level: str -- Snyk Code severity level

    :return:
        str -- Snyk Code severity level
    """
    # See https://docs.snyk.io/snyk-cli/scan-and-maintain-projects-using-the-cli/snyk-cli-for-snyk-code/view-snyk-code-cli-results#severity-levels-in-json-and-sarif-files
    if level.upper() == "ERROR":
        return "High"
    elif level.upper() == "WARNING":
        return "Medium"
    elif level.upper() == "NOTE" or level.upper() == "INFO":
        return "Low"
    else:
        return default_not_found_value


def get_grype_cvss_vector(cvss_data: dict, cvss_version_primary: str, cvss_version_secondary=None) -> str:
    """Get Grype CVSS vector

    :parameter
        cvss_data:dict -- Grype CVSS data
        cvss_version_primary:str -- Primary CVSS version
        cvss_version_secondary:str -- Secondary CVSS version

    :return
        str -- Grype CVSS vector
    """
    for cvss_version in cvss_data["cvss"]:
        if get_json_value(cvss_version, "version") == cvss_version_primary:
            return get_json_value(cvss_version, "vector")
        elif get_json_value(cvss_version, "version") == cvss_version_secondary:
            return get_json_value(cvss_version, "vector")
    return default_not_found_value


def get_snyk_cvss_vector(cvss_data: dict, cvss_version_key: str) -> str:
    """Get Snyk CVSS vector

    :parameter
        cvss_data:dict -- Snyk CVSS data
        cvss_version_primary:str -- CVSS version key

    :return
        str -- Snyk CVSS vector
    """
    if cvss_version_key in cvss_data:
        return get_json_value(cvss_data, cvss_version_key)
    return default_not_found_value


def get_nvd_cvss_vector(nvd_data: dict, cvss_version: str) -> str:
    """Get NVD CVSS vector

    :parameter
        nvd_data:dict -- NVD response data
        cvss_version:str -- CVSS version

    :return
        str -- NVD CVSS vector
    """
    if "cvssMetricV4" in nvd_data and cvss_version == "4.0":
        cvss_details = get_json_value(nvd_data, "cvssMetricV4")
        return get_json_value(cvss_details[0], "cvssData", "vectorString")
    elif "cvssMetricV31" in nvd_data and cvss_version == "3.1":
        cvss_details = get_json_value(nvd_data, "cvssMetricV31")
        return get_json_value(cvss_details[0], "cvssData", "vectorString")
    elif "cvssMetricV3" in nvd_data and cvss_version == "3.0":
        cvss_details = get_json_value(nvd_data, "cvssMetricV3")
        return get_json_value(cvss_details[0], "cvssData", "vectorString")
    elif "cvssMetricV2" in nvd_data and cvss_version == "2.0":
        cvss_details = get_json_value(nvd_data, "cvssMetricV2")
        return get_json_value(cvss_details[0], "cvssData", "vectorString")
    return default_not_found_value


def get_cwe_from_nvd(nvd_data: dict) -> str:
    """Get CWE ID from NVD data

    :parameter
        nvd_data:dict -- NVD data to extract CWE ID from

    :return
        str -- CWE ID extracted from NVD data
    """
    nvd_weaknesses = get_json_value(nvd_data, "cve", "weaknesses")
    if nvd_weaknesses is default_not_found_value:
        return nvd_weaknesses
    cwe_list = []
    for weakness in nvd_weaknesses:
        for description in weakness["description"]:
            # Only consider vulnerabilities with CWE ID
            match = re.search(get_cwe_regex(), description["value"])
            if match:
                vulnerability_cwe_id = match.group(0)
                log.info(f"Extracted CWE ID from NVD: {vulnerability_cwe_id}")
                cwe_list.append(vulnerability_cwe_id)
    return convert_list_to_string(cwe_list)


def get_component_from_purl(component_purl: str) -> dict:
    """Get component details from Package URL

    :parameter
        component_purl:str -- Package URL to extract component details from

    :return
        dict -- Component details extracted from Package URL
    """
    return PackageURL.from_string(component_purl).to_dict()


def clear_cwe_caches():
    """Clear CWE caches"""
    global cwe_name_cache
    global cwe_description_cache

    cwe_name_cache.clear()
    cwe_description_cache.clear()


def clear_cve_caches():
    """Clear CVE caches"""
    global cve_published_date_cache
    global cve_last_modified_date
    global cve_cwe_id_cache
    global cve_status_cache
    global cve_cvss_v2_vector_cache
    global cve_cvss_v3_vector_cache
    global cve_cvss_v4_vector_cache

    cve_published_date_cache.clear()
    cve_last_modified_date.clear()
    cve_cwe_id_cache.clear()
    cve_status_cache.clear()
    cve_cvss_v2_vector_cache.clear()
    cve_cvss_v3_vector_cache.clear()
    cve_cvss_v4_vector_cache.clear()


# ========================
# Data retrieval functions
# ========================
def get_codeql_data(github_token: str, github_organisation: str, github_repository: str) -> list:
    """Get CodeQL data from GitHub API

    :parameter
        github_token:str -- GitHub API token
        github_organisation:str -- GitHub organisation name
        github_repository:str -- GitHub repository name

    :return
        list -- CodeQL data from GitHub API
    """
    log.info("Retrieving CodeQL data")
    github_api_url = get_github_api_url(github_organisation, github_repository)
    codeql_data = send_get_request(github_api_url, None, github_token, None, None, None)
    if codeql_data:
        log.info("Successfully retrieved CodeQL data")
        # Removes any uni-block special characters in CodeQL data
        return json.loads(codeql_data.text.encode("raw-unicode-escape"))
    else:
        log.error("Failed to retrieve CodeQL data")
        sys.exit(1)


# ======================
# Parsing data functions
# ======================
def parse_codeql_data(
    opencve_username: str,
    opencve_password: str,
    codeql_data: list,
    csv_filename: str,
) -> None:
    """Parse CodeQL data and write data to output file

    :param
        opencve_username:str -- OpenCVE username
        opencve_password:str -- OpenCVE password
        codeql_data:list -- CodeQL data to parse
        csv_filename:str -- Name of CSV report to write data to
    """
    log.info("Parsing CodeQL data")
    csv_rows = []

    # Set globals
    global cwe_name_cache
    global cwe_description_cache

    try:
        # Check if vulnerabilities exist in report
        if codeql_data is None or len(codeql_data) == 0:
            log.info("No vulnerabilities found in CodeQL data")
        else:
            tool_type = "SAST"
            tool_name = get_json_value(codeql_data, "tool", "name")
            tool_version = get_json_value(codeql_data, "tool", "version")
            tool_classification = "Semantic"

            # Iterate through all vulnerabilities
            for vulnerability in codeql_data:
                # Remove leading /language:
                vulnerability_language = get_json_value(vulnerability, "most_recent_instance", "category")
                vulnerability_language = vulnerability_language.split(":")[1]

                vulnerability_severity = get_json_value(vulnerability, "rule", "security_severity_level")
                vulnerability_rule_id = get_json_value(vulnerability, "rule", "id")
                vulnerability_file = get_json_value(vulnerability, "most_recent_instance", "location", "path")
                vulnerability_line = get_json_value(vulnerability, "most_recent_instance", "location", "start_line")

                for tag in vulnerability["rule"]["tags"]:
                    # Only consider vulnerabilities with CWE ID
                    match = re.search(get_cwe_regex(), tag.upper())
                    if match:
                        vulnerability_cwe_id = match.group(0)
                        # CodeQL bug: Some CVE IDs contain leading zero
                        if vulnerability_cwe_id.startswith("CWE-0"):
                            vulnerability_cwe_id = vulnerability_cwe_id.replace("CWE-0", "CWE-")
                        log.info(f"Getting vulnerability details: {vulnerability_cwe_id}")

                        vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                        vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                        # Set default values
                        vulnerability_cwe_name = default_not_found_value
                        vulnerability_cwe_description = default_not_found_value

                        if cwe_name_cache.get(vulnerability_cwe_id):
                            log.info(f"Getting vulnerability details from cache: {vulnerability_cwe_id}")

                            # Get CWE details from cache
                            vulnerability_cwe_name = cwe_name_cache.get(vulnerability_cwe_id)
                            vulnerability_cwe_description = cwe_description_cache.get(vulnerability_cwe_id)
                        else:
                            log.info(f"Vulnerability not in cache: {vulnerability_cwe_id}")
                            log.info(f"Getting vulnerability details from OpenCVE: {vulnerability_cwe_id}")

                            # Get CWE details from OpenCVE
                            opencve_cwe_details = send_get_request(
                                get_opencve_api_url(vulnerability_cwe_id), None, None, opencve_username, opencve_password
                            )
                            if opencve_cwe_details:
                                opencve_details = opencve_cwe_details.json()
                                vulnerability_cwe_name = get_json_value(opencve_details, "name")
                                vulnerability_cwe_description = get_json_value(opencve_details, "description")

                                log.info(f"Extracted vulnerability details from OpenCVE: {vulnerability_cwe_id}")
                            else:
                                log.error(f"Failed to extract vulnerability details from OpenCVE: {vulnerability_cwe_id}")

                            # Cache CWE details
                            cwe_name_cache.set(vulnerability_cwe_id, vulnerability_cwe_name)
                            cwe_description_cache.set(vulnerability_cwe_id, vulnerability_cwe_description)

                        vulnerability_results_data = [
                            tool_type,
                            tool_name,
                            tool_version,
                            tool_classification,
                            vulnerability_language,
                            vulnerability_severity,
                            default_not_found_value,
                            vulnerability_cwe_id,
                            vulnerability_cwe_name,
                            vulnerability_cwe_description,
                            default_not_found_value,
                            default_not_found_value,
                            vulnerability_owasp_top_10,
                            vulnerability_mitre_top_25,
                            vulnerability_rule_id,
                            vulnerability_file,
                            vulnerability_line,
                        ]
                        log.info(f"Fetched vulnerability details: {vulnerability_cwe_id}")

                        # Add vulnerability data to CSV row
                        csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated")
            write_to_csv_report(csv_rows, csv_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse CodeQL data: {e}")
        sys.exit(1)
    else:
        log.info("Successfully parsed CodeQL data")
    return None


def parse_horusec_data(
    opencve_username: str,
    opencve_password: str,
    sast_horusec_report_filename: str,
    csv_filename: str,
) -> None:
    """Parse Horusec SAST JSON report and write data to output file

    :parameter
        opencve_username:str -- OpenCVE username
        opencve_password:str -- OpenCVE password
        sast_horusec_report_filename:str -- Name of Horusec JSON report to parse
        csv_filename:str -- Name of CSV report to write data to
    """
    log.info(f"Parsing Horusec report: {sast_horusec_report_filename}")
    with open(sast_horusec_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cwe_name_cache
    global cwe_description_cache

    try:
        # Check if vulnerabilities exist in report
        if data["analysisVulnerabilities"] is None or len(data["analysisVulnerabilities"]) == 0:
            log.info(f"No vulnerabilities found in Horusec report: {sast_horusec_report_filename}")
        else:
            # Iterate through all vulnerabilities
            for analysis in data["analysisVulnerabilities"]:
                vulnerability = analysis["vulnerabilities"]
                vulnerability_details = get_json_value(vulnerability, "details")

                # Only consider vulnerabilities with CWE ID
                match = re.search(get_cwe_regex(), vulnerability_details)
                if match:
                    vulnerability_cwe_id = match.group(0)
                    log.info(f"Getting vulnerability details: {vulnerability_cwe_id}")

                    tool_type = "SAST"
                    tool_name = get_json_value(vulnerability, "securityTool")
                    tool_version = get_json_value(data, "version")
                    tool_classification = "Syntactic"

                    vulnerability_language = get_json_value(vulnerability, "language")
                    vulnerability_severity = get_json_value(vulnerability, "severity")
                    vulnerability_confidence = get_json_value(vulnerability, "confidence")
                    vulnerability_rule_id = get_json_value(vulnerability, "rule_id")
                    vulnerability_file = get_json_value(vulnerability, "file")
                    vulnerability_line = get_json_value(vulnerability, "line")

                    vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                    vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                    # Set default values
                    vulnerability_cwe_name = default_not_found_value
                    vulnerability_cwe_description = default_not_found_value

                    if cwe_name_cache.get(vulnerability_cwe_id):
                        log.info(f"Getting vulnerability details from cache: {vulnerability_cwe_id}")

                        # Get CWE details from cache
                        vulnerability_cwe_name = cwe_name_cache.get(vulnerability_cwe_id)
                        vulnerability_cwe_description = cwe_description_cache.get(vulnerability_cwe_id)
                    else:
                        log.info(f"Vulnerability not in cache: {vulnerability_cwe_id}")
                        log.info(f"Getting vulnerability details from OpenCVE: {vulnerability_cwe_id}")

                        # Get CWE details from OpenCVE
                        opencve_cwe_details = send_get_request(
                            get_opencve_api_url(vulnerability_cwe_id), None, None, opencve_username, opencve_password
                        )
                        if opencve_cwe_details:
                            opencve_details = opencve_cwe_details.json()
                            vulnerability_cwe_name = get_json_value(opencve_details, "name")
                            vulnerability_cwe_description = get_json_value(opencve_details, "description")

                            log.info(f"Extracted vulnerability details from OpenCVE: {vulnerability_cwe_id}")
                        else:
                            log.error(f"Failed to extract vulnerability details from OpenCVE: {vulnerability_cwe_id}")

                        # Cache CWE details
                        cwe_name_cache.set(vulnerability_cwe_id, vulnerability_cwe_name)
                        cwe_description_cache.set(vulnerability_cwe_id, vulnerability_cwe_description)

                    vulnerability_results_data = [
                        tool_type,
                        tool_name,
                        tool_version,
                        tool_classification,
                        vulnerability_language,
                        vulnerability_severity,
                        vulnerability_confidence,
                        vulnerability_cwe_id,
                        vulnerability_cwe_name,
                        vulnerability_cwe_description,
                        default_not_found_value,
                        default_not_found_value,
                        vulnerability_owasp_top_10,
                        vulnerability_mitre_top_25,
                        vulnerability_rule_id,
                        vulnerability_file,
                        vulnerability_line,
                    ]
                    log.info(f"Fetched vulnerability details: {vulnerability_cwe_id}")

                    # Add vulnerability data to CSV row
                    csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated")
            write_to_csv_report(csv_rows, csv_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Horusec report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed Horusec report: {sast_horusec_report_filename}")
    return None


def parse_semgrep_data(
    opencve_username: str,
    opencve_password: str,
    sast_semgrep_report_filename: str,
    csv_filename: str,
) -> None:
    """Parse Semgrep SAST JSON report and write data to output file

    :parameter
        opencve_username:str -- OpenCVE username
        opencve_password:str -- OpenCVE password
        sast_semgrep_report_filename:str -- Name of Semgrep JSON report to parse
        csv_filename:str -- Name of CSV report to write data to
    """
    log.info(f"Parsing Semgrep report: {sast_semgrep_report_filename}")
    with open(sast_semgrep_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cwe_name_cache
    global cwe_description_cache

    try:
        # Check if vulnerabilities exist in report
        if data["results"] is None or len(data["results"]) == 0:
            log.info(f"No vulnerabilities found in Semgrep report: {sast_semgrep_report_filename}")
        else:
            # Iterate through all vulnerabilities
            for vulnerability in data["results"]:
                vulnerability_metadata = get_json_value(vulnerability, "extra", "metadata")
                for vulnerability_cwe_id in vulnerability_metadata["cwe"]:
                    match = re.search(get_cwe_regex(), vulnerability_cwe_id)
                    if match:
                        vulnerability_cwe_id = match.group(0)
                        log.info(f"Getting vulnerability details: {vulnerability_cwe_id}")

                        tool_type = "SAST"
                        tool_name = "Semgrep"
                        tool_version = get_json_value(data, "version")
                        tool_classification = "Semantic"

                        vulnerability_severity = get_json_value(vulnerability, "extra", "severity")
                        vulnerability_file = get_json_value(vulnerability, "path")
                        vulnerability_line = get_json_value(vulnerability, "start", "line")

                        # Convert list to comma-separated string
                        vulnerability_language = get_json_value(vulnerability_metadata, "technology")
                        vulnerability_language = convert_list_to_string(vulnerability_language)

                        vulnerability_confidence = get_json_value(vulnerability_metadata, "confidence")
                        vulnerability_rule_id = get_json_value(vulnerability_metadata, "semgrep.dev", "rule", "rule_id")
                        vulnerability_impact = get_json_value(vulnerability_metadata, "impact")
                        vulnerability_likelihood = get_json_value(vulnerability_metadata, "likelihood")

                        vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                        vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                        # Set default values
                        vulnerability_cwe_name = default_not_found_value
                        vulnerability_cwe_description = default_not_found_value

                        if cwe_name_cache.get(vulnerability_cwe_id):
                            log.info(f"Getting vulnerability details from cache: {vulnerability_cwe_id}")

                            # Get CWE details from cache
                            vulnerability_cwe_name = cwe_name_cache.get(vulnerability_cwe_id)
                            vulnerability_cwe_description = cwe_description_cache.get(vulnerability_cwe_id)
                        else:
                            log.info(f"Vulnerability not in cache: {vulnerability_cwe_id}")
                            log.info(f"Getting vulnerability details from OpenCVE: {vulnerability_cwe_id}")

                            # Get CWE details from OpenCVE
                            opencve_cwe_details = send_get_request(
                                get_opencve_api_url(vulnerability_cwe_id), None, None, opencve_username, opencve_password
                            )
                            if opencve_cwe_details:
                                opencve_details = opencve_cwe_details.json()
                                vulnerability_cwe_name = get_json_value(opencve_details, "name")
                                vulnerability_cwe_description = get_json_value(opencve_details, "description")

                                log.info(f"Extracted vulnerability details from OpenCVE: {vulnerability_cwe_id}")
                            else:
                                log.error(f"Failed to extract vulnerability details from OpenCVE: {vulnerability_cwe_id}")

                            # Cache CWE details
                            cwe_name_cache.set(vulnerability_cwe_id, vulnerability_cwe_name)
                            cwe_description_cache.set(vulnerability_cwe_id, vulnerability_cwe_description)

                        vulnerability_results_data = [
                            tool_type,
                            tool_name,
                            tool_version,
                            tool_classification,
                            vulnerability_language,
                            vulnerability_severity,
                            vulnerability_confidence,
                            vulnerability_cwe_id,
                            vulnerability_cwe_name,
                            vulnerability_cwe_description,
                            vulnerability_impact,
                            vulnerability_likelihood,
                            vulnerability_owasp_top_10,
                            vulnerability_mitre_top_25,
                            vulnerability_rule_id,
                            vulnerability_file,
                            vulnerability_line,
                        ]
                        log.info(f"Fetched vulnerability details: {vulnerability_cwe_id}")

                        # Add vulnerability data to CSV row
                        csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated")
            write_to_csv_report(csv_rows, csv_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Semgrep report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed Semgrep report: {sast_semgrep_report_filename}")
    return None


def parse_snyk_code_data(
    opencve_username: str,
    opencve_password: str,
    sast_snyk_code_report_filename: str,
    csv_filename: str,
) -> None:
    """Parse Snyk Code SAST JSON report and write data to output file

    :parameter
        opencve_username:str -- OpenCVE username
        opencve_password:str -- OpenCVE password
        sast_snyk_code_report_filename:str -- Name of Snyk Code JSON report to parse
        csv_filename:str -- Name of CSV report to write data to
    """
    log.info(f"Parsing Snyk Code report: {sast_snyk_code_report_filename}")
    with open(sast_snyk_code_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cwe_name_cache
    global cwe_description_cache

    try:
        report_runs = data["runs"][0]
        report_rules = get_json_value(report_runs, "tool", "driver", "rules")
        report_results = get_json_value(report_runs, "results")

        # Check if vulnerabilities exist in report
        if len(report_runs["results"]) == 0:
            log.info(f"No vulnerabilities found in Snyk Code report: {sast_snyk_code_report_filename}")
        else:
            # Get tool details
            tool_name = get_json_value(report_runs, "tool", "driver", "name")
            tool_version = get_json_value(data, "version")
            tool_type = "SAST"
            tool_classification = "Semantic"

            # Iterate through all vulnerabilities
            for vulnerability_rule in report_rules:
                vulnerability_rule_id = get_json_value(vulnerability_rule, "id")
                vulnerability_rule_property = vulnerability_rule["properties"]
                vulnerability_confidence = get_json_value(vulnerability_rule_property, "precision")

                # Iterate over each CWE ID
                for vulnerability_cwe_id in vulnerability_rule_property["cwe"]:
                    log.info(f"Getting vulnerability details: {vulnerability_cwe_id}")

                    vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                    vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                    # Set default values
                    vulnerability_cwe_name = default_not_found_value
                    vulnerability_cwe_description = default_not_found_value

                    if cwe_name_cache.get(vulnerability_cwe_id):
                        log.info(f"Getting vulnerability details from cache: {vulnerability_cwe_id}")

                        # Get CWE details from cache
                        vulnerability_cwe_name = cwe_name_cache.get(vulnerability_cwe_id)
                        vulnerability_cwe_description = cwe_description_cache.get(vulnerability_cwe_id)
                    else:
                        log.info(f"Vulnerability not in cache: {vulnerability_cwe_id}")
                        log.info(f"Getting vulnerability details from OpenCVE: {vulnerability_cwe_id}")

                        # Get CWE details from OpenCVE
                        opencve_cwe_details = send_get_request(
                            get_opencve_api_url(vulnerability_cwe_id), None, None, opencve_username, opencve_password
                        )
                        if opencve_cwe_details:
                            opencve_details = opencve_cwe_details.json()
                            vulnerability_cwe_name = get_json_value(opencve_details, "name")
                            vulnerability_cwe_description = get_json_value(opencve_details, "description")

                            log.info(f"Extracted vulnerability details from OpenCVE: {vulnerability_cwe_id}")
                        else:
                            log.error(f"Failed to extract vulnerability details from OpenCVE: {vulnerability_cwe_id}")

                        # Cache CWE details
                        cwe_name_cache.set(vulnerability_cwe_id, vulnerability_cwe_name)
                        cwe_description_cache.set(vulnerability_cwe_id, vulnerability_cwe_description)

                    # Iterate over results for each CWE
                    for vulnerability_result in report_results:
                        if vulnerability_rule_id == get_json_value(vulnerability_result, "ruleId"):
                            log.info(f"Found vulnerability result for rule ID: {vulnerability_rule_id}")

                            vulnerability_severity = get_snyk_code_severity_levels(get_json_value(vulnerability_result, "level"))
                            vulnerability_locations = get_json_value(vulnerability_result, "locations")[0]

                            vulnerability_file = get_json_value(vulnerability_locations, "physicalLocation", "artifactLocation", "uri")
                            vulnerability_line = get_json_value(vulnerability_locations, "physicalLocation", "region", "startLine")

                            vulnerability_results_data = [
                                tool_type,
                                tool_name,
                                tool_version,
                                tool_classification,
                                default_not_found_value,
                                vulnerability_severity,
                                vulnerability_confidence,
                                vulnerability_cwe_id,
                                vulnerability_cwe_name,
                                vulnerability_cwe_description,
                                default_not_found_value,
                                default_not_found_value,
                                vulnerability_owasp_top_10,
                                vulnerability_mitre_top_25,
                                vulnerability_rule_id,
                                vulnerability_file,
                                vulnerability_line,
                            ]
                            log.info(f"Fetched vulnerability details: {vulnerability_cwe_id}")

                            # Add vulnerability data to CSV row
                            csv_rows.append(vulnerability_results_data)

        log.info(f"{str(len(csv_rows))} CSV rows generated")
        write_to_csv_report(csv_rows, csv_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Snyk Code report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed Snyk Code report: {sast_snyk_code_report_filename}")
    return None


def parse_grype_data(
    nvd_api_key: str,
    sca_grype_report_filename: str,
    csv_filename: str,
) -> None:
    """Parse Grype SCA JSON report and write data to output file

    :parameter
        nvd_api_key:str -- NVD API key
        sca_grype_report_filename:str -- Name of Grype JSON report to parse
        csv_filename:str -- Name of CSV report to write data to
    """
    log.info(f"Parsing Grype report: {sca_grype_report_filename}")
    with open(sca_grype_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cve_published_date_cache
    global cve_last_modified_date
    global cve_cwe_id_cache

    try:
        # Check if vulnerabilities exist in report
        if data["matches"] is None or len(data["matches"]) == 0:
            log.info(f"No vulnerabilities found in Grype report: {sca_grype_report_filename}")
        else:
            tool_type = "SCA"
            tool_name = get_json_value(data, "descriptor", "name")
            tool_version = get_json_value(data, "descriptor", "version")
            tool_classification = "Metadata-based"

            # Iterate through all vulnerabilities
            for vulnerability_index in data["matches"]:
                vulnerability = get_json_value(vulnerability_index, "vulnerability")

                # Only consider vulnerabilities with CVE ID
                vulnerability_cve_id = get_json_value(vulnerability, "id")
                if "CVE" in vulnerability_cve_id:
                    log.info(f"Getting vulnerability details: {vulnerability_cve_id}")

                    vulnerability_language = get_json_value(vulnerability_index, "artifact", "language")
                    vulnerability_severity = get_json_value(vulnerability, "severity")

                    # Get Component details
                    vulnerability_component_purl = get_json_value(vulnerability_index, "artifact", "purl")
                    vulnerability_component_details = get_component_from_purl(vulnerability_component_purl)
                    vulnerability_component_type = vulnerability_component_details["type"]
                    vulnerability_component_name = vulnerability_component_details["name"]
                    vulnerability_component_version = vulnerability_component_details["version"]

                    # Convert list to comma-separated string
                    vulnerability_component_licenses = get_json_value(vulnerability_index, "artifact", "licenses")
                    vulnerability_component_license = convert_list_to_string(vulnerability_component_licenses)

                    # Get first uppermost path location
                    vulnerability_component_locations = get_json_value(vulnerability_index, "artifact", "locations")
                    vulnerability_component_location = vulnerability_component_locations[0]["path"]

                    # Get CVE details
                    vulnerability_cve_description = get_json_value(vulnerability_index, "description")
                    vulnerability_cve_source = get_json_value(vulnerability_index, "namespace")
                    vulnerability_cve_status = get_json_value(vulnerability_index, "fix", "state")

                    # Get CVSS vectors
                    vulnerability_cve_cvss_v2_vector = get_grype_cvss_vector(vulnerability, "2.0")
                    vulnerability_cve_cvss_v3_vector = get_grype_cvss_vector(vulnerability, "3.1", "3.0")
                    vulnerability_cve_cvss_v4_vector = get_grype_cvss_vector(vulnerability, "4.0")

                    # Set default values
                    vulnerability_cve_published_date = default_not_found_value
                    vulnerability_cve_last_modified_date = default_not_found_value
                    vulnerability_cwe_id = default_not_found_value

                    if cve_published_date_cache.get(vulnerability_cve_id):
                        log.info(f"Getting vulnerability details from cache: {vulnerability_cve_id}")

                        # Get CVE details from cache
                        vulnerability_cve_published_date = cve_published_date_cache.get(vulnerability_cve_id)
                        vulnerability_cve_last_modified_date = cve_last_modified_date.get(vulnerability_cve_id)
                        vulnerability_cwe_id = cve_cwe_id_cache.get(vulnerability_cve_id)
                    else:
                        log.info(f"Vulnerability not in cache: {vulnerability_cve_id}")
                        log.info(f"Getting additional CVE details from NVD: {vulnerability_cve_id}")

                        # Get additional CVE details from NVD
                        nvd_response = send_get_request(get_nvd_api_url(vulnerability_cve_id), nvd_api_key)
                        if nvd_response:
                            nvd_details = nvd_response.json()
                            if nvd_details["totalResults"] > 0:
                                nvd_cve_details = nvd_details["vulnerabilities"][0]
                                vulnerability_cve_published_date = get_json_value(nvd_cve_details, "cve", "published")
                                vulnerability_cve_last_modified_date = get_json_value(nvd_cve_details, "cve", "lastModified")

                                # Grype does not provide CWEs associated with the CVE ID, so we need to extract it from NVD
                                vulnerability_cwe_id = get_cwe_from_nvd(nvd_cve_details)
                                log.info(f"Extracted additional CVE details from NVD: {vulnerability_cve_status}")
                            else:
                                log.info(f"No additional CVE details found in NVD: {vulnerability_cve_id}")
                        else:
                            log.error(f"Failed to get additional CVE details from NVD: {vulnerability_cve_id}")

                        # Cache CVE details
                        cve_published_date_cache.set(vulnerability_cve_id, vulnerability_cve_published_date)
                        cve_last_modified_date.set(vulnerability_cve_id, vulnerability_cve_last_modified_date)
                        cve_cwe_id_cache.set(vulnerability_cve_id, vulnerability_cwe_id)

                    vulnerability_results_data = [
                        tool_type,
                        tool_name,
                        tool_version,
                        tool_classification,
                        vulnerability_language,
                        vulnerability_severity,
                        default_not_found_value,
                        vulnerability_component_type,
                        vulnerability_component_name,
                        vulnerability_component_version,
                        vulnerability_component_purl,
                        vulnerability_component_license,
                        vulnerability_component_location,
                        vulnerability_cve_id,
                        vulnerability_cve_description,
                        vulnerability_cve_source,
                        vulnerability_cve_published_date,
                        vulnerability_cve_last_modified_date,
                        vulnerability_cve_status,
                        default_not_found_value,
                        default_not_found_value,
                        vulnerability_cve_cvss_v2_vector,
                        vulnerability_cve_cvss_v3_vector,
                        vulnerability_cve_cvss_v4_vector,
                        vulnerability_cwe_id,
                    ]
                    log.info(f"Fetched vulnerability details: {vulnerability_cve_id}")

                    # Add vulnerability data to CSV row
                    csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated")
            write_to_csv_report(csv_rows, csv_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Grype report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed Grype report: {sca_grype_report_filename}")

    # Cleanup CVE caches
    clear_cve_caches()

    return None


def parse_snyk_data(
    nvd_api_key: str,
    sca_snyk_report_filename: str,
    csv_filename: str,
) -> None:
    """Parse Snyk SCA JSON report and write data to output file

    :parameter
        nvd_api_key:str -- NVD API key
        sca_snyk_report_filename:str -- Name of Snyk JSON report to parse
        csv_filename:str -- Name of CSV report to write data to
    """
    log.info(f"Parsing Snyk report: {sca_snyk_report_filename}")
    with open(sca_snyk_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cve_status_cache

    try:
        # Check if vulnerabilities exist in report
        if data["vulnerabilities"] is None or len(data["vulnerabilities"]) == 0:
            log.info(f"No vulnerabilities found in Snyk report: {sca_snyk_report_filename}")
        else:
            tool_type = "SCA"
            tool_name = "Snyk"
            tool_version = "1.1292.1"
            tool_classification = "Metadata-based"

            # Iterate through all vulnerabilities
            for vulnerability in data["vulnerabilities"]:
                # Only consider vulnerabilities with CVE ID
                for vulnerability_cve_id in vulnerability["identifiers"]["CVE"]:
                    log.info(f"Getting vulnerability details: {vulnerability_cve_id}")

                    vulnerability_language = get_json_value(vulnerability, "language")
                    vulnerability_severity = get_json_value(vulnerability, "severity")

                    # Get Component details
                    vulnerability_component_type = get_json_value(vulnerability, "packageManager")
                    vulnerability_component_name = get_json_value(vulnerability, "packageName")
                    vulnerability_component_version = get_json_value(vulnerability, "version")
                    vulnerability_component_purl = (
                        f"pkg:{vulnerability_component_type}/{vulnerability_component_name}@{vulnerability_component_version}"
                    )

                    vulnerability_component_path = get_json_value(data, "path")
                    vulnerability_component_file = get_json_value(data, "displayTargetFile")
                    vulnerability_component_location = f"{vulnerability_component_path}/{vulnerability_component_file}"

                    # Get CVE details
                    vulnerability_cve_description = get_json_value(vulnerability, "title")
                    vulnerability_cve_published_date = get_json_value(vulnerability, "publicationTime")
                    vulnerability_cve_last_modified_date = get_json_value(vulnerability, "modificationTime")
                    vulnerability_cve_malicious = str(get_json_value(vulnerability, "malicious"))
                    vulnerability_cve_disputed = str(get_json_value(vulnerability, "isDisputed"))

                    # Get CVSS vectors
                    vulnerability_cve_cvss_v2_vector = get_snyk_cvss_vector(vulnerability, "CVSSv2")
                    vulnerability_cve_cvss_v3_vector = get_snyk_cvss_vector(vulnerability, "CVSSv3")
                    vulnerability_cve_cvss_v4_vector = get_snyk_cvss_vector(vulnerability, "CVSSv4")

                    # Get CWE IDs
                    vulnerability_cwe_ids = get_json_value(vulnerability, "identifiers", "CWE")
                    vulnerability_cwe_id = convert_list_to_string(vulnerability_cwe_ids)

                    # Set default values
                    vulnerability_cve_status = default_not_found_value

                    if cve_status_cache.get(vulnerability_cve_id):
                        log.info(f"Getting vulnerability details from cache: {vulnerability_cve_id}")

                        # Get CVE details from cache
                        vulnerability_cve_status = cve_status_cache.get(vulnerability_cve_id)
                    else:
                        log.info(f"Vulnerability not in cache: {vulnerability_cve_id}")
                        log.info(f"Getting additional CVE details from NVD: {vulnerability_cve_id}")

                        # Get additional CVE details from NVD
                        nvd_response = send_get_request(get_nvd_api_url(vulnerability_cve_id), nvd_api_key)
                        if nvd_response:
                            nvd_details = nvd_response.json()
                            if nvd_details["totalResults"] > 0:
                                nvd_cve_details = nvd_details["vulnerabilities"][0]
                                vulnerability_cve_status = get_json_value(nvd_cve_details, "cve", "vulnStatus")
                                log.info(f"Extracted additional CVE details from NVD: {vulnerability_cve_status}")
                            else:
                                log.info(f"No additional CVE details found in NVD: {vulnerability_cve_id}")
                        else:
                            log.error(f"Failed to get additional CVE details from NVD: {vulnerability_cve_id}")

                        # Cache CVE details
                        cve_status_cache.set(vulnerability_cve_id, vulnerability_cve_status)

                    vulnerability_results_data = [
                        tool_type,
                        tool_name,
                        tool_version,
                        tool_classification,
                        vulnerability_language,
                        vulnerability_severity,
                        default_not_found_value,
                        vulnerability_component_type,
                        vulnerability_component_name,
                        vulnerability_component_version,
                        vulnerability_component_purl,
                        default_not_found_value,
                        vulnerability_component_location,
                        vulnerability_cve_id,
                        vulnerability_cve_description,
                        default_not_found_value,
                        vulnerability_cve_published_date,
                        vulnerability_cve_last_modified_date,
                        vulnerability_cve_status,
                        vulnerability_cve_malicious,
                        vulnerability_cve_disputed,
                        vulnerability_cve_cvss_v2_vector,
                        vulnerability_cve_cvss_v3_vector,
                        vulnerability_cve_cvss_v4_vector,
                        vulnerability_cwe_id,
                    ]
                    log.info(f"Fetched vulnerability details: {vulnerability_cve_id}")

                    # Add vulnerability data to CSV row
                    csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated")
            write_to_csv_report(csv_rows, csv_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Snyk report: {e}")
    else:
        log.info(f"Successfully parsed Snyk report: {sca_snyk_report_filename}")

    # Cleanup CVE caches
    clear_cve_caches()

    return None


def parse_owasp_dependency_check_data(
    nvd_api_key: str,
    sca_owasp_dependency_check_report_filename: str,
    csv_filename: str,
) -> None:
    """Parse OWASP Dependency Check SCA JSON report and write data to output file

    :parameter
        nvd_api_key:str -- NVD API key
        sca_owasp_dependency_check_report_filename:str -- Name of OWASP Dependency Check JSON report to parse
        csv_filename:str -- Name of CSV report to write data to
    """
    log.info(f"Parsing OWASP Dependency Check report: {sca_owasp_dependency_check_report_filename}")
    with open(sca_owasp_dependency_check_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cve_published_date_cache
    global cve_last_modified_date
    global cve_status_cache
    global cve_cvss_v2_vector_cache
    global cve_cvss_v3_vector_cache
    global cve_cvss_v4_vector_cache

    try:
        # Check if dependencies exist in report
        if data["dependencies"] is None or len(data["dependencies"]) == 0:
            log.info(f"No dependencies found in OWASP Dependency Check report: {sca_owasp_dependency_check_report_filename}")
        else:
            tool_type = "SCA"
            tool_name = "OWASP Dependency Check"
            tool_version = get_json_value(data, "scanInfo", "engineVersion")
            tool_classification = "Metadata-based"

            # Iterate through all dependencies
            for dependency in data["dependencies"]:
                dependency_packages = get_json_value(dependency, "packages")

                # Check if vulnerabilities exist in dependency and package details available
                if "vulnerabilities" in dependency and dependency_packages is not default_not_found_value:
                    for vulnerability in dependency["vulnerabilities"]:
                        # Only consider vulnerabilities with CVE ID
                        if "CVE" in vulnerability["name"]:
                            vulnerability_cve_id = get_json_value(vulnerability, "name")
                            log.info(f"Getting vulnerability details: {vulnerability_cve_id}")

                            # Get first uppermost path location
                            vulnerability_confidence = get_json_value(dependency_packages[0], "confidence")
                            vulnerability_severity = get_json_value(vulnerability, "severity")

                            # Get Component details
                            vulnerability_component_license = get_json_value(dependency, "license")
                            vulnerability_location = get_json_value(dependency, "filePath")
                            vulnerability_component_purl = get_json_value(dependency_packages[0], "id")
                            vulnerability_component_details = get_component_from_purl(vulnerability_component_purl)
                            vulnerability_component_type = vulnerability_component_details["type"]
                            vulnerability_component_name = vulnerability_component_details["name"]
                            vulnerability_component_version = vulnerability_component_details["version"]

                            # Get CVE details
                            vulnerability_cve_description = get_json_value(vulnerability, "description")
                            vulnerability_cve_source = get_json_value(vulnerability, "source")

                            # Get CWE IDs
                            vulnerability_cwe_ids = get_json_value(vulnerability, "cwes")
                            vulnerability_cwe_id = convert_list_to_string(vulnerability_cwe_ids)

                            # Set default values
                            vulnerability_cve_published_date = default_not_found_value
                            vulnerability_cve_last_modified_date = default_not_found_value
                            vulnerability_cve_status = default_not_found_value
                            vulnerability_cve_cvss_v2_vector = default_not_found_value
                            vulnerability_cve_cvss_v3_vector = default_not_found_value
                            vulnerability_cve_cvss_v4_vector = default_not_found_value

                            if cve_published_date_cache.get(vulnerability_cve_id):
                                log.info(f"Getting vulnerability details from cache: {vulnerability_cve_id}")

                                # Get CVE details from cache
                                vulnerability_cve_published_date = cve_published_date_cache.get(vulnerability_cve_id)
                                vulnerability_cve_last_modified_date = cve_last_modified_date.get(vulnerability_cve_id)
                                vulnerability_cve_status = cve_status_cache.get(vulnerability_cve_id)
                                vulnerability_cve_cvss_v2_vector = cve_cvss_v2_vector_cache.get(vulnerability_cve_id)
                                vulnerability_cve_cvss_v3_vector = cve_cvss_v3_vector_cache.get(vulnerability_cve_id)
                                vulnerability_cve_cvss_v4_vector = cve_cvss_v4_vector_cache.get(vulnerability_cve_id)
                            else:
                                log.info(f"Vulnerability not in cache: {vulnerability_cve_id}")
                                log.info(f"Getting additional CVE details from NVD: {vulnerability_cve_id}")

                                # Get additional CVE details from NVD
                                nvd_response = send_get_request(get_nvd_api_url(vulnerability_cve_id), nvd_api_key)
                                if nvd_response:
                                    nvd_details = nvd_response.json()
                                    if nvd_details["totalResults"] > 0:
                                        nvd_cve_details = nvd_details["vulnerabilities"][0]

                                        vulnerability_cve_published_date = get_json_value(nvd_cve_details, "cve", "published")
                                        vulnerability_cve_last_modified_date = get_json_value(nvd_cve_details, "cve", "lastModified")
                                        vulnerability_cve_status = get_json_value(nvd_cve_details, "cve", "vulnStatus")

                                        # Get CVSS vectors
                                        vulnerability_cve_metrics = get_json_value(nvd_cve_details, "cve", "metrics")
                                        vulnerability_cve_cvss_v2_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "2.0")
                                        vulnerability_cve_cvss_v3_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "3.1")
                                        if vulnerability_cve_cvss_v3_vector == default_not_found_value:
                                            vulnerability_cve_cvss_v3_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "3.0")
                                        vulnerability_cve_cvss_v4_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "4.0")

                                        log.info(f"Extracted additional CVE details from NVD: {vulnerability_cve_status}")
                                    else:
                                        log.info(f"No additional CVE details found in NVD: {vulnerability_cve_id}")
                                else:
                                    log.error(f"Failed to get additional CVE details from NVD: {vulnerability_cve_id}")

                                # Cache CVE details
                                cve_published_date_cache.set(vulnerability_cve_id, vulnerability_cve_published_date)
                                cve_last_modified_date.set(vulnerability_cve_id, vulnerability_cve_last_modified_date)
                                cve_status_cache.set(vulnerability_cve_id, vulnerability_cve_status)
                                cve_cvss_v2_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v2_vector)
                                cve_cvss_v3_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v3_vector)
                                cve_cvss_v4_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v4_vector)

                            vulnerability_results_data = [
                                tool_type,
                                tool_name,
                                tool_version,
                                tool_classification,
                                default_not_found_value,
                                vulnerability_severity,
                                vulnerability_confidence,
                                vulnerability_component_type,
                                vulnerability_component_name,
                                vulnerability_component_version,
                                vulnerability_component_purl,
                                vulnerability_component_license,
                                vulnerability_location,
                                vulnerability_cve_id,
                                vulnerability_cve_description,
                                vulnerability_cve_source,
                                vulnerability_cve_published_date,
                                vulnerability_cve_last_modified_date,
                                vulnerability_cve_status,
                                default_not_found_value,
                                default_not_found_value,
                                vulnerability_cve_cvss_v2_vector,
                                vulnerability_cve_cvss_v3_vector,
                                vulnerability_cve_cvss_v4_vector,
                                vulnerability_cwe_id,
                            ]
                            log.info(f"Fetched vulnerability details: {vulnerability_cve_id}")

                            # Add vulnerability data to CSV row
                            csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated")
            write_to_csv_report(csv_rows, csv_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse OWASP Dependency Check report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed OWASP Dependency Check report: {sca_owasp_dependency_check_report_filename}")

    # Cleanup CVE caches
    clear_cve_caches()

    return None


# =============
# Main function
# =============
def main(args: argparse.Namespace) -> None:
    """Main function of script

    :parameter
        args:argparse.Namespace -- Parsed arguments supplied to script
    """
    # SAST - CodeQL
    if args.sast_codeql_csv_result_filename:
        if args.github_organisation and args.github_repository:
            log.info(f"CodeQL GitHub repository found: {args.github_organisation}/{args.github_repository}")
            write_csv_report_header("sast", args.sast_codeql_csv_result_filename)

            codeql_data = get_codeql_data(
                args.github_token,
                args.github_organisation,
                args.github_repository,
            )
            parse_codeql_data(args.opencve_username, args.opencve_password, codeql_data, args.sast_codeql_csv_result_filename)
        else:
            log.error("CodeQL GitHub repository not found")
            sys.exit(1)

    # SAST - Horusec
    if args.sast_horusec_report_filename and args.sast_horusec_csv_result_filename:
        if os.path.isfile(args.sast_horusec_report_filename):
            log.info(f"Horusec report found: {args.sast_horusec_report_filename}")
            write_csv_report_header("sast", args.sast_horusec_csv_result_filename)

            parse_horusec_data(
                args.opencve_username,
                args.opencve_password,
                args.sast_horusec_report_filename,
                args.sast_horusec_csv_result_filename,
            )
        else:
            log.error(f"Horusec file not found: {args.sast_horusec_report_filename}")
            sys.exit(1)

    # SAST - Semgrep
    if args.sast_semgrep_report_filename and args.sast_semgrep_csv_result_filename:
        if os.path.isfile(args.sast_semgrep_report_filename):
            log.info(f"Semgrep report found: {args.sast_semgrep_report_filename}")
            write_csv_report_header("sast", args.sast_semgrep_csv_result_filename)

            parse_semgrep_data(
                args.opencve_username,
                args.opencve_password,
                args.sast_semgrep_report_filename,
                args.sast_semgrep_csv_result_filename,
            )
        else:
            log.error(f"Semgrep file not found: {args.sast_semgrep_report_filename}")
            sys.exit(1)

    # SAST - Snyk Code
    if args.sast_snyk_code_report_filename and args.sast_snyk_code_csv_result_filename:
        if os.path.isfile(args.sast_snyk_code_report_filename):
            log.info(f"Snyk Code report found: {args.sast_snyk_code_report_filename}")
            write_csv_report_header("sast", args.sast_snyk_code_csv_result_filename)

            parse_snyk_code_data(
                args.opencve_username,
                args.opencve_password,
                args.sast_snyk_code_report_filename,
                args.sast_snyk_code_csv_result_filename,
            )
        else:
            log.error(f"Snyk Code file not found: {args.sast_snyk_code_report_filename}")
            sys.exit(1)

    # SCA - Grype
    if args.sca_grype_report_filename and args.sca_grype_csv_result_filename:
        if os.path.isfile(args.sca_grype_report_filename):
            log.info(f"Grype report found: {args.sca_grype_report_filename}")
            write_csv_report_header("sca", args.sca_grype_csv_result_filename)

            parse_grype_data(
                args.nvd_api_key,
                args.sca_grype_report_filename,
                args.sca_grype_csv_result_filename,
            )
        else:
            log.error(f"Grype file not found: {args.sca_grype_report_filename}")
            sys.exit(1)

    # SCA - Snyk
    if args.sca_snyk_report_filename and args.sca_snyk_csv_result_filename:
        if os.path.isfile(args.sca_snyk_report_filename):
            log.info(f"Snyk report found: {args.sca_snyk_report_filename}")
            write_csv_report_header("sca", args.sca_snyk_csv_result_filename)

            parse_snyk_data(
                args.nvd_api_key,
                args.sca_snyk_report_filename,
                args.sca_snyk_csv_result_filename,
            )
        else:
            log.error(f"Snyk file not found: {args.sca_snyk_report_filename}")
            sys.exit(1)

    # SCA - OWASP Dependency Check
    if args.sca_owasp_dependency_check_report_filename and args.sca_owasp_dependency_check_csv_result_filename:
        if os.path.isfile(args.sca_owasp_dependency_check_report_filename):
            log.info(f"OWASP Dependency Check report found: {args.sca_owasp_dependency_check_report_filename}")
            write_csv_report_header("sca", args.sca_owasp_dependency_check_csv_result_filename)

            parse_owasp_dependency_check_data(
                args.nvd_api_key,
                args.sca_owasp_dependency_check_report_filename,
                args.sca_owasp_dependency_check_csv_result_filename,
            )
        else:
            log.error(f"OWASP Dependency Check file not found: {args.sca_owasp_dependency_check_report_filename}")
            sys.exit(1)

    # Cleanup CWE caches for unit testing
    clear_cwe_caches()


if __name__ == "__main__":
    """
    The starting point of the application
    Script should be running in the root dir of project
    """
    log = logging.getLogger()
    log.setLevel(logging.NOTSET)

    logging_handler_out = logging.StreamHandler(sys.stdout)
    logging_handler_out.setLevel(logging.INFO)
    logging_handler_out.addFilter(LogFilter(logging.INFO))
    log.addHandler(logging_handler_out)

    logging_handler_err = logging.StreamHandler(sys.stderr)
    logging_handler_err.setLevel(logging.ERROR)
    logging_handler_err.addFilter(LogFilter(logging.ERROR))
    log.addHandler(logging_handler_err)

    main(get_args(sys.argv[1:]))
