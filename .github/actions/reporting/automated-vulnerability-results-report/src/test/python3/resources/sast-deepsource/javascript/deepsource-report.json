{
  "data": {
    "repository": {
      "issues": {
        "totalCount": 66,
        "edges": [
          {
            "node": {
              "issue": {
                "title": "Call to Function object",
                "tags": [],
                "shortcode": "JS-R1003",
                "shortDescription": "Creating functions using the `Function` constructor can be avoided when all arguments are strings.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnFkcWVt",
                "description": "Creating functions using the `Function` constructor can be avoided when all arguments are strings.\n<!--more-->\nJS runtimes find it easier to optimize functions that are written in plain JavaScript syntax.\nConsider using arrow functions, or the `function` keyword instead.\n\n### Bad Practice\n\n```js\nconst add = new Function('a', 'b', 'return a + b')\nconst sub = Function('a', 'b', 'return a - b')\n```\n\n### Recommended\n\n```js\nconst add = function (a, b) { return a + b }\nconst sub = function (a, b) { return a - b }\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Useless template literal found",
                "tags": [],
                "shortcode": "JS-R1004",
                "shortDescription": "Template literals are useful when you need:  1. [Interpolated strings](https://en.wikipedia.org/wiki/String_interpolation).",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6enhqeXdq",
                "description": "Template literals are useful when you need:\n\n1. [Interpolated strings](https://en.wikipedia.org/wiki/String_interpolation).\n\n2. Strings that have unescaped double quotes **and** single quotes.\n\n3. Strings that need line breaks in them.\n\nIf neither of these three conditions is met,\nyou can replace the template expression with a regular string literal.\n\n### Bad Practice\n\n```js\nconst dialogue = `\"Journey before destination\", said Dalinar.`\nconst dialogue2 = `What is a 'Kwisatz Haderach'?`\n```\n\n### Recommended\n\n```js\nconst dialogue = '\"Journey before destination\", said Dalinar.'\nconst dialogue2 = \"What is a 'Kwisatz Haderach'?\"\nconst dialogue3 = `\"${getLine()}\", said ${getChararcter()}`\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found shorthand type coercions",
                "tags": [],
                "shortcode": "JS-0066",
                "shortDescription": "Prefer using explicit casts by calling `Number`, `Boolean`, or `String` over using operators like `+`, `!!` or `\"\" +`. This is considered best practice as it improves readability.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6emdlbG96",
                "description": "Prefer using explicit casts by calling `Number`, `Boolean`, or `String` over using operators like `+`, `!!` or `\"\" +`.\nThis is considered best practice as it improves readability.\n\n### Bad Practice\n```js\nconst b = !!foo;\n// The `+` operator does not change the value of its operand\n// unless it's already a number.\nlet n = +foo;\nn = 1 * foo;\nconst s = \"\" + foo;\n```\n\n### Recommended\n\n```js\nconst b = Boolean(foo);\nconst n = Number(foo);\nconst s = String(foo);\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found unused expressions",
                "tags": [],
                "shortcode": "JS-0093",
                "shortDescription": "An unused expression that does not affect the state of the program indicates a logic error.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnFwbmd6",
                "description": "An unused expression that does not affect the state of the program indicates a logic error.\n\n<!--more-->\n\nFor example, if a programmer wants to increment the value of a variable `a` by one, and intends to do so through this code:\n\n```js\nlet a = 0\na = a + 1\nconsole.log(a) // output 1\n```\n\nBut because of a typo, writes the following:\n\n```js\nlet a = 0\na + 1\nconsole.log(a)\n```\n\nHere, the expression `a + 1` does nothing meaningful in the program's runtime.\nThe expression is thus considered \"unused\" and should be removed.\n\n### Bad Practice\n\n```js\n0\n\nif(0) 0\n\n{0}\n\nf(0), {}\n\na, b()\n\nc = a, b;\n\na() && function namedFunctionInExpressionContext () {f();}\n\n(function anIncompleteIIFE () {});\n\ninjectGlobal`body{ color: red; }`\n\n```\n\n\n### Recommended\n\n```js\n{} // In this context, this is a block statement, not an object literal\n\n{myLabel: someVar} // In this context, this is a block statement with a label and expression, not an object literal\n\nfunction namedFunctionDeclaration () {}\n\n(function aGenuineIIFE () {}());\n\nf()\n\na = 0\n\nnew C\n\ndelete a.b\n\nvoid a\n```",
                "category": "BUG_RISK",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Prefer adding `u` flag in regular expressions",
                "tags": [],
                "shortcode": "JS-0117",
                "shortDescription": "It is recommended to use the `u` flag with regular expressions.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6emxtYWdi",
                "description": "It is recommended to use the `u` flag with regular expressions.\n\n<!--more-->\n\nThe `u` flag has two effects:\n- It enables correct handling of  UTF-16 surrogate pairs.\n- It ensures the correct behavior of regex character ranges.\n\n```js\n/^[üëç]$/.test(\"üëç\") //‚Üí false\n/^[üëç]$/u.test(\"üëç\") //‚Üí true\n```\n\nFor historical reasons, JavaScript regular expressions tolerate syntax errors.\nFor example, `/\\w{1, 2/` is a regex that would throw a syntax error, but JavaScript chooses not to.\nIt matches strings such as `\"a{1, 2\"` instead.\nThis behaviour is defined in Annex B of the Javascript specification.\n\nThe `u` flag disables the recovering logic `Annex B` of the Javascript specification.\nThis way, you can find errors early.\nIt can therefore be thought of as a \"strict mode\" for RegEx literals.\n\nThis issue is raised when:\n- A regular expression contains unicode property escapes i.e `\\p{<property-name>}`\n- A regular expression contains 4 bytes characters like emojis or some special characters\n\n### Bad Practice\n\n```js\nconst a = /aaa/\nconst b = /bbb/gi\nconst c = new RegExp(\"ccc\")\nconst d = new RegExp(\"ddd\", \"gi\")\n```\n\n### Recommended\n\n```js\nconst a = /aaa/u\nconst b = /bbb/giu\nconst c = new RegExp(\"ccc\", \"u\")\nconst d = new RegExp(\"ddd\", \"giu\")\n\n// This rule ignores RegExp calls if the flags are not a compile time constant.\nfunction f(flags) {\n    return new RegExp(\"eee\", flags)\n}\n```\n\n\n## References\n\n- [Regular Expressions Patterns](https://www.ecma-international.org/ecma-262/6.0/#sec-regular-expressions-patterns)\n- [JavaScript strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)\n- [Unicode properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "`Object.prototype` builtins should not be used directly",
                "tags": [],
                "shortcode": "JS-0021",
                "shortDescription": "It is preferable to call certain `Object.prototype` methods through `Object` on object instances instead of using the builtins directly.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6emxtdmdi",
                "description": "It is preferable to call certain `Object.prototype` methods through `Object` on object instances instead of using the builtins directly.\n\n<!--more-->\n\nObjects can have properties that shadow the builtins on `Object.prototype`, potentially causing unintended behavior or denial-of-service security vulnerabilities.\n\nFor example, it would be unsafe for a webserver to parse JSON input from a client and call `hasOwnProperty` directly on the resulting object, because a malicious client could send a JSON value like `{\"hasOwnProperty\": 1}` and cause the server to crash.\n\nIt's better to always call these methods from `Object.prototype`. For example, `obj.hasOwnProperty(\"bar\")` should be replaced with `Object.prototype.hasOwnProperty.call(obj, \"bar\")`.\n\n### Bad Practice\n\n```js\nlet hasBarProperty = obj.hasOwnProperty(\"property\");\n\nlet isPrototypeOfBar = obj.isPrototypeOf(property);\n\nlet barIsEnumerable = obj.propertyIsEnumerable(\"property\");\n```\n\n### Recommended\n\n```js\nlet hasBarProperty = Object.prototype.hasOwnProperty.call(obj, \"property\");\n\nlet isPrototypeOfBar = Object.prototype.isPrototypeOf.call(obj, property);\n\nlet barIsEnumerable = {}.propertyIsEnumerable.call(obj, \"property\");\n```",
                "category": "BUG_RISK",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found `new` operators with the `String`, `Number` and `Boolean` Objects",
                "tags": [],
                "shortcode": "JS-0080",
                "shortDescription": "There are three primitive types in JavaScript that have wrapper objects: `string`, `number`, and `boolean`. These are represented by the constructors `String`, `Number`, and `Boolean` respectively. The primitive wrapper types are used whenever one of these primitive values is read, providing them with object-like capabilities such as methods.\n\nIt's also possible to manually create a new wrapper instance:\n\n```js\nconst stringObject = new String(\"Hello world\");\nconst numberObject = new Number(33);\nconst booleanObject = new Boolean(false);\n```\n\nAlthough possible, there aren't any good reasons to use these primitive wrappers as constructors. They tend to confuse other developers more than anything else because they seem like they should act as primitives, but they do not.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YmFuZ296",
                "description": "There are three primitive types in JavaScript that have wrapper objects: `string`, `number`, and `boolean`. These are represented by the constructors `String`, `Number`, and `Boolean` respectively. The primitive wrapper types are used whenever one of these primitive values is read, providing them with object-like capabilities such as methods.\n\nIt's also possible to manually create a new wrapper instance:\n\n```js\nconst stringObject = new String(\"Hello world\");\nconst numberObject = new Number(33);\nconst booleanObject = new Boolean(false);\n```\n\nAlthough possible, there aren't any good reasons to use these primitive wrappers as constructors. They tend to confuse other developers more than anything else because they seem like they should act as primitives, but they do not.\n\n<!--more-->\n\n```js\nconst stringObject = new String(\"Hello world\");\nconsole.log(typeof stringObject);       // \"object\"\n\nconst text = \"Hello world\";\nconsole.log(typeof text);               // \"string\"\n\nconst booleanObject = new Boolean(false);\nif (booleanObject) {                    // all objects are truthy!\n    console.log(\"This executes\");\n}\n```\n\n1. The first problem is that primitive wrapper objects are, in fact, `objects`. That means `typeof` will return \"object\" instead of \"string\", \"number\", or \"boolean\".\n\n2. The second problem comes with `boolean` objects. Every object is truthy, which means an instance of `Boolean` always resolves to true even when its actual value is `false`. For these reasons, it's considered a best practice to avoid using primitive wrapper types with `new`.\n\n### Bad Practice\n\n```\nconst stringObject = new String(\"Hello world\");\nconst numberObject = new Number(33);\nconst booleanObject = new Boolean(false);\n\nconst stringObject = new String;\nconst numberObject = new Number;\nconst booleanObject = new Boolean;\n```\n\n### Recommended\n\n```js\nconst text = String(someValue);\nconst num = Number(someValue);\nconst object = new MyString();\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found trailing undefined in function call",
                "tags": [],
                "shortcode": "JS-W1042",
                "shortDescription": "When an argument is omitted from a function call, it will default to `undefined`. It is therefore redundant to explicitly pass an `undefined` literal as the last argument.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnBqeHhn",
                "description": "When an argument is omitted from a function call, it will default to `undefined`.\nIt is therefore redundant to explicitly pass an `undefined` literal as the last argument.\n\n### Bad Practice\n\n```typescript\nfunction hasOptionalParam(a: number, b?: number) {\n  // ...\n}\n\nhasOptionalParam(1, undefined)\n```\n\n### Recommended\n\n```typescript\nfunction hasOptionalParam(a: number, b?: number) {\n  // ...\n}\n\nhasOptionalParam(1)\nhasOptionalParam(1, 2)\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Suggest correct usage of shebang",
                "tags": [],
                "shortcode": "JS-0271",
                "shortDescription": "The issue checks for incorrect or missing shebang in files mentioned in the `bin` field of the `package.json`.\nWhen creating a CLI tool with Node.js, it is necessary to add a shebang to the file that serves as the entry point for the application.\nAs the NPM docs say, the file(s) referenced in `bin` must start with `#!/usr/bin/env node`, or the scripts won't be run with the Node.js executable.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6Ym95cWVi",
                "description": "The issue checks for incorrect or missing shebang in files mentioned in the `bin` field of the `package.json`.\nWhen creating a CLI tool with Node.js, it is necessary to add a shebang to the file that serves as the entry point for the application.\nAs the NPM docs say, the file(s) referenced in `bin` must start with `#!/usr/bin/env node`, or the scripts won't be run with the Node.js executable.\n\n<!--more-->\nThe `bin` field in package.json is used to specify JS files which run as tools when launched with the Node.js launcher.\n\n### Bad Practice\n\nIncorrect shebang:\n\n```js\n// /user/bin/env node\nconsole.log(\"App launched\");\n```\n\nNo shebang in a file referenced in package.json's `bin` field:\n\n```js\nconsole.log(\"App launched\")\n```\n\n### Recommended\n\nThe following code snippet is assumed to be in a file that is referenced in the `bin` field:\n\n```js\n#!/usr/bin/env node\nconsole.log(\"App launched\");\n```\n\n## References\n\n- [`bin` - npm](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#bin)\n- [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix))",
                "category": "BUG_RISK",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Logical operator can be refactored to optional chain",
                "tags": [],
                "shortcode": "JS-W1044",
                "shortDescription": "The [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) operator can be used to perform null checks before accessing a property, or calling a function.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6emV2a3Z5",
                "description": "The [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)\noperator can be used to perform null checks before accessing a property, or calling a function.\n\nUsing `&&` for this purpose is no longer required.\n\n### Bad Practice\n\n```typescript\nfunction getUsernameFromId(id: number): string | undefined {\n  const user = db.getUser(id)\n  return user && user.name\n}\n\nsomeFunc && someFunc()\n//        ^~~~ not necessary\n\nmaybeArray && maybeArray[index]\n//          ^~~~ not necessary\n```\n\n### Recommended\n\n```typescript\nfunction getUsernameFromId(id: number): string | undefined {\n  const user = db.getUser(id)\n  return user?.name\n}\n\nsomeFunc?.()\n\nmaybeArray?.[index]\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Avoid use of `==` and `!=`",
                "tags": [],
                "shortcode": "JS-0050",
                "shortDescription": "It is considered good practice to use the type-safe equality operators `===` and `!==` instead of their regular counterparts `==` and `!=`.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6enlnd2F6",
                "description": "It is considered good practice to use the type-safe equality operators `===` and `!==` instead of their regular counterparts `==` and `!=`.\n\n<!--more-->\n\nThe strict equality operators (`===` and `!==`) use the strict equality comparison algorithm to compare two operands.\n\n- If the operands are of different types, return `false`.\n- If both operands are objects, return `true` only if they refer to the same object.\n- If both operands are `null` or both operands are `undefined`, return `true`.\n- If either operand is `NaN`, return `false`.\n- Otherwise, compare the two operand's values:\n    - Numbers must have the same numeric values. `+0` and `-0` are considered to be the same value.\n    - Strings must have the same characters in the same order.\n    - Booleans must be both `true` or both `false`.\n\nThe most notable difference between this operator and the equality (`==`) operator is that if the operands are of different types, the `==` operator attempts to convert them to the same type before comparing.\n\n### Bad Practice\n```js\na == b\nfoo == true\nbananas != 1\nvalue == undefined\ntypeof foo == 'undefined'\n'hello' != 'world'\n0 == 0\ntrue == true\nfoo == null\n```\n\n### Recommended\n```js\na === b\nfoo === true\nbananas !== 1\nvalue === undefined\ntypeof foo === 'undefined'\n'hello' !== 'world'\n0 === 0\ntrue === true\nfoo === null\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Prefer that `for-in` loops should include an `if` statement",
                "tags": [],
                "shortcode": "JS-0051",
                "shortDescription": "Looping over objects with a `for in` loop will include properties that are inherited through the prototype chain. This behavior can lead to unexpected keys in your for loop.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6empkcWp6",
                "description": "Looping over objects with a `for in` loop will include properties that are inherited through the prototype chain.\nThis behavior can lead to unexpected keys in your for loop.\n\n### Bad Practice\n```js\nfor (const key in foo) {\n    doSomething(key);\n}\n```\n\n### Recommended\n```js\nfor (const key in foo) {\n    if (Object.prototype.hasOwnProperty.call(foo, key)) {\n        doSomething(key);\n    }\n}\n\nfor (const key of Object.keys(foo)) {\n    doSomething(key);\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found empty functions",
                "tags": [],
                "shortcode": "JS-0057",
                "shortDescription": "Having empty functions hurts readability, and is considered a code-smell. There's almost always a way to avoid using them. If you must use one, consider adding a comment to inform the reader of its purpose.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6end3anh6",
                "description": "Having empty functions hurts readability, and is considered a code-smell.\nThere's almost always a way to avoid using them.\nIf you must use one, consider adding a comment to inform the reader of its purpose.\n\n### Bad Practice\n\n```ts\ngetUser('SwaGaLisTiQuE', () => {})\n\nfunction f() {}\n```\n\n### Recommended\n\n```ts\ngetUser('SwaGaLisTiQuE', () => {\n    // empty because <reason>\n})\n\nfunction f() {\n    // intentionally empty. <reason>\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "`eval()` should not be used",
                "tags": [
                  "a03",
                  "2021",
                  "owasp-top-10"
                ],
                "shortcode": "JS-0060",
                "shortDescription": "JavaScript's `eval()` function is potentially dangerous and is often misused.\nUsing `eval()` on untrusted code can open a program up to several different injection attacks.\nThe use of `eval()` in most contexts can be substituted for a better, alternative approach to the problem.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ym9kb216",
                "description": "JavaScript's `eval()` function is potentially dangerous and is often misused.\nUsing `eval()` on untrusted code can open a program up to several different injection attacks.\nThe use of `eval()` in most contexts can be substituted for a better, alternative approach to the problem.\n\n<!--more-->\n\n### Bad Practice\n\n```js\nconst obj = { x: \"foo\" }\nconst key = \"x\"\nconst value = eval(\"obj.\" + key);\n\n(0, eval)(\"var a = 0\");\n\nconst foo = eval;\nfoo(\"var a = 0\");\n\n// This `this` is the global object.\nthis.eval(\"var a = 0\");\n```\n\n### Recommended\n\n```js\nconst obj = { x: \"foo\" },\n    key = \"x\",\n    value = obj[key];\n\nclass A {\n    foo() {\n        // This is a user-defined method.\n        this.eval(\"var a = 0\");\n    }\n\n    eval() { /* ... * / }\n}\n```\n\n## References\n- [OWASP A03:2021 - Injection](https://owasp.org/Top10/A03_2021-Injection/)\n- [OWASP Direct Dynamic Code Evaluation - Eval Injection](https://owasp.org/www-community/attacks/Direct_Dynamic_Code_Evaluation_Eval%20Injection)",
                "category": "SECURITY",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Prefer not to extend native types",
                "tags": [],
                "shortcode": "JS-0061",
                "shortDescription": "In JavaScript, you can extend any object, including builtin or \"native\" objects. Sometimes people change the behavior of these native objects in ways that break the assumptions made about them in other parts of the code.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YmR3d3h6",
                "description": "In JavaScript, you can extend any object, including builtin or \"native\" objects.\nSometimes people change the behavior of these native objects in ways that break the assumptions made about them in other parts of the code.\n\n\n### Bad Practice\n```js\n// seems harmless\nObject.prototype.extra = 55;\n\n// loop through some userIds\nconst users = {\n    \"123\": \"Stan\",\n    \"456\": \"David\"\n};\n\n// not what you'd expect\nfor (const id in users) {\n    console.log(id); // \"123\", \"456\", \"extra\"\n}\n```\nIn the above example, a common suggestion to avoid this problem would be to wrap the inside of the `for` loop with `users.hasOwnProperty(id)`.\n\n### Recommended\n\n```js\nObject.prototype.a = \"a\";\nObject.defineProperty(Array.prototype, \"times\", { value: 999 });\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Fallthrough of `case` statements found",
                "tags": [],
                "shortcode": "JS-0064",
                "shortDescription": "If the fallthrough is intentional in the code, there is no way to indicate this intent in the language. It's considered a best practice to always indicate when a fallthrough is intentional using a comment which matches the `/falls?\\s?through/i` regular expression.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YmV5ZG5i",
                "description": "If the fallthrough is intentional in the code, there is no way to indicate this intent in the language.\nIt's considered a best practice to always indicate when a fallthrough is intentional using a comment which matches the `/falls?\\s?through/i` regular expression.\n\n### Bad Practice\n```js\nswitch(foo) {\n    case 1: doSomething();\n    case 2: doSomethingElse();\n}\n```\n\n### Recommended\n```js\nswitch(foo) {\n    case 1:\n        doSomething();\n        break;\n    case 2:\n        doSomethingElse();\n}\n\nfunction bar(foo) {\n    switch(foo) {\n        case 1:\n            doSomething();\n            return;\n        case 2:\n            doSomething();\n    }\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        throw new Error(\"Boo!\");\n    case 2:\n        doSomething();\n}\n\nswitch(foo) {\n    case 1:\n    case 2:\n        doSomething();\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        // falls through\n    case 2:\n        doSomething();\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found labeled statements",
                "tags": [],
                "shortcode": "JS-0071",
                "shortDescription": "Labeled statements in JavaScript are used in conjunction with `break` and `continue` to control flow around multiple loops. For example:",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnlueWF6",
                "description": "Labeled statements in JavaScript are used in conjunction with `break` and `continue` to control flow around multiple loops. For example:\n\n```js\nouter:\n    while (cond()) {\n        while (cond2()) {\n            break outer;\n        }\n    }\n```\nWhile convenient in some cases, labels tend to be used only rarely and are frowned upon by some as a remedial form of flow control that is more error prone and harder to understand.\n\n### Bad Practice\n```js\nlabel:\n    while(cond()) { /* ... */ }\n\nlabel:\n    while(foo) {\n        break label;\n    }\n\nlabel:\n    while(bar) {\n        continue label;\n    }\n\nlabel:\n    switch (a) {\n    case 0:\n        break label;\n    }\n\nlabel:\n    {\n        break label;\n    }\n\nlabel:\n    if (a) {\n        break label;\n    }\n```\n\n### Recommended\n\n```js\nconst x = {\n    label: \"foo\"\n};\n\nwhile (true) {\n    // code\n    break;\n}\n\nwhile (true) {\n    // code\n    continue;\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found unsafe function declarations",
                "tags": [],
                "shortcode": "JS-0073",
                "shortDescription": "Writing functions within loops tends to result in errors due to the way the function creates a closure around the loop. For example:",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6enFub2Ri",
                "description": "Writing functions within loops tends to result in errors due to the way the function creates a closure around the loop. For example:\n\n```js\nfor (var i = 0; i < 10; i++)\n    funcs[i] = function() {\n        return i;\n    };\n}\n```\n\nIn this case, you would expect each function created within the loop to return a different number. In reality, each function returns 10, because that was the last value of i in the scope.\n\n`let` or `const` mitigate this problem.\n\n```js\nfor (let i = 0; i < 10; i++) {\n    funcs[i] = function() {\n        return i;\n    };\n}\n```\nIn this case, each function created within the loop returns a different number as expected.\n\n### Bad Practice\n```js\nfor (let i = 10; i; i--) {\n    (function() { return i; })();\n}\n\nwhile(i) {\n    const a = function() { return i; };\n    a();\n}\n\ndo {\n    function a() { return i; };\n    a();\n} while (i);\n\nlet foo = 0;\nfor (let i = 0; i < 10; ++i) {\n    //Bad, `foo` is not in the loop-block's scope and `foo` is modified in/after the loop\n    setTimeout(() => console.log(foo));\n    foo += 1;\n}\n\nfor (let i = 0; i < 10; ++i) {\n    //Bad, `foo` is not in the loop-block's scope and `foo` is modified in/after the loop\n    setTimeout(() => console.log(foo));\n}\nfoo = 100;\n```\n\n### Recommended\n\n```js\nlet a = function() {};\n\nfor (let i = 10; i; i--) {\n    a();\n}\n\nfor (let i = 10; i; i--) {\n    const a = function() {}; // OK, no references to variables in the outer scopes.\n    a();\n}\n\nfor (let i = 10; i; i--) {\n    const a = function() { return i; }; // OK, all references are referring to block scoped variables in the loop.\n    a();\n}\n\nconst foo = 100;\nfor (let i = 10; i; i--) {\n    const a = function() { return foo; }; // OK, all references are referring to never modified variables.\n    a();\n}\n//... no modifications of foo after this loop ...\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Assignments to native objects or read-only global variables is not preferred",
                "tags": [],
                "shortcode": "JS-0077",
                "shortDescription": "JavaScript environments contain a number of built-in global variables, such as `window` in browsers and `process` in Node.js. In almost all cases, you don't want to assign a value to these global variables as doing so could result in losing access to important functionality. For example, you probably don't want to do this in browser code:",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6enJleGVi",
                "description": "JavaScript environments contain a number of built-in global variables, such as `window` in browsers and `process` in Node.js.\nIn almost all cases, you don't want to assign a value to these global variables as doing so could result in losing access to important functionality.\nFor example, you probably don't want to do this in browser code:\n\n```js\nwindow = {};\n```\nWhile examples such as `window` are obvious, there are often hundreds of built-in global objects provided by JavaScript environments. It can be hard to know if you're assigning to a global variable or not.\n\n### Bad Practice\n\n```js\nObject = null\nundefined = 1\nwindow = {}\n```\n\n### Recommended\n\n```js\nconst a = 1\nlet b = 1\nb = 2\nconst onload = function() {}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found redeclared variables",
                "tags": [],
                "shortcode": "JS-0085",
                "shortDescription": "The `var` keyword is soft-deprecated, and should not be used to redeclare existing variables.  <!-- more -->",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6Ynhub3Ji",
                "description": "The `var` keyword is soft-deprecated, and should not be used to redeclare existing variables.\n\n<!-- more -->\n\nIt is possible to re-declare the same variable using the `var` keyword:\n\n```js\nvar a = 1;\nvar a = 10; // valid!\n```\n\nHowever, this can have unintentional side effects on the code:\n\n```js\nvar x = 10;\n{\n  var x = 20;\n}\nconsole.log(x); // 20\n```\n\n### Bad Practice\n\n```js\nvar db = dbDriver.loadTables()\n{\n  var db = db.get(\"usersId:1234\") // bad practice!\n}\n```\n\n### Recommended\n\n```js\n\n// always use 'let' or 'const'\nconst db = dbDriver.loadTables();\n{\n  const users = db.get(\"userId:1234\") // avoid shadowing\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "The usage of `javascript:` urls is not recommended",
                "tags": [],
                "shortcode": "JS-0087",
                "shortDescription": "Using `javascript: URLs` is considered by some as a form of `eval`. Code passed in `javascript: URLs` has to be parsed and evaluated by the browser in the same way that `eval` is processed.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnZuZXZi",
                "description": "Using `javascript: URLs` is considered by some as a form of `eval`.\nCode passed in `javascript: URLs` has to be parsed and evaluated by the browser in the same way that `eval` is processed.\n\n### Bad Practice\n```js\nlocation.href = \"javascript:void(0)\";\n```\n\n### Recommended\n```js\nlocation.href = \"https://deepsource.io\"\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Comparisons found where both the sides are exactly the same",
                "tags": [],
                "shortcode": "JS-0089",
                "shortDescription": "Comparing a variable against itself is usually an error, either a typo or refactoring error. It is confusing to the reader and may potentially introduce a runtime error. The only time you would compare a variable against itself is when you are testing for `NaN`.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6enlnbWd6",
                "description": "Comparing a variable against itself is usually an error, either a typo or refactoring error.\nIt is confusing to the reader and may potentially introduce a runtime error.\nThe only time you would compare a variable against itself is when you are testing for `NaN`.\nHowever, it is far more appropriate to use `typeof x === 'number' && isNaN(x)` or the `Number.isNaN ES2015 function` for that use case rather than leaving the reader to determine the intent of self comparison.\n\n### Bad Practice\n```js\nconst x = 10;\nif (x === x) {\n    x = 20;\n}\n```\n\n### Recommended\n```js\nif (x == y) {\n    x = y + 10\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Throwing literals as exceptions is not recommended",
                "tags": [],
                "shortcode": "JS-0091",
                "shortDescription": "It is considered good practice to only `throw` the `Error` object itself or an object using the `Error` object as base objects for user-defined exceptions. The benefit of `Error` objects is that they automatically keep track of where they were built and originated. This rule restricts what can be thrown as an exception.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnFwZW56",
                "description": "It is considered good practice to only `throw` the `Error` object itself or an object using the `Error` object as base objects for user-defined exceptions.\nThe benefit of `Error` objects is that they automatically keep track of where they were built and originated.\nThis rule restricts what can be thrown as an exception.\n\n### Bad Practice\n```js\nthrow \"error\";\n\nthrow 0;\n\nthrow undefined;\n\nthrow null;\n\nvar err = new Error();\nthrow \"an \" + err;\n// err is recast to a string literal\n\nvar err = new Error();\nthrow `${err}`\n```\n\n### Recommended\n\n```js\nthrow new Error();\n\nthrow new Error(\"error\");\n\nvar e = new Error(\"error\");\nthrow e;\n\ntry {\n    throw new Error(\"error\");\n} catch (e) {\n    throw e;\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found unnecessary escape characters",
                "tags": [],
                "shortcode": "JS-0097",
                "shortDescription": "Escaping non-special characters in strings, template literals, and regular expressions doesn't have any effect.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6emRhdnli",
                "description":"Escaping non-special characters in strings",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Void operators found",
                "tags": [],
                "shortcode": "JS-0098",
                "shortDescription": "A `return;` statement with nothing after it is redundant, and has no effect on the runtime behavior of a function. This can be confusing, so it's better to disallow these redundant statements.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6em5nZGxi",
                "description": "A `return;` statement with nothing after it is redundant, and has no effect on the runtime behavior of a function.\nThis can be confusing, so it's better to disallow these redundant statements.\n\n### Bad Practice\n\n```js\nfunction foo() { return; }\n\nfunction foo() {\n  doSomething();\n  return;\n}\n\nfunction foo() {\n  if (condition) {\n    bar();\n    return;\n  } else {\n    baz();\n  }\n}\n\nfunction foo() {\n  switch (bar) {\n    case 1:\n      doSomething();\n    default:\n      doSomethingElse();\n      return;\n  }\n}\n```\n\n### Recommended\n\n```js\nfunction foo() { return 5; }\n\nfunction foo() {\n  return doSomething();\n}\n\nfunction foo() {\n  if (condition) {\n    bar();\n    return;\n  } else {\n    baz();\n  }\n  qux();\n}\n\nfunction foo() {\n  switch (bar) {\n    case 1:\n      doSomething();\n      return;\n    default:\n      doSomethingElse();\n  }\n}\n\nfunction foo() {\n  for (const foo of bar) {\n    return;\n  }\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Prefer var declarations be placed at the top of their scope",
                "tags": [
                  "javascript"
                ],
                "shortcode": "JS-0102",
                "shortDescription": "Declare variables at the top of their scope as it improves code readability, performance and also helps in code navigation.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6emp3eHhi",
                "description": "Declare variables at the top of their scope as it improves code readability, performance and also helps in code navigation.\n\n<!--more-->\n\nThe `vars-on-top` rule generates warnings when variable declarations are not used serially at the top of a function scope or the top of a program. By default variable declarations are always moved (‚Äúhoisted‚Äù) invisibly to the top of their containing scope by the JavaScript interpreter. This rule forces the programmer to represent that behavior by manually moving the variable declaration to the top of its containing scope.\n\n### Bad Practice\n```js\n// Variable declarations in a block:\nfunction doSomething() {\n    var first;\n    if (true) {\n        first = true;\n    }\n    var second;\n}\n\n// Variable declaration in for initializer:\nfunction doSomething() {\n    for (var i=0; i<10; i++) {}\n}\n```\n\n### Recommended\n```js\nfunction doSomething() {\n    var first;\n    var second; //multiple declarations are allowed at the top\n    if (true) {\n        first = true;\n    }\n}\n\nfunction doSomething() {\n    var i;\n    for (i=0; i<10; i++) {}\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Prefer the usage of regular expression literals over the `RegExp` constructor",
                "tags": [],
                "shortcode": "JS-0115",
                "shortDescription": "When a regular expression is known in advance, it is considered a best practice to avoid the string literal notation on top of the regular expression notation, and use regular expression literals instead of the constructor function.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6enZucmV6",
                "description": "When a regular expression is known in advance, it is considered a best practice to avoid the string literal notation on top of the regular expression notation, and use regular expression literals instead of the constructor function.\n\n```js\n// bad practice:\nconst number  = new RegExp(\"^\\d\\.$\");\n// recommended:\nconst number_ = /^\\d\\.$/;\n```\n\nRegex literals are easier to read and do not require a call to the `RegExp` constructor at runtime.\n\n### Bad Practice\n\n```js\nnew RegExp(\"abc\");\n\nnew RegExp(\"abc\", \"u\");\n\nRegExp(\"abc\");\n\nRegExp(\"abc\", \"u\");\n\nnew RegExp(\"\\d\\d\\.\\d\\d\\.\\d\\d\\d\\d\");\n\nRegExp(`^\\d\\.$`);\n\nnew RegExp(String.raw`^\\d\\.$`);\n```\n\n### Recommended\n\n```js\n/abc/;\n\n/abc/u;\n\n/\\d\\d\\.\\d\\d\\.\\d\\d\\d\\d/;\n\n/^\\d\\.$/;\n\n// RegExp constructor is allowed for dynamically generated regular expressions\n\nnew RegExp(pattern);\n\nRegExp(\"abc\", flags);\n\nnew RegExp(prefix + \"abc\");\n\nRegExp(`${prefix}abc`);\n\nnew RegExp(String.raw`^\\d\\. ${sufix}`);\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Usage of `strict` mode against recommended approach",
                "tags": [],
                "shortcode": "JS-0118",
                "shortDescription": "A strict mode directive is a `\"use strict\"` literal at the beginning of a script or function body. It enables strict mode semantics.  When a directive occurs in global scope, strict mode applies to the entire script:",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6emF2ZHhi",
                "description": "A strict mode directive is a `\"use strict\"` literal at the beginning of a script or function body. It enables strict mode semantics.\n\nWhen a directive occurs in global scope, strict mode applies to the entire script:\n\n```js\n\"use strict\";\n\n// strict mode\n\nfunction foo() {\n    // strict mode\n}\n```\n\nWhen a directive occurs at the beginning of a function body, strict mode applies only to that function, including all contained functions:\n\n```js\nfunction foo() {\n    \"use strict\";\n    // strict mode\n}\n\nfunction foo2() {\n    // not strict mode\n};\n\n(function() {\n    \"use strict\";\n    function bar() {\n        // strict mode\n    }\n}());\n```\n\nIn the CommonJS module system, a hidden function wraps each module and limits the scope of a \"global\" strict mode directive.\n\nIn ECMAScript modules, which always have strict mode semantics, the directives are unnecessary.\n\n### Bad Practice\n\n```js\nfunction foo() {\n}\n\nfunction foo() {\n    \"use strict\";\n}\n\n\"use strict\";\n\nfunction foo() {\n    \"use strict\";\n}\n\n```\n\n### Recommended\n\n```js\nfunction foo() {\n}\n\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Initialization in variable declarations against recommended approach",
                "tags": [],
                "shortcode": "JS-0119",
                "shortDescription": "In JavaScript, variables can be assigned during declaration, or at any point afterwards using an assignment statement. For example, in the following code, `foo` is initialized during declaration, while `bar` is initialized later.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ym1ueHF6",
                "description": "In JavaScript, variables can be assigned during declaration, or at any point afterwards using an assignment statement. For example, in the following code, `foo` is initialized during declaration, while `bar` is initialized later.\n\n```js\nvar foo = 1;\nvar bar;\n\nif (foo) {\n    bar = 1;\n} else {\n    bar = 2;\n}\n```\n\n### Bad Practice\n\n```js\nfunction foo() {\n    var bar;\n    let baz;\n}\n```\n\n### Recommended\n\n```js\nfunction foo() {\n    var bar = 1;\n    let baz = 2;\n    const qux = 3;\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Local variable name shadows variable in outer scope",
                "tags": [],
                "shortcode": "JS-0123",
                "shortDescription": "Two variables can have the same name if they're declared in different scopes. In the example below, the parameter `x` is said to \"shadow\" the variable `x` declared above it. The outer `x` can no longer be accessed inside the `sum` function.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ynlndmdi",
                "description": "Two variables can have the same name if they're declared in different scopes.\nIn the example below, the parameter `x` is said to \"shadow\" the variable `x` declared above it.\nThe outer `x` can no longer be accessed inside the `sum` function.\n\n```js\nconst x = 1\nfunction add(x, y) {\n    return x + y\n}\n```\n\nWhile shadowing does not cause any problems most of the time, it does make the code harder to read and understand.\nWe highly recommend against shadowing.\nHowever, if you want to shadow some variable name and don't want DeepSource to flag it, add a [skipcq comment](https://docs.deepsource.com/docs/issues-ignore-rules) alongside an explanation:\n\n```js\nconst x = 1\nfunction add(x, y) { // skipcq: JS-0123 - `x` can be safely shadowed\n    return x + y\n}\n```\n\nIf you want to disable this issue project-wide, you can add it to the list of disabled issues in the project dashboard.\n\n### Bad Practice\n\n```js\nconst file = \"data.txt\"\n\nfunction readFile(file) {\n    // The parameter `file` shadows the toplevel variable `file`.\n    if (fs.existsSync(file)) {\n        return fs.readFileSync(file)\n    }\n    return null\n}\n```\n\n### Recommended\n\n```js\n// Prefer variable names that are distinct and convey as much\n// meaning as possible.\nconst dataFile = \"data.txt\"\n\nfunction readFile(filePath) {\n    if (fs.existsSync(filePath)) {\n        return fs.readFileSync(filePath)\n    }\n    return null\n}\n```\n\nAlternatively:\n\n```js\nconst file = \"data.txt\"\n\nfunction readFile(file) { // skipcq: JS-0123 - Shadowing is safe here\n    // ...\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found the usage of undeclared variables",
                "tags": [],
                "shortcode": "JS-0125",
                "shortDescription": "Variables that aren't defined, but accessed may throw reference errors at runtime.\n\n> **NOTE**: In browser applications, DeepSource recommends the use of ESModules over regular `text/javascript` scripts.\n> Using variables that are injected by scripts included in an HTML file is currently not supported.",
                "severity": "CRITICAL",
                "isRecommended": true,
                "id": "SXNzdWU6YnhyZ3Fi",
                "description": "Variables that aren't defined, but accessed may throw reference errors at runtime.\n\n> **NOTE**: In browser applications, DeepSource recommends the use of ESModules over regular `text/javascript` scripts.\n> Using variables that are injected by scripts included in an HTML file is currently not supported.\n\n<!--more-->\n\nPotential `ReferenceError`s may result from misspellings of variable and parameter names, or accidental implicit globals (for example, forgetting the `var` keyword in a `for` loop initializer).\nAny reference to an undeclared variable causes a warning, unless the variable is explicitly mentioned in a `/*global ...*/` comment, or specified in the globals key in the configuration file.\nA common use case for these is if you intentionally use globals that are defined elsewhere (e.g. in a script sourced from HTML).\n\n### Bad Practice\n\n```js\nconst foo = someFunction(); // `someFunction` is not defined\nconst bar = baz + 1; // 'baz' is undeclared\n```\n\n### Recommended\n\n```js\nimport { someFunction } from 'some-file';\n\nconst baz = Math.random();\nconst foo = someFunction();\nconst bar = baz + 1;\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Should not have unused variables",
                "tags": [
                  "javascript"
                ],
                "shortcode": "JS-0128",
                "shortDescription": "Found variables that are declared but not used anywhere.\n\n> **NOTE**: In browser applications, DeepSource recommends the use of ESModules over regular `text/javascript` scripts.\n> Currently, we don't support variables that are not explicitly exported,\n> and are injected into other scripts by being included in an HTML file",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6Ym5ncXJ6",
                "description": "Found variables that are declared but not used anywhere.\n\n> **NOTE**: In browser applications, DeepSource recommends the use of ESModules over regular `text/javascript` scripts.\n> Currently, we don't support variables that are not explicitly exported,\n> and are injected into other scripts by being included in an HTML file\n\n<!--more-->\n\nUnused variables are most often the result of incomplete refactoring.\nThey can lead to confusing code and minor performance hitches.\n\n**NOTE:** If you have intentionally left a variable unused, we suggest you to prefix the variable name with a `_` to prevent them from being flagged by DeepSource.\n\n### Bad Practice\n\n```js\n// Write-only variables are not considered as used.\nlet y = 10;\ny = 5;\n\n// A variable that modifies only itself isn't considered used.\nlet z = 0;\nz = z + 1;\n\n// Unused argument\n(function(x) {\n    return 5;\n})();\n\n// Unused recursive functions also raise this issue.\nfunction fact(n) {\n    if (n < 2) return 1;\n    return n * fact(n - 1);\n}\n\n// When a function definition destructures an array,\n// unused entries from the array also cause warnings.\nfunction getY([x, y]) {\n    return y;\n}\n```\n\n### Recommended\n\n```js\nlet x = 10;\nalert(x);\n\n((arg1) => {\n    return arg1;\n})();\n\nlet myFunc;\nmyFunc = (n) => {\n    // this is legal\n    if (n < 0) myFunc();\n};\n\n// this is also considered legal\nconsole.log(declaredLater);\nvar declaredLater;\n\n// Only the second argument from the descructured array is used.\nfunction getY([, y]) {\n    return y;\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Variable used before definition",
                "tags": [],
                "shortcode": "JS-0129",
                "shortDescription": "It is recommended to use a variable only after it is defined as it might produce errors at runtime.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6em1uZG9i",
                "description": "It is recommended to use a variable only after it is defined as it might produce errors at runtime.\n\n<!--more-->\n\nIn JavaScript, prior to ES6, variable and function declarations are hoisted to the top of a scope, so it's possible to use identifiers before their formal declarations in code. This can be confusing and some believe it is best to always declare variables and functions before using them.\n\nIn ES6, block-level bindings (`let` and `const`) introduce a \"temporal dead zone\" where a `ReferenceError` will be thrown with any attempt to access the variable before its declaration.\n\n### Bad Practice\n\n```js\nalert(a);\nvar a = 10;\n\nf();\nfunction f() {}\n\nfunction g() {\n    return b;\n}\nvar b = 1;\n\n{\n    alert(c);\n    let c = 1;\n}\n```\n\n### Recommended\n\n```js\nvar a;\na = 10;\nalert(a);\n\nfunction f() {}\nf(1);\n\nvar b = 1;\nfunction g() {\n    return b;\n}\n\n{\n    let c;\n    c++;\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Consider using `let` or `const` instead of `var`",
                "tags": [],
                "shortcode": "JS-0239",
                "shortDescription": "It is recommended to use `let` or `const` over `var`.\nThis will help prevent re-declaration of variables that are in the global scope when using `var`.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6emtka2pi",
                "description": "It is recommended to use `let` or `const` over `var`.\nThis will help prevent re-declaration of variables that are in the global scope when using `var`.\n\n<!--more-->\n\nES6 allows programmers to create variables with block scope instead of function scope using the `let` and `const` keywords.\nBlock scope is common in many other programming languages and helps programmers avoid mistakes such as this one:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\nBlock scoped variables shadow outer declarations instead of writing to them.\n\n**NOTE:**\nThere are certain edge cases where users might want to consider var.\nConsider this example:\n\n```js\nvar lib = lib || { run: () => {} }\n```\n\nHere, `lib` might be a library that is exposed to an HTML file using a `<script>` tag.\nThe `var` keyword helps avoid re-writing `lib` if it has already been declared via an injected script that was executed before this one.\nIdeally, you should let bundlers worry about cases like this.\nBut if you want to use `var` anyway, consider using a [skipcq comment](https://docs.deepsource.com/docs/issues-ignore-rules), or [disabling the issue](https://docs.deepsource.com/docs/repository-view-issues#ignoring-issues) altogether.\n\n### Bad Practice\n\n```js\nvar x = \"y\";\nvar CONFIG = {};\n```\n\n### Recommended\n```js\nlet x = \"y\";\nconst CONFIG = {};\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Use shorthand property syntax for object literals",
                "tags": [],
                "shortcode": "JS-0240",
                "shortDescription": "ECMAScript 6 provides a concise form for defining object literal methods and properties. This syntax can make defining complex object literals much cleaner.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6enJueGR6",
                "description": "ECMAScript 6 provides a concise form for defining object literal methods and properties.\nThis syntax can make defining complex object literals much cleaner.\n\nHere are a few common examples using the ES5 syntax:\n```\nconst x = 1, y = 2, z = 3;\n// properties\nconst foo = {\n    x: x,\n    y: y,\n    z: z,\n};\n\n// methods\nconst foo = {\n    a: function() {},\n    b: function() {}\n};\n```\n\nThe ES6 equivalent syntax is::\n```\n// properties\nconst foo = {x, y, z};\n\n// methods\nconst bar = {\n    a() { return 1 },\n    b() { return 2 }\n};\n```\n\n**NOTE:** The shorthand properties are equivalent to function expressions.\nMeaning that they do not bind their own `this` inside their bodies.\nIt is still possible to access properties from the object inside a shorthand member function:\n\n```js\nconst object = {\n    x: 1,\n    getX() {\n        return this.x // valid\n    }\n}\n```\n\n### Bad Practice\n\n```js\nconst foo = {\n    bar: function () { return 1 }\n};\n```\n\n### Recommended\n\n```js\nconst foo = {\n    bar() { return 1 }\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Consider using arrow functions for callbacks",
                "tags": [],
                "shortcode": "JS-0241",
                "shortDescription": "It is recommended to use arrow functions as callbacks.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6emFucHJi",
                "description": "It is recommended to use arrow functions as callbacks.\n\n<!--more-->\n\nArrow functions can be an attractive alternative to function expressions for callbacks or function arguments.\n\nFor example, arrow functions are automatically bound to their surrounding scope/context. This provides an alternative to the pre-ES6 standard of explicitly binding function expressions to achieve similar behavior.\n\nAdditionally, arrow functions are:\n\n* less verbose, and easier to reason about.\n\n* bound lexically regardless of where or when they are invoked.\n\n### Bad Practice\n\n```js\nfunc(function(a) { return a; }); // ERROR\n// prefer: func(a => a)\n\nfunc(function() { return this.a; }.bind(this)); // ERROR\n// prefer: func(() => this.a)\n```\n\n### Recommended\n\n```js\n// arrow function callback\nfunc(a => a); // OK\n\n// generator as callback\nfunc(function*() { yield; }); // OK\n\n// function expression not used as callback or function argument\nvar funcVar = function func(a) { return a; }; // OK\n\n// unbound function expression callback\nfunc(function() { return this.a; }); // OK\n\n// recursive named function callback\nfunc(function recursiveFunc(n) { return n && n + recursiveFunc(n - 1); }); // OK\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found control characters in regular expressions",
                "tags": [],
                "shortcode": "JS-0004",
                "shortDescription": "Control characters are special, invisible characters in the ASCII range 0-31.\nThese characters are rarely used in JavaScript strings, so a regular expression containing these characters is most likely a mistake.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enJua3F6",
                "description": "Control characters are special, invisible characters in the ASCII range 0-31.\nThese characters are rarely used in JavaScript strings, so a regular expression containing these characters is most likely a mistake.\n\n<!--more-->\n\n### Bad Practice\n\n```js\nconst pattern1 = /\\x1f/;\nconst pattern2 = new RegExp(\"\\x1f\");\n```\n\n### Recommended\n\n```js\nconst pattern1 = /\\x20/;\nconst pattern2 = new RegExp(\"\\x20\");\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Require spread operators instead of .apply()",
                "tags": [],
                "shortcode": "JS-0245",
                "shortDescription": "Before ES2015, one must use `Function.prototype.apply()` to call variadic functions.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YmxtZXF6",
                "description": "Before ES2015, one must use `Function.prototype.apply()` to call variadic functions.\n```\nvar args = [1, 2, 3, 4];\nMath.max.apply(Math, args);\n```\nIn ES2015, one can use spread syntax to call variadic functions.\n```\nvar args = [1, 2, 3, 4];\nMath.max(...args);\n```\n\n### Bad Practice\n\n```js\nfoo.apply(undefined, args);\nfoo.apply(null, args);\nobj.foo.apply(obj, args);\n```\n\n### Recommended\n\n```js\n// Using spread syntax\nfoo(...args);\nobj.foo(...args);\n\n// The `this` binding is different.\nfoo.apply(obj, args);\nobj.foo.apply(null, args);\nobj.foo.apply(otherObj, args);\n\n// The argument list is not variadic.\n// Those are warned by the `no-useless-call` rule.\nfoo.apply(undefined, [1, 2, 3]);\nfoo.apply(null, [1, 2, 3]);\nobj.foo.apply(obj, [1, 2, 3]);\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Require template literals instead of string concatenation",
                "tags": [],
                "shortcode": "JS-0246",
                "shortDescription": "In ES2015 (ES6), we can use template literals instead of string concatenation.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YmtkdmR6",
                "description": "In ES2015 (ES6), we can use template literals instead of string concatenation.\n```\nvar str = `Hello, ${name}!`;\n```\n\n### Bad Practice\n\n```js\nvar str = \"Hello, \" + name + \"!\";\nvar str = \"Time: \" + (12 * 60 * 60 * 1000);\n```\n\n### Recommended\n\n```js\nvar str = \"Hello World!\";\nvar str = `Hello, ${name}!`;\nvar str = `Time: ${12 * 60 * 60 * 1000}`;\n\nvar str = \"Hello, \" + \"World!\";\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Require symbol description",
                "tags": [],
                "shortcode": "JS-0250",
                "shortDescription": "The `Symbol` function may have an optional description:",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnFubHF6",
                "description": "The `Symbol` function may have an optional description:\n```\nvar foo = Symbol(\"some description\");\n\nvar someString = \"some description\";\nvar bar = Symbol(someString);\n```\nUsing `description` promotes easier debugging: when a symbol is logged the description is used:\n```\nvar foo = Symbol(\"some description\");\n\n> console.log(foo);\n// Symbol(some description)\n```\nIt may facilitate identifying symbols when one is observed during debugging.\n\n### Bad Practice\n\n```js\nvar foo = Symbol();\n\n```\n\n### Recommended\n\n```js\nvar foo = Symbol(\"some description\");\n\nvar someString = \"some description\";\nvar bar = Symbol(someString);\n```",
                "category": "PERFORMANCE",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Require error handling in callbacks",
                "tags": [],
                "shortcode": "JS-0254",
                "shortDescription": "In Node.js, a common pattern for dealing with asynchronous behavior is called the callback pattern. This pattern expects an Error object or null as the first argument of the callback. Forgetting to handle these errors can lead to some really strange behavior in your application.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnZucXZi",
                "description": "In Node.js, a common pattern for dealing with asynchronous behavior is called the callback pattern. This pattern expects an Error object or null as the first argument of the callback. Forgetting to handle these errors can lead to some really strange behavior in your application.\n```\nfunction loadData (err, data) {\n    doSomething(); // forgot to handle error\n}\n```\n### Bad Practice\n\n```js\nfunction loadData (err, data) {\n    doSomething();\n}\n```\n\n\n### Recommended\n\n```js\nfunction loadData (err, data) {\n    if (err) {\n        console.log(err.stack);\n    }\n    doSomething();\n}\n\nfunction generateError (err) {\n    if (err) {}\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Ensure Node.js-style error-first callback pattern is followed",
                "tags": [],
                "shortcode": "JS-0255",
                "shortDescription": "When invoking a callback function which uses the Node.js error-first callback pattern, all of your errors should either use the Error class or a subclass of it. It is also acceptable to use undefined or null if there is no error.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ynhydm1i",
                "description": "When invoking a callback function which uses the Node.js error-first callback pattern, all of your errors should either use the Error class or a subclass of it. It is also acceptable to use undefined or null if there is no error.\n\n### Bad Practice\n\n```js\ncb('this is an error string');\ncb({ a: 1 });\ncallback(0);\n```\n\n\n### Recommended\n\n```js\ncb(undefined);\ncb(null, 5);\ncallback(new Error('some error'));\ncallback(someVariable);\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Detected string concatenation with __dirname and __filename",
                "tags": [],
                "shortcode": "JS-0262",
                "shortDescription": "In Node.js, the __dirname and __filename global variables contain the directory path and the file path of the currently executing script file, respectively. Sometimes, developers try to use these variables to create paths to other files, such as:",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnlncG9i",
                "description": "In Node.js, the __dirname and __filename global variables contain the directory path and the file path of the currently executing script file, respectively. Sometimes, developers try to use these variables to create paths to other files, such as:\n```\nvar fullPath = __dirname + \"/foo.js\";\n```\nHowever, there are a few problems with this. First, you can't be sure what type of system the script is running on. Node.js can be run on any computer, including Windows, which uses a different path separator. It's very easy, therefore, to create an invalid path using string concatenation and assuming Unix-style separators. There's also the possibility of having double separators, or otherwise ending up with an invalid path.\n\nIn order to avoid any confusion as to how to create the correct path, Node.js provides the path module. This module uses system-specific information to always return the correct value. So you can rewrite the previous example as:\n```\nvar fullPath = path.join(__dirname, \"foo.js\");\n```\nThis example doesn't need to include separators as path.join() will do it in the most appropriate manner. Alternately, you can use path.resolve() to retrieve the fully-qualified path:\n```\nvar fullPath = path.resolve(__dirname, \"foo.js\");\n```\nBoth path.join() and path.resolve() are suitable replacements for string concatenation wherever file or directory paths are being created.\n\n### Bad Practice\n\n```js\nconst fullPath1 = __dirname + \"/foo.js\";\nconst fullPath2 = __filename + \"/foo.js\";\nconst fullPath3 = `${__dirname}/foo.js`;\nconst fullPath4 = `${__filename}/foo.js`;\n```\n\n\n### Recommended\n\n```js\nconst fullPath1 = path.join(__dirname, \"foo.js\");\nconst fullPath2 = path.join(__filename, \"foo.js\");\nconst fullPath3 = __dirname + \".js\";\nconst fullPath4 = __filename + \".map\";\nconst fullPath5 = `${__dirname}_foo.js`;\nconst fullPath6 = `${__filename}.test.js`;\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Detected the use of process.exit()",
                "tags": [],
                "shortcode": "JS-0263",
                "shortDescription": "The process.exit() method in Node.js is used to immediately stop the Node.js process and exit. This is a dangerous operation because it can occur in any method at any point in time, potentially stopping a Node.js application completely when an error occurs. For example:",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6em1ycHli",
                "description": "The process.exit() method in Node.js is used to immediately stop the Node.js process and exit. This is a dangerous operation because it can occur in any method at any point in time, potentially stopping a Node.js application completely when an error occurs. For example:\n```\nif (somethingBadHappened) {\n    console.error(\"Something bad happened!\");\n    process.exit(1);\n}\n```\nThis code could appear in any module and will stop the entire application when somethingBadHappened is truthy. This doesn't give the application any chance to respond to the error. It's usually better to throw an error and allow the application to handle it appropriately:\n```\nif (somethingBadHappened) {\n    throw new Error(\"Something bad happened!\");\n}\n```\nBy throwing an error in this way, other parts of the application have an opportunity to handle the error rather than stopping the application altogether. If the error bubbles all the way up to the process without being handled, then the process will exit and a non-zero exit code will returned, so the end result is the same.\n\nIf you are using process.exit() only for specifying the exit code, you can set process.exitCode (introduced in Node.js 0.11.8) instead.\n\n### Bad Practice\n\n```js\nprocess.exit(1);\nprocess.exit(0);\n```\n\n\n### Recommended\n\n```js\nProcess.exit();\nvar exit = process.exit;\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Detected deprecated APIs",
                "tags": [],
                "shortcode": "JS-0272",
                "shortDescription": "Since its inception, NodeJS has deprecated many APIs for one of the following reasons: - Use of the API is unsafe. - An improved version of the API was introduced later.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6emxkYWt6",
                "description": "Since its inception, NodeJS has deprecated many APIs for one of the following reasons:\n  - Use of the API is unsafe.\n  - An improved version of the API was introduced later.\n  - The API may have breaking changes in a future version of Node.\n\nThis issue prevents the use of deprecated Node APIs in favor of modern ones.\n\n### Bad Practice\n\n```js\nconst fs = require(\"fs\");\nfunction fetchData(fileName) {\n  // 'fs.exists' was deprecated since v4.\n  // Use 'fs.stat()' or 'fs.access()' instead.\n  if (fs.exists(fileName)) {\n    // ... \n  }\n}\n```\n\n### Recommended\n\n```js\nasync function fetchData(fileName) {\n  fs.access(fileName, (error) => {\n    if (error) {\n      // Handle the error\n    } else {\n      // ...\n    }\n  })\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found single char variable name",
                "tags": [],
                "shortcode": "JS-C1002",
                "shortDescription": "Single character variable names affect code readability and complicate code refactoring, because of the difficulty in searching and replacing single characters.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YmRsbWx3",
                "description": "Single character variable names affect code readability and complicate code refactoring, because of the difficulty in searching and replacing single characters.\n<!--more-->\n\nThis issue will not be raised for certain special identifiers, such as `i`, `j` or `n`. It will also not be reported for the parameters used in `for` and `while` loops.\n\n### Bad Practice\n\n```js\nvar a;\nconst l = 90\n```\n\n### Recommended\n\n```js\nvar age;\nconst limit = 90;\n\n\nfor(let o = 2; o < 10; o++){\n    sum += o\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found bad matching pattern",
                "tags": [],
                "shortcode": "JS-D006",
                "shortDescription": "Prior to the addition of `matchAll` to JavaScript, it was possible to use calls to `regexp.exec` (and regexes with the `/g` flag) in a loop to obtain all the matches.  With `matchAll` available, you can avoid the `while` loop and `exec` with `g`.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6emduanZi",
                "description": "Prior to the addition of `matchAll` to JavaScript, it was possible to use calls to `regexp.exec` (and regexes with the `/g` flag) in a loop to obtain all the matches.\n\nWith `matchAll` available, you can avoid the `while` loop and `exec` with `g`.\nInstead, by using `matchAll`, you get an iterator to use with the more convenient `for...of`, array spread, or `Array.from()` constructs.\n\nAnother compelling reason for matchAll is the improved access to capture groups.\n\nCapture groups are ignored when using `match()` with the global `/g` flag.\n\n### Bad Practice\n\n```js\nlet match;\nconst regexp = RegExp(/[a-zA-Z0-9]/)\nwhile ((match = regexp.exec(str)) !== null) {\n  // code\n}\n```\n\n### Recommended\n\n```js\nfor (const match of str.matchAll(regexp)) {\n  // code\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Unused return value from `Array`/`Object` prototype method",
                "tags": [],
                "shortcode": "JS-D008",
                "shortDescription": "Many built-in functions defined on prototypes for `Object` and `Array` are pure, and return modified versions of their inputs. If the return values from these functions aren't used, the function call is essentially a no-op and might as well be removed.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enFrZ2t6",
                "description": "Many built-in functions defined on prototypes for `Object` and `Array` are pure, and return modified versions of their inputs.\nIf the return values from these functions aren't used, the function call is essentially a no-op and might as well be removed.\n\n```js\n// These calls do not modify the array, instead they\n// return new arrays with the desired properties.\nxs.map(x => x.prop)\nxs.filter(x => x.prop === 'value')\nxs.concat(ys)\nxs.reduce((x, y) => (x.value + y.value))\n```\n<!-- more -->\n\nPerhaps, you're using `map` to iterate over an array and induce some side-effect, like logging to the console as shown here:\n\n```js\nxs.map((x, i) => console.log(`element #${i}:`, x))\n```\nThis use of `map` is however misleading.\nThe `map`/`filter`/`concat` methods should only ever be used to produce new arrays that are used elsewhere.\nInstead, you should use the `forEach` method:\n\n```js\nxs.forEach((x, i) => console.log(`element #${i}:`, x))\n```\n\n### Bad Practice\n\n```js\nconst characters = [\n  { name: 'Paul Atreides', age: 15 },\n  { name: 'Kaladin Stormblessed', age: 19 },\n  { name: 'Miss Kobayashi', age: 25 },\n  { name: 'Eren Yeager', age: 14 },\n  { name: 'Illidan Stormrage', age: 3000 }\n]\n\ncharacters.map(character => character.name);\n\n// characters array is not modified by the call to `map`.\nconsole.log(characters) \n```\n\n### Recommended\n```js\nconst characters = [\n  { name: 'Paul Atreides', age: 15 },\n  { name: 'Kaladin Stormblessed', age: 19 },\n  { name: 'Miss Kobayashi', age: 25 },\n  { name: 'Eren Yeager', age: 14 },\n  { name: 'Illidan Stormrage', age: 3000 }\n]\n\n// array returned by call to `map` is now stored.\nconst characterNames = characters.map(character=> character.name);\nconsole.log(characterNames)\n//  [ 'Paul Atreides', 'Kaladin Stormblessed', 'Miss Kobayashi', 'Eren Yeager', 'Illidan Stormrage' ]\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Avoid the use of `Buffer()` and `Buffer#allocUnsafe()`",
                "tags": [],
                "shortcode": "JS-D025",
                "shortDescription": "NodeJS has deprecated the `Buffer` constructor due to the multitude of security vulnerabilities it is affected by, such as **Remote Memory Disclosure** and **Denial Of Service**.\n\nWe recommend using `Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()` as alternatives, keeping the following points in mind:\n\n- `Buffer.alloc(size[, fill[, encoding]])` returns a new initialized Buffer of the specified size. This method is slower than `Buffer.allocUnsafe(size)` but guarantees that newly created Buffer instances never contain potentially sensitive data. If the size is not a number, then it will throw a `TypeError`.\n- `Buffer.allocUnsafe(size)` and `Buffer.allocUnsafeSlow(size)` each return a new uninitialized Buffer of the specified size. Because the Buffer is uninitialized, the allocated segment of memory might contain potentially sensitive data.",
                "severity": "CRITICAL",
                "isRecommended": false,
                "id": "SXNzdWU6YnZkd3h5",
                "description": "NodeJS has deprecated the `Buffer` constructor due to the multitude of security vulnerabilities it is affected by, such as **Remote Memory Disclosure** and **Denial Of Service**.\n\nWe recommend using `Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()` as alternatives, keeping the following points in mind:\n\n- `Buffer.alloc(size[, fill[, encoding]])` returns a new initialized Buffer of the specified size. This method is slower than `Buffer.allocUnsafe(size)` but guarantees that newly created Buffer instances never contain potentially sensitive data. If the size is not a number, then it will throw a `TypeError`.\n- `Buffer.allocUnsafe(size)` and `Buffer.allocUnsafeSlow(size)` each return a new uninitialized Buffer of the specified size. Because the Buffer is uninitialized, the allocated segment of memory might contain potentially sensitive data.\n\n<!--more-->\n\nIn Node.js, the behavior of the `Buffer` constructor is different depending on the type of its argument.\n\nPassing an argument from user input to `Buffer()` without validating its type can lead to security vulnerabilities such as **Remote Memory Disclosure** and **Denial of Service**.\n\nErrors in handling buffers allocated with `Buffer.allocUnsafe()` could result in various issues, ranging from undefined behavior of your code to sensitive data (user input, passwords, certs) leaking to the remote attacker.\n\nWhen calling `Buffer.allocUnsafe()`, the segment of allocated memory is uninitialized (it is not zeroed-out). While this design allocates memory quite fast, the allocated memory segment might contain old and potentially sensitive data. Using a Buffer created by `Buffer.allocUnsafe()` without completely overwriting the memory can allow this old data to leak.\n\n### Bad Practice\n\n```js\nBuffer([1, 2, 3])\nnew Buffer([1, 2, 3])\nBuffer.allocUnsafe(5)\n```\n\n### Recommended\n\n```js\nBuffer.alloc(5)\nnew Buffer.Foo()\nBuffer.from([1, 2, 3])\nfoo(Buffer)\nBuffer.alloc(res.body.amount)\nBuffer.from(res.body.values)\n```\n\n## References\n\n- [NodeJS Buffer Deprecated](https://nodejs.org/en/docs/guides/buffer-constructor-deprecation/)\n- [Exploiting Buffer](https://snyk.io/blog/exploiting-buffer/)\n- [Remote Memory Exposure](https://snyk.io/vuln/npm:ws:20160104)",
                "category": "SECURITY",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found unused objects",
                "tags": [],
                "shortcode": "JS-R1002",
                "shortDescription": "Class constructors being invoked and then dropped immediately is an anti-pattern and should be avoided.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6YmpteHZx",
                "description": "Class constructors being invoked and then dropped immediately is an anti-pattern and should be avoided.\n<!--more-->\nObjects instantiated with `new` should always be useful in some way (passed as a function argument, stored in a variable for later use, etc).\nIf the object is instantiated only to invoke some side effect in the constructor, then the side effect should be refactored out into it's own function.\n\n### Bad Practice\n\n```js\nnew Foo()\n```\n\n### Recommended\n\n```js\nconst myFoo = new Foo()\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Function with cyclomatic complexity higher than threshold",
                "tags": [],
                "shortcode": "JS-R1005",
                "shortDescription": "A function with high cyclomatic complexity can be hard to understand and\nmaintain. Cyclomatic complexity is a software metric that measures the number of\nindependent paths through a function. A higher cyclomatic complexity indicates\nthat the function has more decision points and is more complex.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6enhqdmd2",
                "description": "A function with high cyclomatic complexity can be hard to understand and\nmaintain. Cyclomatic complexity is a software metric that measures the number of\nindependent paths through a function. A higher cyclomatic complexity indicates\nthat the function has more decision points and is more complex.\n\n<!--more-->\n\nFunctions with high cyclomatic complexity are more likely to have bugs and be\nharder to test. They may lead to reduced code maintainability and increased\ndevelopment time.\n\nTo reduce the cyclomatic complexity of a function, you can:\n\n- Break the function into smaller, more manageable functions.\n- Refactor complex logic into separate functions or classes.\n- Avoid multiple return paths and deeply nested control expressions.\n\n### Bad Practice\n\n```js\n// When `cyclomatic_complexity_threshold` is set to `low`, by default it is `high`\nfunction getCapitalCity(countryName) {\n  if (countryName === 'India') {\n    return 'New Delhi'\n  } else if (countryName === 'China') {\n    return 'Beijing'\n  } else if (countryName === 'France') {\n    return 'Paris'\n  } else if (countryName === 'Germany') {\n    return 'Berlin'\n  } else if (countryName === 'Italy') {\n    return 'Rome'\n  }\n}\n```\n\n### Recommended\n\n```js\nfunction getCapitalCity(countryName) {\n  const capitalCities = {\n    India: 'New Delhi',\n    China: 'Beijing',\n    France: 'Paris',\n    Germany: 'Berlin',\n    Italy: 'Rome'\n  }\n\n  return capitalCities[countryName]\n}\n```\n\n### Issue configuration\n\nCyclomatic complexity threshold can be configured using the\n`cyclomatic_complexity_threshold` [meta field](https://docs.deepsource.com/docs/analyzers-javascript#cyclomatic_complexity_threshold) in the\n`.deepsource.toml` config file.\n\nConfiguring this is optional. If you don't provide a value, the Analyzer will\nraise issues for functions with complexity higher than the default threshold,\nwhich is `high`(only raises for issues >25) for the JavaScript Analyzer.\n\nHere's the mapping of the risk category to the cyclomatic complexity score to\nhelp you configure this better:\n\n| Risk category | Cyclomatic complexity range |                                             Recommended action                                             |\n| :-----------: | :-------------------------: | :--------------------------------------------------------------------------------------------------------: |\n|      low      |             1-5             |                                             No action needed.                                              |\n|    medium     |            6-15             |                                            Review and monitor.                                             |\n|     high      |            16-25            | Review and refactor. Recommended to add comments if the function is absolutely needed to be kept as it is. |\n|   very-high   |            26-50            |                                     Refactor to reduce the complexity.                                     |\n|   critical    |             >50             |          Must refactor this. This can make the code untestable and very difficult to understand.           |",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Avoid using deprecated or outdated libraries",
                "tags": [],
                "shortcode": "JS-S1005",
                "shortDescription": "It is not recommended to use third-party libraries that are deprecated or have not been actively maintained for a long time because these deprecated or non maintained libraries are not up to date with their dependencies (these dependencies are indirect dependencies to your project) which results in application exposed to the known security vulnerabilities. Along with this, these libraries often contain outdated or old language features or framework features that might not be compatible with your language or framework versions.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnBqamVn",
                "description": "It is not recommended to use third-party libraries that are deprecated or have not been actively maintained for a long time because these deprecated or non maintained libraries are not up to date with their dependencies (these dependencies are indirect dependencies to your project) which results in application exposed to the known security vulnerabilities. Along with this, these libraries often contain outdated or old language features or framework features that might not be compatible with your language or framework versions.\n\n<!--more-->\n\nThis issue does support recommending a better alternative for the reported library. Currently, this issue reports for the following commonly used libraries that developers often miss\n\n- request\n- cross-env\n- tslint\n- jscs\n- babel-eslint\n- babylon\n- memory-fs\n- node-libs-browser\n- owl.carousel\n- glamorous\n- angular-ui-utils\n- uglifyjs-webpack-plugin\n- bootstrap-timepicker\n- cropper\n- react-hot-loader\n- scribe\n- node-serialize\n- cli\n- cst\n- esmangle\n\n### Bad Practice\n\n```js\nconst fetchUtil = require('request')\nconst env = require('cross-env')\n```\n\n### Recommended\n\n```js\nconst fetchUtil = require('axios')\nconst env = require('env-cmd')\n```",
                "category": "SECURITY",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Missing target origin in cross-origin communication",
                "tags": [
                  "a07",
                  "cwe-223",
                  "2021",
                  "sans-top-25",
                  "owasp-top-10"
                ],
                "shortcode": "JS-S1014",
                "shortDescription": "The [window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) function is used for cross-origin communication between two entities. An \"entity\" here can be a page, an iframe, or a pop-up spawned by a page. It is recommended to always have an explicit [targetOrigin parameter](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#parameters) when using `window.postMessage`.",
                "severity": "CRITICAL",
                "isRecommended": true,
                "id": "SXNzdWU6enJneG9l",
                "description": "The [window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) function is used for cross-origin communication between two entities.\nAn \"entity\" here can be a page, an iframe, or a pop-up spawned by a page.\nIt is recommended to always have an explicit [targetOrigin parameter](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#parameters) when using `window.postMessage`.\nThis allows the message to be sent only to trusted receivers - those that have the required URI.\n\nWhen sharing a password for example, it is critical that the password only be sent to the intended receiver, and not some malicious third party.\n\n```js\nconst password = getPassword()\nwindow.postMessage(password, \"https://safe.site.com\")\n```\n\nIf you have no preference for the origin of a window for a message to be dispatched, you can use `*`:\n\n```js\nwindow.postMessage(data, \"*\")\n```\n\n### Bad Practice\n\n```js\n// send a message from a pop-up:\nconst popup = window.open(/* popup data */)\n\n// INSECURE: The message can be received by any window that is currently active\n// below the pop-up.\npopup.postMessage(\"secret message for the parent\")\n```\n\n### Recommended\n\n```js\n// send a message from a pop-up:\nconst popup = window.open(/* popup data */)\n\n// SAFE: The message can only be received by example.com \npopup.postMessage(\"secret message for the parent\", \"https://www.example.com\")\n```\n\n## References\n- [OWASP A07:2021 - Identification and Authentication Failures](https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/)\n- [CWE 20](https://cwe.mitre.org/data/definitions/20.html)\n- [MDN - Security concerns with window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#security_concerns)",
                "category": "SECURITY",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found control characters in regular expression",
                "tags": [],
                "shortcode": "JS-W1035",
                "shortDescription": "ASCII character codes between 0 and 32 are reserved for [non-printing characters](https://en.wikipedia.org/wiki/Non-printing_character_in_word_processors). Such characters are unlikely to be present in JavaScript strings, and matching them with a Regular expression is most likely a mistake. Even when you do want to match them, it is recommended to use the character literals for better clarity:",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6enhqZHhx",
                "description": "ASCII character codes between 0 and 32 are reserved for [non-printing characters](https://en.wikipedia.org/wiki/Non-printing_character_in_word_processors).\nSuch characters are unlikely to be present in JavaScript strings, and matching them with a Regular expression is most likely a mistake.\nEven when you do want to match them, it is recommended to use the character literals for better clarity:\n\n```js\nconst tabsAndSpaces = / \\t/\nconst tabsSpacesAndNewLines = /\\s/\n```\n\n<!-- more -->\n\nIf you find yourself needing to match the hex values for some reason,\nconsider adding a [skipcq comment](https://docs.deepsource.com/docs/issues-ignore-rules) to inform readers about the use-case.\nThis will also prevent DeepSource from raising the issue.\n\n### Bad Practice\n\n```js\nconst rSpaces = /\\x1a/;\n// A regex like this one is rarely useful:\nconst regExp  = new RegExp(\"\\x12\");\n```\n\n### Recommended\n\n```js\nconst rSpaces = / /;\nconst regExp  = new RegExp(\"[\\sa-z]+no-control-chars-here\");\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Too many arguments passed to function call",
                "tags": [],
                "shortcode": "JS-W1038",
                "shortDescription": "JavaScript allows passing more arguments to a function than needed. However, doing so makes your code less readable, and may not produce the result you would expect from the function call.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6em1sYXZh",
                "description": "JavaScript allows passing more arguments to a function than needed.\nHowever, doing so makes your code less readable, and may not produce the result you would expect from the function call.\n\n### Bad Practice\n\n```js\nfunction mult(a, b, c) {\n  return a * b * c;\n}\n\nmult(1, 2, 3, 4); // '4' will be ignored, and the result will be '6'.\nmult(...nums); // this is OK.\n```\n\n### Recommended\n\n```js\nfunction mult(a, b, c) {\n  return a * b * c;\n}\n\nmult(1, 2, 3);\nmult(...nums); // this is OK.\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found redundant literal in a logical expression",
                "tags": [],
                "shortcode": "JS-W1043",
                "shortDescription": "Expressions that consistently result in either true or false when comparing values, and logical operations like ||, &&, and ?? that consistently either skip or fully evaluate their operands, often indicate mistakes. Logical operations that always yield the same result could lead to unexpected behavior or bugs in the program.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6enBqeWp2",
                "description": "Expressions that consistently result in either true or false when comparing values,\nand logical operations like ||, &&, and ?? that consistently either skip or fully evaluate their operands, often indicate mistakes.\nLogical operations that always yield the same result could lead to unexpected behavior or bugs in the program.\n\n### Bad Practice\n\n```typescript\nconst arrIsEmpty = someArr === [] // Will always evaluate to false\n```\n\n### Recommended\n\n```typescript\nconst arrIsEmpty = someArr.length === 0\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Require rest parameters instead of arguments",
                "tags": [],
                "shortcode": "JS-0244",
                "shortDescription": "There are rest parameters in `ES2015`. We can use that feature for variadic functions instead of the `arguments` variable.  `arguments` does not have methods of `Array.prototype`, so it's a bit of an inconvenience.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ym5kb2Vi",
                "description": "There are rest parameters in `ES2015`. We can use that feature for variadic functions instead of the `arguments` variable.\n\n`arguments` does not have methods of `Array.prototype`, so it's a bit of an inconvenience.\n\n### Bad Practice\n\n```js\nfunction foo() {\n    console.log(arguments);\n}\n\nfunction foo(action) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    action.apply(null, args);\n}\n\nfunction foo(action) {\n    var args = [].slice.call(arguments, 1);\n    action.apply(null, args);\n}\n```\n\n### Recommended\n\n```js\nfunction foo(...args) {\n    console.log(args);\n}\n\nfunction foo(action, ...args) {\n    action.apply(null, args); // or `action(...args)`, related to the `prefer-spread` rule.\n}\n\n// Note: the implicit arguments can be overwritten.\nfunction foo(arguments) {\n    console.log(arguments); // This is the first argument.\n}\nfunction foo() {\n    var arguments = 0;\n    console.log(arguments); // This is a local variable.\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found empty block statements",
                "tags": [],
                "shortcode": "JS-0009",
                "shortDescription": "Empty block statements, while not technically errors, usually occur due to refactoring that wasn't completed.\nThey can mislead the reader.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6enlncm96",
                "description": "Empty block statements, while not technically errors, usually occur due to refactoring that wasn't completed.\nThey can mislead the reader.\n\n<!--more-->\n\nIf you still want to keep an empty block, add a comment saying `empty` inside the block.\n\n### Bad Practice\n\n```js\nif (someCheck) {}\n\nwhile (someCheck) {}\n\ntry {\n    doSomething();\n} catch(err) {\n} finally {\n}\n```\n\n### Recommended\n\n```js\nif (someCheck) {\n    // empty\n}\n\nwhile (someCheck) {\n    /* empty */\n}\n\ntry {\n    doSomething();\n} catch (err) {\n    // continue regardless of error\n}\n\ntry {\n    doSomething();\n} finally {\n    /* continue regardless of error */\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Avoid using sparse arrays unless necessary",
                "tags": [],
                "shortcode": "JS-0023",
                "shortDescription": "Sparse arrays can have empty elements represented by consecutive commas (`,`).\nUsing them is considered a bad practice and may confuse readers or even cause bugs.\nNote: This does not apply to a trailing comma present after the last element.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YmFubW16",
                "description": "Sparse arrays can have empty elements represented by consecutive commas (`,`).\nUsing them is considered a bad practice and may confuse readers or even cause bugs.\nNote: This does not apply to a trailing comma present after the last element.\n\n<!--more-->\n\nSparse arrays contain empty slots that are `undefined` by default, most frequently due to multiple commas being used in an array literal, for example:\n\n```js\nconst items = [,,];\n```\n\nThe length of the above array is 2 while `array[0]` and `array[1]` are set to `undefined`.\nHere is another example:\n\n```js\nconst colors = [ \"red\",, \"blue\" ];\n```\n\nIt is likely that the developer intended the array to have 2 elements here but ended up inserting an extra comma, leading it to have a size of 3, with an `undefined` in the middle.\nIt is therefore advised to not use sparse arrays.\n\n### Bad Practice\n\n```js\nconst items = [,];\nconst colors = [ \"red\",, \"blue\" ];\n```\n\n### Recommended\n\n```js\nconst items = [];\nconst colors = [ \"red\", \"blue\" ];\n\n// trailing comma (after the last element) is not a problem\nconst colors = [ \"red\", \"blue\", ];\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found confusing multiline expressions",
                "tags": [],
                "shortcode": "JS-0024",
                "shortDescription": "It is recommended to use a multiline expression with proper use of newlines; otherwise, it can cause confusion and have a different outcome than what the developer intended.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enlneG96",
                "description": "It is recommended to use a multiline expression with proper use of newlines; otherwise, it can cause confusion and have a different outcome than what the developer intended.\n\n<!--more-->\n\nConsider the following code-snippet:\n```js\nsomeFuncCall()\n[2].concat([3])\n```\nThe two lines are being interpreted as one expression i.e\n```js\nsomeFuncCall()[2].concat([3])\n```\n\nThis might even throw a runtime error if `someFuncCall()` does not return a multi-dimensional array.\n\n### Bad Practice\n\n```js\nconst upperLimit = limit\n(1 || 2).get();\n\nconst hello = 'world'\n[1, 2, 3].forEach(addNumber);\n\nconst x = function() {}\n`hello`\n\nconst y = function() {}\ny\n`hello`\n\nconst z = upperLimit\n/regex/g.test(limit)\n```\n\n### Recommended\n```js\nconst upperLimit = limit;\n(1 || 2).get();\n\n\n// Two different expression separated using semi-colon\nconst upperLimit = limit\n;(1 || 2).get()\n\nconst hello = 'world';\n[1, 2, 3].forEach(addNumber);\n\nconst x = function() {};\n`hello`\n\nconst tag = function() {}\ntag `hello`\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found characters which are made with multiple code points in character class syntax",
                "tags": [],
                "shortcode": "JS-0036",
                "shortDescription": "Unicode includes the characters which are made with multiple code points. RegExp character class syntax (`/[abc]/`) cannot handle characters which are made by multiple code points as a character; those characters will be dissolved to each code point. Probably the most important concept about Unicode in JavaScript is to treat strings as sequences of code units, as they really are. The confusion appears when the developer thinks that strings are composed of graphemes (or symbols), ignoring the code unit sequence concept.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6empkd2p6",
                "description": "Unicode includes the characters which are made with multiple code points.\nRegExp character class syntax (`/[abc]/`) cannot handle characters which are made by multiple code points as a character; those characters will be dissolved to each code point.\nProbably the most important concept about Unicode in JavaScript is to treat strings as sequences of code units, as they really are. The confusion appears when the developer thinks that strings are composed of graphemes (or symbols), ignoring the code unit sequence concept.\nIt creates misunderstanding when processing strings that contain surrogate pairs or combining character sequences:\n\n- Getting the string length\n- Character positioning\n- Regular expression matching\n\nFor example, `‚ùáÔ∏è` is made by `‚ùá` (`U+2747`) and VARIATION SELECTOR-16 (`U+FE0F`).\nIf this character is in RegExp character class, it will match to either `‚ùá` (`U+2747`) or VARIATION SELECTOR-16 (`U+FE0F`) rather than `‚ùáÔ∏è`.\n\n### Bad Practice\n```js\n/^[√Å]$/u\n/^[‚ùáÔ∏è]$/u\n/^[üë∂üèª]$/u\n/^[üáØüáµ]$/u\n/^[üë®‚Äçüë©‚Äçüë¶]$/u\n/^[üëç]$/\n```\n\n### Recommended\n\n```js\n/^[abc]$/\n/^[üëç]$/u\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Found template literal placeholder syntax in regular strings",
                "tags": [],
                "shortcode": "JS-0038",
                "shortDescription": "ECMAScript 6 allows programmers to create strings containing variable or expressions using template literals, instead of string concatenation, by writing expressions like `${variable}` between two backtick quotes (`). It is easy to use the wrong quotes when wanting to use template literals, by writing `${variable}`, and ending up with the literal value `${variable}` instead of a string containing the value of the templated expressions.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ymp3bmx6",
                "description": "ECMAScript 6 allows programmers to create strings containing variable or expressions using template literals, instead of string concatenation, by writing expressions like `${variable}` between two backtick quotes (`).\nIt is easy to use the wrong quotes when wanting to use template literals, by writing `${variable}`, and ending up with the literal value `${variable}` instead of a string containing the value of the templated expressions.\n\n### Bad Practice\n```js\n\"Hello ${name}!\";\n'Hello ${name}!';\n\"Time: ${12 * 60 * 60 * 1000}\";\n```\n\n### Recommended\n```js\n`Hello ${name}!`;\n`Time: ${12 * 60 * 60 * 1000}`;\n\ntemplateFunction`Hello ${name}`;\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Invalid variable usage",
                "tags": [],
                "shortcode": "JS-0043",
                "shortDescription": "Variables should be used inside of their binding context. This helps avoid difficult bugs with variable hoisting. It is a bad practice to use `var` declarations because variables declared using `var` can be accessed in a function-wide scope.",
                "severity": "CRITICAL",
                "isRecommended": false,
                "id": "SXNzdWU6YnZ2Z2ti",
                "description": "Variables should be used inside of their binding context.\nThis helps avoid difficult bugs with variable hoisting.\nIt is a bad practice to use `var` declarations because variables declared using `var` can be accessed in a function-wide scope.\nThey can even be accessed before declaration.\nIn such cases, their value would be `undefined` because only declarations and not initializations are hoisted.\n\n### Bad Practice\n\n```js\nfunction doIf() {\n    if (cond()) {\n        var build = true;\n    }\n    console.log(build);\n}\n\nfunction doIfElse() {\n    if (cond()) {\n        var build = true;\n    } else {\n        var build = false;\n    }\n    console.log(build)\n}\n```\n\n### Recommended\n\n```js\nfunction doIf() {\n    let build;\n    if (cond()) {\n        build = true;\n    }\n    console.log(build);\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Either all code paths should have explicit returns, or none of them",
                "tags": [],
                "shortcode": "JS-0045",
                "shortDescription": "Any code paths that do not have explicit returns will return `undefined`. It is recommended to replace any implicit dead-ends that return `undefined` with a `return null` statement.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6enJlcXZi",
                "description": "Any code paths that do not have explicit returns will return `undefined`.\nIt is recommended to replace any implicit dead-ends that return `undefined` with a `return null` statement.\n\nAs a convention, `undefined` signals that an unexpected value has been produced as the\nresult of a logical error in the program.\nA `null` return, on the other hand, signals that the input to a function was incorrect,\nor a value was 'not found'.\n\nHaving this distinction in code helps you figure out if something was caused because of a logical error,\nor malformed input to a function call.\n\n### Bad Practice\n\n```js\nfunction getUser(name) {\n    if (userExists(name)) {\n        return userDb.get(name);\n    }\n    // whoops! Implicit undefined return\n}\n\nfunction readFile(fileName) {\n    if (fs.existsSync(fileName)) {\n        return fs.readFileSync(fileName, 'utf-8');\n    }\n\n    return; // Implicit undefined return.\n}\n```\n\n### Recommended\n\n```js\nfunction getUser(name) {\n    if (userExists(name)) {\n        return userDb.get(name);\n    }\n\n    // `null` indicates there is no such user.\n    return null;\n}\n\nfunction readFile(fileName) {\n    if (fs.existsSync(fileName)) {\n        return fs.readFileSync(fileName, 'utf-8');\n    }\n\n    // `null` indicates there is no such file.\n    return null;\n}\n```\n\n### References\n\n- [Stack Overflow: When is null or undefined used in JavaScript?](https://stackoverflow.com/questions/6429225/when-is-null-or-undefined-used-in-javascript)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "No default cases in switch statements",
                "tags": [],
                "shortcode": "JS-0047",
                "shortDescription": "Some code conventions require that all switch statements have a default case, even if the default case is empty. The idea is to always explicitly state what the default behavior should be so that it's clear that the developer didn't forget to handle the default fallback case.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ym1yam56",
                "description": "Some code conventions require that all switch statements have a default case, even if the default case is empty.\nThe idea is to always explicitly state what the default behavior should be so that it's clear that the developer didn't forget to handle the default fallback case.\n\n### Bad Practice\n```js\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n}\n```\n\n### Recommended\n```js\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n\n    default:\n        /* code */\n        break;\n}\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n\n    // no default\n}\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n\n    // No Default\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Avoid square-bracket notation when accessing properties",
                "tags": [],
                "shortcode": "JS-0049",
                "shortDescription": "In JavaScript, there are two ways to access the properties of an object:\n\n- dot-notation `(object.property)` ( Recommended )\n- square-bracket notation `(object[\"property\"])` ( Bad Practice )\n\nThe dot notation is preferred because it is easier to read, less verbose, and works better with aggressive JavaScript minimizers.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6emF2eHFi",
                "description": "In JavaScript, there are two ways to access the properties of an object:\n\n- dot-notation `(object.property)` ( Recommended )\n- square-bracket notation `(object[\"property\"])` ( Bad Practice )\n\nThe dot notation is preferred because it is easier to read, less verbose, and works better with aggressive JavaScript minimizers.\n\n<!--more-->\n\n### Bad Practice\n```js\nconst x = object[\"property\"];\n```\n\n### Recommended\n```js\nconst x = object.property;\nx = object[y];\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          }
        ]
      }
    }
  }
}