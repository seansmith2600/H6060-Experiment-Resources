{
  "data": {
    "repository": {
      "issues": {
        "totalCount": 64,
        "edges": [
          {
            "node": {
              "issue": {
                "title": "Protected fields in a final class are useless",
                "tags": [],
                "shortcode": "JAVA-W0417",
                "shortDescription": "This class is declared to be final, but declares fields to be protected. Such code is confusing, since protected fields in final classes are effectively the same as private fields.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ymd4eHdy",
                "description": "This class is declared to be final, but declares fields to be protected. Such code is confusing, since protected fields in final classes are effectively the same as private fields.\n\n<!--more-->\n\n### Bad Practice\n\n```java\nfinal class A {\n\n      // This field is effectively private since A cannot be subclassed further.\n      protected int abc;\n\n}\n```\n\n### Recommended\n\nSince the class is final, it can not be derived from, and a protected field in a final class is essentially private. The access modifier for the field should be changed to `private` or `public` to represent the true use for the field.\n\n```java\nfinal class A {\n\n      private int abc;\n\n}\n\n```\n\n## References\n\n- SpotBugs - [CI\\_CONFUSED\\_INHERITANCE](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#ci-class-is-final-but-declares-protected-field-ci-confused-inheritance)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "`Object.getClass` does not need to be invoked on an instantiated object",
                "tags": [],
                "shortcode": "JAVA-W0077",
                "shortDescription": "This method allocates an object just to call `getClass()` on it, in order to retrieve the `Class` object for it. It is simpler to just access the static `.class` property of the class itself.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6em1xanF6",
                "description": "This method allocates an object just to call `getClass()` on it, in order to retrieve the `Class` object for it. It is simpler to just access the static `.class` property of the class itself.\n\n<!--more-->\n\n### Bad Practice\n\n```java\nClass<SomeClass> c = new SomeClass().getClass();\n```\n\n### Recommended\n\n```java\nClass<SomeClass> c = SomeClass.class;\n```\n\nJust use the static `.class` property when you can statically determine the class object you need.\n\n## References\n\n- SpotBugs - [DM\\_NEW\\_FOR\\_GETCLASS](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#dm-method-allocates-an-object,-only-to-get-the-class-object-dm-new-for-getclass)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Abstract class constructors should not be public",
                "tags": [],
                "shortcode": "JAVA-W1094",
                "shortDescription": "Abstract classes cannot be instantiated, so their constructors need not be public. Consider marking the constructor as protected instead.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YmV2bXdq",
                "description": "Abstract classes cannot be instantiated, so their constructors need not be public. Consider marking the constructor as protected instead.\n\n<!--more-->\n\n## Bad Practice\n\n```java\nabstract class SomeClass {\n    public SomeClass(...) {\n        // ...\n    }\n}\n```\n\n## Recommended\n\nMake the constructor protected.\n\n```java\nabstract class SomeClass {\n    protected SomeClass(...) {\n        // ...\n    }\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Avoid using `equals` to compare against `null`",
                "tags": [],
                "shortcode": "JAVA-E0051",
                "shortDescription": "Tests for null should not use the `equals` method. The '==' operator should be used instead.",
                "severity": "CRITICAL",
                "isRecommended": false,
                "id": "SXNzdWU6enlsd2p2",
                "description": "Tests for null should not use the `equals` method. The '==' operator should be used instead.\n\n<!--more-->\n\nConsider this string declaration:\n```\nString x = \"foo\";\n```\n\n### Bad Practice\n\n```java\nif (x.equals(null)) {\n    doSomething();\n}\n```\nIf `x` is null in the above snippet, calling `equals` on it would result in a `NullPointerException`.\n\n### Recommended\n```java\nif (x == null) {\n    doSomething();\n}\n```\n\nSince the `==` operator directly compares references, it does not have the same problem.\n\n## References\n- PMD - [EqualsNull](https://pmd.github.io/latest/pmd_rules_java_errorprone.html#equalsnull)",
                "category": "BUG_RISK",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Method superfluously delegates to parent class method",
                "tags": [],
                "shortcode": "JAVA-W1016",
                "shortDescription": "This method appears to only call its superclass implementation, while directly passing its parameters to the super method. This method can be removed, as it provides no additional value.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6YmRsb3Jy",
                "description": "This method appears to only call its superclass implementation, while directly passing its parameters to the super method. This method can be removed, as it provides no additional value.\n\n<!--more-->\n\n### Bad Practice\n\n```java\n@Override\npublic String getName() {\n    return super.getName();\n}\n```\n\nThis `getName` method is redundant, since the same behavior would occur even without explicitly overriding the parent method.\n\n### Recommended\n\nRemove the redundant overriding method. If this was not intended, and there is further logic to be implemented, consider marking this method with a `TODO` comment to ensure it is not missed in future work.\n\n```java\n@Override\npublic String getName() {\n    // TODO: this method requires extra logic to be implemented.\n    return super.getName();\n}\n```\n\n## References\n\n- SpotBugs - [USM\\_USELESS\\_SUBCLASS\\_METHOD](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#usm-method-superfluously-delegates-to-parent-class-method-usm-useless-subclass-method)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "`switch` statements with only 2 branches should be `if` statements instead",
                "tags": [],
                "shortcode": "JAVA-W1086",
                "shortDescription": "`switch` statements that have only two arms can be better represented as `if` statements.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6endweXFh",
                "description": "`switch` statements that have only two arms can be better represented as `if` statements.\n\n<!--more-->\n\nIf the intent is to add more cases later on, consider adding a `// skipcq: JAVA-W1086` to\nthe top of the switch block to avoid reporting the issue.\n\n### Bad Practice\n\n```java\nswitch (someInt) {\n    case 1 -> action1();\n    default -> elseAction();\n}\n```\n\n### Recommended\n\nJust use an `if-else` block:\n\n```java\nif (someInt == 1) {\n    action1();\n} else {\n    elseAction();\n}\n```\n\n### Exceptions\n\nThis issue will not be reported for switch blocks that have multiple non-default arms.",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Unused private field detected",
                "tags": [],
                "shortcode": "JAVA-W1025",
                "shortDescription": "A private field which is not referenced anywhere in this file was detected.\n\nSuch a field is useless and can be safely removed.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnBqZXBt",
                "description": "A private field which is not referenced anywhere in this file was detected.\n\nSuch a field is useless and can be safely removed.\n\n<!--more-->\n\n### Bad Practice\n\n```java\nclass SomeClass {\n    private int unused; // Not used anywhere within `SomeClass`.\n\n    // ...\n}\n```\n\n### Recommended\n\nRemove the field if is is not used anywhere. If the field was meant to be inherited, mark it as `protected` instead.\n\n```java\nclass SomeClass {\n    protected int usedInSubclass;\n\n    // ...\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Double assignment of variable detected",
                "tags": [],
                "shortcode": "JAVA-E1063",
                "shortDescription": "A double assignment of a variable to itself has been detected. This may be a typo.\n\nCheck whether this is correct and edit it or remove the extra assignment.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enBqbXBu",
                "description": "A double assignment of a variable to itself has been detected. This may be a typo.\n\nCheck whether this is correct and edit it or remove the extra assignment.\n\n<!--more-->\n\nWhen used as an expression, an assignment evaluates to the result of the RHS expression. For example, in the assignment `a = 3`, Java would evaluate the result of the assignment as `3`.\n\n### Bad Practice\n\nAssigning a value to itself is redundant and does not achieve any benefits over assigning just the value of the RHS expression.\n\n```java\nsomeVar = someVar = ...; // redundant!\n```\n\n### Recommended\n\nIt is likely that this was a typo. Perhaps the intention was to use a different variable in place of one of the repeated names.\n\n```java\nsomeVar = someOtherVar = ...;\n```\n\n**Alternatives**\n\nConsider changing this double assignment into two single, separate assignments on different lines.\n\n```java\nsomeVar = ...;\n\nsomeOtherVar = someVar;\n```\n\nThis can have multiple benefits:\n\n* It is clear where an assignment occurs.\n* It is easier to understand what value is being assigned to what variable.\n* It improves readability.",
                "category": "BUG_RISK",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Use `assertNull`/`NotNull` instead of `assertEquals`/`notEquals` to assert nullity",
                "tags": [],
                "shortcode": "JAVA-W1091",
                "shortDescription": "Use the `assertNull` and `assertNotNull` methods instead of using `assertEquals` or `assertNotEquals` with an expected `null` argument.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6emtncXB4",
                "description": "Use the `assertNull` and `assertNotNull` methods instead of using `assertEquals` or `assertNotEquals` with an expected `null` argument.\n\n<!--more-->\n\nThis issue is raised when the Java analyzer detects a usage of `assertEquals` or `assertNotEquals` where one of the arguments is a null value.\n\n## Bad Practice\n\n```java\nAssertions.assertEquals(null, result);\n```\n\n## Recommended\n\nUse the `assertNull` and `assertNotNull` methods instead:\n\n```java\nAssertions.assertNull(result);\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Method can be declared static",
                "tags": [],
                "shortcode": "JAVA-W1057",
                "shortDescription": "Private final methods that do not access instance fields should be declared static.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6Ym92cGtt",
                "description": "Private final methods that do not access instance fields should be declared static.\n\n<!--more-->\nSince the method is private and final, it can't possibly be overridden. Therefore, the only possible definition of the method that exists doesn't access any instance fields.\nSo we can safely declare it as static.\n\n### Bad Practice\n\n```java\npublic class Klass {\n    private final int aField = 10;\n\n    private final void method() {\n        // ...statements that do not access `aField`\n    }\n}\n```\n\n### Recommended\n\nConsider declaring the method static.\n\n```java\npublic class Klass {\n    private final int aField = 10;\n\n    private static final void method() {\n        // ...statements that do not access `aField`\n    }\n}\n```\n\n## References\n- StackOverflow - [Should all methods that do not use instance fields be static?](https://stackoverflow.com/questions/7234807/should-all-methods-that-do-not-use-instance-variables-be-marked-static)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": true
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Iterator `next` method should throw `NoSuchElementException`",
                "tags": [],
                "shortcode": "JAVA-W0146",
                "shortDescription": "This class implements the `java.util.Iterator` interface. However, its `next()` method is not capable of throwing `java.util.NoSuchElementException`.  This is a violation of the `Iterator` interface's contract, and will not work with code that expects `next()` to throw when the iterator is exhausted.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnlsbHdx",
                "description": "This class implements the `java.util.Iterator` interface. However, its `next()` method is not capable of throwing `java.util.NoSuchElementException`.\n\nThis is a violation of the `Iterator` interface's contract, and will not work with code that expects `next()` to throw when the iterator is exhausted.\n\nThe `next()` method should be changed so it throws `NoSuchElementException` if is called when there are no more elements to return.\n\n### Bad Practice\n\nThis is a nonconforming implementation and may mislead API consumers.\n\n```java\n// Within iterator implementation\n@Override\npublic T next() {\n    if (hasNext()) { ... }\n    else return null;\n}\n```\n\n### Recommended\n\nThis implementation should be preferred:\n\n```java\n@Override\npublic T next() {\n    if (hasNext()) { ... }\n    else throw NoSuchElementException();\n}\n```\n\nIf the iterator will never throw, it may be preferable to write `hasNext()` to always return `true`, while throwing if `hasNext()` returns false. Obviously that would never occur, but it can serve to convey the intent. Always document such behavior for consumers of your API.\n\n```java\n@Override\npublic boolean hasNext() {\n    return true;\n}\n```\n\nOtherwise, a `NoSuchElementException` must be thrown to ensure conformance with the `Iterator` API.\n\n## References\n- SpotBugs - [IT\\_NO\\_SUCH\\_ELEMENT](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#it-iterator-next-method-can-t-throw-nosuchelementexception-it-no-such-element)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Audit: `DocumentBuilder` may be vulnerable to XXE attacks",
                "tags": [
                  "a05",
                  "cwe-327",
                  "security",
                  "cwe-776",
                  "sans-top-25",
                  "owasp-top-10"
                ],
                "shortcode": "JAVA-A1052",
                "shortDescription": "This code appears to use a `DocumentBuilder` instance without setting the correct input processing flags. This could allow [XML External Entity (XXE)](https://en.wikipedia.org/wiki/XML_external_entity_attack) attacks to easily occur.",
                "severity": "CRITICAL",
                "isRecommended": true,
                "id": "SXNzdWU6emRsZGFh",
                "description": "This code appears to use a `DocumentBuilder` instance without setting the correct input processing flags. This could allow [XML External Entity (XXE)](https://en.wikipedia.org/wiki/XML_external_entity_attack) attacks to easily occur.\n\n<!--more-->\n\nTo put into perspective how XXE attacks can cause damage, consider the following examples:\n\n**Exposing Local File Data**\n\n```xml\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [\n   <!ENTITY xxe SYSTEM \"file:///etc/passwd\" > ]>\n<foo>&xxe;</foo>\n```\n\nThe example above uses XML's DTD syntax to define an XML entity whose data is present outside the file itself (it is\ntherefore an Xml eXternal Entity). That entity (`&xxe` here) is then used as the value of an XML element, `<foo>`.\n\nIt so happens that the value of the external entity is specified to be the `/etc/passwd` file of the local machine,\nwhich is in general private information which must not be shared, leave alone accessed by the server process in any way.\nIf an attacker could upload a malicious XML file with this particular declaration in it, the resulting XML file when\nparsed will also evaluate the external entity, and by extension, load the contents of `/etc/passwd`.\n\nIf the resultant data can be downloaded by the attacker again by some means, we would have described a successful data\nexfilteration attack.\n\n**XEE Denial of Service**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE lolz [\n <!ENTITY lol \"lol\">\n <!ELEMENT lolz (#PCDATA)>\n <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">\n <!ENTITY lol2 \"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\">\n <!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\">\n[...]\n <!ENTITY lol9 \"&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;\">\n]>\n<lolz>&lol9;</lolz>\n```\n\nThe above example abuses DTD syntax to create an \"XEE bomb\". An XML Entity Expansion (XEE) bomb is a type of Denial of\nService (DoS) attack that makes use of XML's DTD syntax. It is possible to define a set of XML entities, each of which\nexpand into others, to use up exponential amounts of CPU time and memory which would in turn bring the application to a\ngrinding halt.\n\nThis particular attack works because the `lol9` entity defined in the DTD tag recursively expands into an exponentially\nincreasing set of other entities as defined, until the expansion terminates, resulting in ~10^9 instances of the `lol`\nentity being created. It is likely that this will trigger an Out of Memory (OOM) crash in the best case, or possibly may render the\napplication process completely unresponsive.\n\n### Bad Practice\n\nIn the example below, a `DocumentBuilder` has been created, which neither prevents processing of DTD elements (which would\ncompletely stop any XXE or XEE attacks) nor prevents access to external files via secure processing.\n\n```java\n// No flags set.\nDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n```\n\n### Recommended\n\nHere are two ways XXE attacks can be avoided.\n\n- Using the [**`XMLConstants.FEATURE\\_SECURE\\_PROCESSING`\n  **](https://docs.oracle.com/javase/8/docs/api/javax/xml/XMLConstants.html#FEATURE_SECURE_PROCESSING) flag\n\nEnabling this flag will not disallow DTD processing, but will prevent DoS attacks by limiting recursion, and will\nprevent access to external resources.\n\n```java\n  DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n  dbf.setFeature(\"http://javax.xml.XMLConstants/feature/secure-processing\", true);\n  DocumentBuilder db = dbf.newDocumentBuilder();\n```\n\n- Disallowing DTD processing entirely\n\nWe can disable DTD processing wholesale by directly specifying the `disallow-doctype-decl` feature flag:\n\n```java\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\nDocumentBuilder db = dbf.newDocumentBuilder();\n```\n\nThis will prevent DTD entities from being processed. If you are reliant on certain DTD related features, consider using\nthe secure processing flag instead.\n\n## References\n\n- [CWE-611](https://cwe.mitre.org/data/definitions/611.html) - Improper Restriction of XML External Entity Reference ('\n  XXE')\n- [CWE-776](https://cwe.mitre.org/data/definitions/776.html) - Improper Restriction of Recursive Entity References in\n  DTDs ('XML Entity Expansion')\n- FindSecBugs - [XXE\\_DOCUMENT](https://find-sec-bugs.github.io/bugs.htm#XXE_DOCUMENT)\n- Oracle Java 8 JavaDocs - [`javax.xml.parsers.DocumentBuilderFactory`](https://docs.oracle.com/en/java/javase/11/docs/api/java.xml/javax/xml/parsers/DocumentBuilderFactory.html)\n- OWASP - [XML External Entity Processing](https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing)\n- OWASP Top Ten (2021) - [Category A05](https://owasp.org/Top10/A05_2021-Security_Misconfiguration/) - Security\n  Misconfiguration\n- WS-Attacks - [XML Entity Expansion](https://www.ws-attacks.org/index.php/XML_Entity_Expansion)\n- WS-Attacks - [XML Entity DOS](https://www.ws-attacks.org/index.php/XML_External_Entity_DOS)\n- WS-Attacks - [XML Entity Reference Attack](https://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack)\n- h3xstream - [Identifying XXE vulnerabilities](https://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html)\n- OpenJDK - [JEP 185](https://openjdk.java.net/jeps/185) - Restrict Fetching of External XML Resources",
                "category": "SECURITY",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Overly generic exceptions should not be thrown",
                "tags": [],
                "shortcode": "JAVA-W1042",
                "shortDescription": "`throws` clauses should not contain generic exception types such as `Throwable`, `Exception`, or `RuntimeException`.\n\nInstead, extend `RuntimeException` and create more specific exception types which are relevant to your use case.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnJneGRk",
                "description": "`throws` clauses should not contain generic exception types such as `Throwable`, `Exception`, or `RuntimeException`.\n\nInstead, extend `RuntimeException` and create more specific exception types which are relevant to your use case.\n<!--more-->\n\nThis issue will be reported for method and constructor declarations with `throws` clauses that contain any of the following exception types:\n\n- `java.lang.Throwable`\n- `java.lang.Exception`\n- `java.lang.RuntimeException`\n\n### Bad Practice\n\nAvoid using overly generic exception types:\n```java\npublic float getPercent() throws RuntimeException { ... }\n```\n\n### Recommended\n\nUse a more specific exception type instead.\n\n```java\nclass CalculationException extends RuntimeException {\n    // ...\n}\n\n// ...\n\npublic float getPercent() throws CalculationException { ... }\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Interface only declares static final fields",
                "tags": [],
                "shortcode": "JAVA-W1059",
                "shortDescription": "Interfaces should not contain only static final fields.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enhqbXZv",
                "description": "Interfaces should not contain only static final fields.\n\n<!--more-->\nUsing interfaces as bags of constants is considered bad practice in Java.\n\nHaving fields declared in an interface at all is a questionable design decision, but it may be justified if the fields have some significance to the implementors of the interface.\n\nUsing an interface to hold constants also imposes an unintended commitment: if some type inherits from such an interface but does not need those constants, the subtype is expected to keep the inheritance relation anyway to avoid breaking [binary compatibility](https://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html).\n\nBinary compatibility guarantees that (among other things) if a type inherits from another type, it will continue to do so in the future. This can affect the efficiency of development (Because recompilation will take longer), as well as API stability in production (If this code is part of the public API of a library).\n\n### Bad Practice\n\n```java\ninterface SomeInterface {\n    String STRING = \"somestring\";\n    double PI = 3.14\n}\n```\n\n### Recommended\n\nConsider moving the constants to classes that actually use them.\n\n```java\npublic class MyKlass implements SomeInterface {\n    private static final STRING = \"somestring\";\n    private static final PI = 3.14;\n}\n```\n\nIf the constants are being used in more than one class, consider defining a new final class solely for the purpose of holding the constants.\n\n```java\npublic final class Constants {\n    public static final STRING = \"somestring\";\n    public static final PI = 3.14;\n\n    // Prevent creating instances of this class.\n    private Constants() {}\n}\n\npublic class Klass1 {\n    public void method1() {\n        use(Constants.STRING);\n        // ..rest of the code\n    }\n}\n\npublic class Klass2 {\n    public void method2() {\n        use(Constants.PI);\n        // ..rest of the code\n    }\n}\n```\n\n## References\n- StackOverflow - [Why putting static final fields in an interface is bad?](https://stackoverflow.com/a/2659740)\n- Wikipedia - [Constant Interface](https://en.wikipedia.org/wiki/Constant_interface)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "For loop can be converted into a foreach loop",
                "tags": [],
                "shortcode": "JAVA-W1089",
                "shortDescription": "If a for loop can be converted to a foreach loop, consider doing so, as it is a more concise and readable syntax.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnJndnZh",
                "description": "If a for loop can be converted to a foreach loop, consider doing so, as it is a more concise and readable syntax.\n\n<!--more-->\n\nThis issue is raised when the Java analyzer detects that all elements of a list/array are being iterated over, in sequence, and only one element of the iterable is accessed in one loop iteration.\n\n## Bad Practice\n\n```java\nfor (int i = 0; i < list.size(); i++) {\n    SomeType value = list.get(i);\n\n    // do whatever is required with value.\n}\n```\n\n## Recommended\n\nUse the `foreach` syntax to iterate over the iterable instead.\n\n```java\nfor (SomeType value : list) {\n    // Do the required operation.\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Audit: Unsafe Jackson deserialization configurations should not be used",
                "tags": [
                  "a08",
                  "cwe-502",
                  "security",
                  "sans-top-25",
                  "owasp-top-10"
                ],
                "shortcode": "JAVA-A1024",
                "shortDescription": "Using features such as `@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)` or `ObjectMapper.enableDefaultTyping()` with Jackson can be a security risk, as such configurations are stepping stones towards a successful exploit.\n\nJackson is a well known serialization/deserialization library for Java that supports deserializing data based solely on type information contained within it. This mechanism can be abused through \"deserialization gadgets\" to execute attacks on the target system.\n\nAvoid specifying unsafe configurations for Jackson deserialization.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6Ymxsam5q",
                "description": "Using features such as `@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)` or `ObjectMapper.enableDefaultTyping()` with Jackson can be a security risk, as such configurations are stepping stones towards a successful exploit.\n\nJackson is a well known serialization/deserialization library for Java that supports deserializing data based solely on type information contained within it. This mechanism can be abused through \"deserialization gadgets\" to execute attacks on the target system.\n\nAvoid specifying unsafe configurations for Jackson deserialization.\n<!--more-->\n\nJackson has faced a [number](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-4995) of [CVEs](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-19362) based on its [polymorphic type handling (PTH)](https://medium.com/@david.truong510/jackson-polymorphic-deserialization-91426e39b96a) or polymorphic deserialization as it was previously known. This feature allows the data itself to determine the type of object it will be deserialized into. While this can be convenient, it is susceptible to exploits known as \"deserialization gadgets\", which can lead to remote code execution attacks. Deserialization gadgets are specific classes which may allow an attacker to perform arbitrary operations or access private data during instantiation.\n\n### Bad Practice\n\nThis isssue will be raised if a class uses the `@JsonTypeInfo` annotation with the `use` value set to `Id.CLASS` or `Id.MINIMAL_CLASS`.\n```java\n@JsonTypeInfo(use = Id.CLASS)\nabstract class SomeClass {\n    // ...\n}\n```\n\nIt will also be raised if a Jackson `ObjectMapper` instance has the `enableDefaultTyping()` method called on it:\n```java\nObjectMapper mapper = new ObjectMapper();\nmapper.enableDefaultTyping();\n```\n\n### Recommended\n\nUse `@JsonTypeInfo(use = Id.NAME)`, along with `@JsonTypeName` as well as `JsonSubTypes` to allow polymorphic type handling.\n```java\n@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = As.PROPERTY, property = \"type\")\n@JsonSubTypes({\n   @JsonSubTypes.Type(value = Square.class, name = \"square\"),\n   @JsonSubTypes.Type(value = Circle.class, name = \"circle\")\n})\nclass Shape {\n    public String name;\n\n    Shape(String name) {\n      this.name = name;\n   }\n}\n\n@JsonTypeName(\"square\")\nclass Square extends Shape {\n   public double length;\n\n   Square() {\n      this(null, 0.0);\n   }\n\n   Square(String name, double length) {\n      super(name);\n      this.length = length;\n   }\n}\n\n@JsonTypeName(\"circle\")\nclass Circle extends Shape {\n   public double radius;\n\n   Circle() {\n      this(null, 0.0);\n   }\n\n   Circle(String name, double radius) {\n      super(name);\n      this.radius = radius;\n   }\n}\n```\n\n## References\n\n- `@cowtowncoder` - [On Jackson CVEs](https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n- OWASP Top Ten (2021) - [Category A08](https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/) - Software and Data Integrity Failures\n- [CWE-502](https://cwe.mitre.org/data/definitions/502.html) - Deserialization of untrusted data\n- FindSecBugs - [JACKSON_UNSAFE_DESERIALIZATION](https://find-sec-bugs.github.io/bugs.htm#JACKSON_UNSAFE_DESERIALIZATION)",
                "category": "SECURITY",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "`equals` method does not handle null valued operands",
                "tags": [],
                "shortcode": "JAVA-E0110",
                "shortDescription": "This implementation of `equals(Object)` violates the contract defined by `java.lang.Object.equals(Object)` because it does not check for `null` being passed as the argument.\n\n`equals` must always return `false` if its argument is `null`.",
                "severity": "CRITICAL",
                "isRecommended": true,
                "id": "SXNzdWU6YmRscWph",
                "description": "This implementation of `equals(Object)` violates the contract defined by `java.lang.Object.equals(Object)` because it does not check for `null` being passed as the argument.\n\n`equals` must always return `false` if its argument is `null`.\n\n<!--more-->\n\nThis can lead to the code throwing a `NullPointerException` when a null value is passed. One property of any non-static method in Java is that the receiver object (`this`) is always non-null. This code violates the contract of `equals` because any null value passed is automatically not equal to `this`.\n\n### Bad Practice\n```java\n\n@Override\npublic boolean equals(Object o) {\n    return this.field == o.field;\n}\n\n// ...\n\nMyClass a = new MyClass(3);\n\na.equals(null); // Throws a NullPointerException.\n\n```\n\n### Recommended\n```java\n\n@Override\npublic boolean equals(Object o) {\n    return o != null && this.field == o.field;\n}\n\n```\n\nThe `equals` method should return `false` if passed a null value. Assuming that the operands are always non-null may easily allow `NullPointerException`s to occur.\n\n## References\n\n- Spotbugs - [NP\\_EQUALS\\_SHOULD\\_HANDLE\\_NULL\\_ARGUMENT](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#np-equals-method-does-not-check-for-null-argument-np-equals-should-handle-null-argument)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Self assignment of local variable detected",
                "tags": [],
                "shortcode": "JAVA-E0291",
                "shortDescription": "A local variable is assigned to itself.",
                "severity": "CRITICAL",
                "isRecommended": false,
                "id": "SXNzdWU6emFscmtt",
                "description": "A local variable is assigned to itself.\n\n<!--more-->\n\nThis is essentially a noop but it may be indicative of a different problem. It may be that the variable shadows another in a parent scope, or that the variable may shadow a field of the object itself. Such code can cause confusion and subtle logic errors that are hard to catch.\n\n### Bad Practice\n```java\npublic void foo() {\n    int x = 3;\n    int y = someInt;\n    // ...\n    x = x; // Useless self assignment.\n}\n```\n\n### Recommended\n\nAlways check that the correct variable is being assigned to (or from)\n\n```java\npublic void foo() {\n    int x = 3;\n    int y = someInt;\n    // ...\n    y = x; // Here, we assign x to y.\n}\n```\n\nCheck if you meant to assign a field or another local variable with a similar name instead.",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Non-thread-safe date/time fields should not be public and static",
                "tags": [],
                "shortcode": "JAVA-E1024",
                "shortDescription": "Avoid storing non-thread-safe `java.util` date/time API classes in public static fields.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnlscHB3",
                "description": "Avoid storing non-thread-safe `java.util` date/time API classes in public static fields.\n\n<!--more-->\n\nThese classes are not designed to be used directly over multiple threads and issues such as race conditions or spurious crashes may occur.\n\nThis issue will be reported if a `public static` field is found having any of the following types:\n\n- [`java.util.Calendar`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Calendar.html)\n- [`java.text.SimpleDateFormat`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/text/SimpleDateFormat.html#synchronization)\n\n`Calendar` is particularly insidious in this, as its documentation makes no mention of its lack of thread safety.\n\n### Bad Practice\n\nConsider the example below, which uses `Calendar` (the same principle applies to `SimpleDateFormat` as well). Because `CAL_INSTANCE` is `public`, it can be accessed by any external code.\n\n```java\npublic static final Calendar CAL_INSTANCE = ...;\n```\n\nModifying (or even accessing fields of) a `Calendar` instance will mutate it, and such mutations can cause unintended state changes on other threads.\n\n### Recommended\n\nIf a single global `Calendar` instance is absolutely required, make sure to keep the field `private`, and predefine all possible actions that will be performed with the object as synchronized methods. This reduces the chances of race conditions occurring due to unsynchronized usage of the specific calendar instance.\n\n```java\nprivate static final Object LOCK = new Object();\nprivate static final Calendar cal = ...;\n\npublic Date getDateAfter(int days) {\n    synchronized(LOCK) {\n        cal.add(Calendar.DAY, days);\n        Date date = cal.getTime();\n        cal.add(Calendar.DAY, -days);\n        return date;\n    }\n}\n```\n\nIf each thread requires a persistent instance, consider wrapping the field in a `ThreadLocal` instead. This will allow for keeping the field `public` and `static` while still preserving thread safety.\n\n```java\npublic static ThreadLocal<Calendar> = ThreadLocal.withInitial(() -> Calendar.getInstance());\n```\n\nIf a global instance is not required, just use an instance value, or create a new instance on demand.\n\n\n**Alternatives**\n\nIf possible, consider using a better date/time API such as [`java.time`](https://www.oracle.com/technical-resources/articles/java/jf14-date-time.html) (For Java versions 8 and above) or [Joda-time](https://www.joda.org/joda-time/) (For Java versions 7 and below), which do not have such thread safety issues.\n\n## References\n\n- Oracle Java 17 JavaDocs - [`java.util.Calendar`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Calendar.html)\n- Oracle Java 17 JavaDocs - [`java.text.SimpleDateFormat`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/text/SimpleDateFormat.html#synchronization)\n- Stackoverflow - [Is `java.util.Calendar` thread-safe or not?](https://stackoverflow.com/questions/12131324/is-java-util-calendar-thread-safe-or-not)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Custom serialization method is declared with an incorrect signature",
                "tags": [],
                "shortcode": "JAVA-E1033",
                "shortDescription": "This class declares one or more custom serialization methods but these methods do not match the signatures expected by Java's serialization API.\n\nChange the signature(s) to match the expected type.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnlscHlv",
                "description": "This class declares one or more custom serialization methods but these methods do not match the signatures expected by Java's serialization API.\n\nChange the signature(s) to match the expected type.\n\n<!--more-->\n\nJava expects the signatures of the `readObject`, `readObjectNoData` and `writeObject` methods to exactly match certain signatures, as codified in the specification for the [`Serializable` API](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html):\n\nClasses that require special handling during the serialization and deserialization process must implement special methods with these exact signatures:\n\n```java\nprivate void writeObject(java.io.ObjectOutputStream out) throws IOException;\n\nprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;\n\nprivate void readObjectNoData() throws ObjectStreamException;\n```\n\nIf these methods are not declared with the correct signatures, Java will perform serialization without the expected custom behavior.\n\nThe reason serialization works like this is because the custom serialization behavior of a class only applies to the fields declared in that class, and cannot be shared with its descendants. Thus, custom serialization methods are private. Descendants of the class are likewise expected to privately implement extra logic as required to serialize and deserialize data for their own declared fields.\n\n### Bad Practice\n\n```java\n    // readObjectNoData should return void!\n    private int readObjectNoData() throws ObjectStreamException {\n        // ...\n    }\n\n    // readObject should not be public!\n    public void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        // ...\n    }\n\n    // writeObject should not throw ClassNotFoundException!\n    private void writeObject(ObjectOutputStream object) throws ClassNotFoundException {\n        // ...\n    }\n```\n\n### Recommended\n\nSpecify the method signatures for these methods as expected by Java.\n\n## References\n\n- Oracle Java 11 JavaDocs - [java.io.Serializable](https://www.oracle.com/technical-resources/articles/java/serializationapi.html)\n- Oracle - [Discover the secrets of the Java Serializable API](https://www.oracle.com/technical-resources/articles/java/serializationapi.html)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Loop conditions should be true at least once",
                "tags": [],
                "shortcode": "JAVA-E1045",
                "shortDescription": "This loop's condition is never true, meaning it will never execute (or, for a `do` loop, only execute once). Check the condition and rectify it if there are mistakes. If used to disable the code, consider commenting the code out, or removing the loop entirely.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enBqZW9t",
                "description": "This loop's condition is never true, meaning it will never execute (or, for a `do` loop, only execute once). Check the condition and rectify it if there are mistakes. If used to disable the code, consider commenting the code out, or removing the loop entirely.\n\n<!--more-->\n\n### Bad Practice\n\n```java\nwhile (false) {\n    // Will not execute...\n}\n\n// ...\n\nint a = 2;\n\n// this loop will never start...\nwhile (a < 0) {\n    // ...\n    a += 2;\n}\n```\n\n### Recommended\n\nRemove the code or fix the loop.\n\n```java\nint a = 2;\n\n// The loop condition is now fixed.\nwhile (a < 20) {\n    // ...\n    a += 2;\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Call to unsupported method detected",
                "tags": [],
                "shortcode": "JAVA-E1048",
                "shortDescription": "A method that unconditionally throws an [`UnsupportedOperationException`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/UnsupportedOperationException.html) was called. Avoid calling methods that you know will always throw an exception.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6YmtnZW5h",
                "description": "A method that unconditionally throws an [`UnsupportedOperationException`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/UnsupportedOperationException.html) was called. Avoid calling methods that you know will always throw an exception.\n<!--more-->\n\nThis issue is raised when:\n1. A final method that throws `UnsupportedOperationException` is called.\n2. A method that throws `UnsupportedOperationException`, which is declared in a final class, is called.\n\n### Bad Practice\n\n```java\nclass SomeClass {\n  final void doSomething() {\n    throw new UnsupportedOperationException();\n  }\n\n  // ...\n}\n// ...\n\nSomeClass someObject = new SomeClass();\n\nsomeObject.doSomething();  // Will always throw!\n```\n\n### Recommended\n\nCheck if you are calling this method on the correct class. If you called this method by accident, consider changing your code to avoid calling it.\n\n## References\n\n- Oracle Java 11 JavaDocs - [`java.lang.UnsupportedOperationException`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/UnsupportedOperationException.html)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Interface is unimplementable",
                "tags": [],
                "shortcode": "JAVA-E1041",
                "shortDescription": "This interface cannot be implemented because it declares one or more methods that clash with the names of methods defined in `java.lang.Object`.\n\nRename the methods that clash with `Object`'s declared methods so that there are no more conflicts.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6Ym5qb2tq",
                "description": "This interface cannot be implemented because it declares one or more methods that clash with the names of methods defined in `java.lang.Object`.\n\nRename the methods that clash with `Object`'s declared methods so that there are no more conflicts.\n\n<!--more-->\n\nThe methods defined in `Object` have certain specific properties:\n* Attempting to redeclare `Object`'s `final` methods in a class or interface with the same name and formal parameters will always fail with a compilation error.\n* Public overridable methods of `Object` (such as `toString()`) will similarly not allow overloads that have the same argument types but different return types.\n* Protected methods, such as `clone()` may be defined with a different return type in an interface without incident, but cannot ever be implemented, because the declarations present in both the interface and within `Object` would clash.\n\nThe third point in particular is not immediately apparent. But when a class attempts to inherit from an affected interface, `javac` will raise a compile error.\n\n### Bad Practice\n\n```java\ninterface SomeInterface {\n\n    int toString(); // This is a compile error.\n\n    void wait(); // wait is final in object, it cannot be overridden.\n\n    String clone(); // clone is protected in Object and will clash when this interface is implemented.\n}\n\nclass SomeClass implements SomeInterface {\n\n\n    @Override\n    String clone() { // This method's signature will clash with the one defined in Object.\n        return \"\";\n    }\n}\n```\n\n### Recommended\n\nGive the offending method(s) a different name to avoid clashes with `Object`'s members.\n\n## References",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Inefficient use of `String` constructor",
                "tags": [],
                "shortcode": "JAVA-P0062",
                "shortDescription": "Creating a `String` using object creation wastes memory because the new `String` object so constructed will be functionally indistinguishable from the `String` value passed as a parameter. Just use the string directly.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6enZkd2Vq",
                "description": "Creating a `String` using object creation wastes memory because the new `String` object so constructed will be functionally indistinguishable from the `String` value passed as a parameter. Just use the string directly.\n\n<!--more-->\n\n### Bad Practice\n```java\nString a = new String(\"abc\");\n```\n\n\n### Recommended\n```java\nString a = \"abc\";\n```\n\n## References\n\n- Spotbugs - [DM\\_STRING\\_CTOR](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#dm-method-invokes-inefficient-new-string-string-constructor-dm-string-ctor)",
                "category": "PERFORMANCE",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "`TimeZone.getTimeZone` should be passed correct timezone IDs",
                "tags": [],
                "shortcode": "JAVA-E1093",
                "shortDescription": "[`java.util.TimeZone.getTimeZone()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TimeZone.html#getTimeZone(java.lang.String))\nshould not be passed invalid time zone identifier strings, as this will make it fail silently and return GMT instead.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YmxsYW14",
                "description": "[`java.util.TimeZone.getTimeZone()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TimeZone.html#getTimeZone(java.lang.String))\nshould not be passed invalid time zone identifier strings, as this will make it fail silently and return GMT instead.\n\n<!--more-->\n\nJava cannot check for invalid timezones at compile time, so it is up to the developer to ensure that the string provided is actually valid. To avoid accidentally using an invalid time zone, it is recommended to select from a known list of timezone identifiers, such as those provided by the [`ZoneId.getAvailableZoneIds()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/ZoneId.html#getAvailableZoneIds()) method.\n\n### Bad Practice\n\n```java\nTimeZone tz = TimeZone.getTimeZone(\"invalid/timezone\"); // tz is assigned the GMT time zone.\n```\n\n### Recommended\n\nUse a valid timezone string.\n\n```java\nTimeZone tz = TimeZone.getTimeZone(\"America/New_York\");\n```\n\n## References\n\n- Oracle Java 11 Javadocs - [`java.util.TimeZone.getTimeZone()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TimeZone.html#getTimeZone(java.lang.String))",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "`BigDecimal` constructed from `double` may be imprecise",
                "tags": [],
                "shortcode": "JAVA-W0008",
                "shortDescription": "`BigDecimal`s constructed from a `double` may not be represented correctly.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6em92anJs",
                "description": "`BigDecimal`s constructed from a `double` may not be represented correctly.\n\n<!--more-->\n\nThis code creates a `BigDecimal` from a `double` value that may not translate well to a decimal number. This happens due to the way real numbers are represented in binary. Only rational numbers that are powers of 2 can be represented with perfect accuracy in types such as `float` and `double`. For example, numbers such as `1/16` or `1/1024` are precisely representable whereas the binary representation of a number such as `1/10` would expand infinitely (similarly to how `1/3`'s decimal form expands infinitely when you try writing it down).\n\nFrom `BigDecimal`'s [JavaDocs](https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#BigDecimal(double)):\n> One might assume that writing `new BigDecimal(0.1)` in Java creates a `BigDecimal` which is exactly equal to `0.1` (an unscaled value of 1, with a scale of 1), but it is actually equal to `0.1000000000000000055511151231257827021181583404541015625`.\n\nFor more information on why this occurs, see this [wikipedia article](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Representable_numbers,_conversion_and_rounding)\n\nYou probably want to use the `BigDecimal.valueOf(double d)` method, which uses the `String` representation of the `double` to create the `BigDecimal` (e.g., `BigDecimal.valueOf(0.1)` gives `0.1`).\n\n\n\n```java\n\nBigDecimal bad = new BigDecimal(0.1);\n\nBigDecimal good = BigDecimal.valueOf(0.1);\n\n```\n\n## References\n\n\n- [CERT NUM10-J](https://wiki.sei.cmu.edu/confluence/x/kzdGBQ) - Do not construct BigDecimal objects from floating-point literals\n- Spotbugs - [DMI\\_BIGDECIMAL\\_CONSTRUCTED\\_FROM\\_DOUBLE](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#dmi-bigdecimal-constructed-from-double-that-isn-t-represented-precisely-dmi-bigdecimal-constructed-from-double)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Exception classes must be named appropriately",
                "tags": [],
                "shortcode": "JAVA-W1000",
                "shortDescription": "This class is an exception, but its name does not end in `Exception`. This could be confusing to consumers of your API.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnhqanFq",
                "description": "This class is an exception, but its name does not end in `Exception`. This could be confusing to consumers of your API.\n\n<!--more-->\n\n### Bad Practice\n\n```java\nclass BadName extends Exception {\n    // ...\n}\n```\n\n### Recommended\n\n```java\nclass ActuallyAnException extends Exception {\n    // ...\n}\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Redundant type check",
                "tags": [],
                "shortcode": "JAVA-W1021",
                "shortDescription": "This code attempts to perform an `instanceof` check of a type with its supertype. This is a redundant operation as such a check will always return `true`.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YmptcG94",
                "description": "This code attempts to perform an `instanceof` check of a type with its supertype. This is a redundant operation as such a check will always return `true`.\n\n<!--more-->\n\nFor two classes `A` and `B`, where `A extends B`, an instance of `A` can also be treated as an instance of `B`. Thus, a check such as `<some instance of A> isntanceof B` will always return `true`.\n\nThis may have been a typo. Check if the type you are checking for is correct, and rectify it if not.\n\n### Bad Practice\n\n```java\nInteger a = 3;\n\n// `a` is already a Number\nif (a instanceof Number) {\n    // ...\n}\n```\n\n### Recommended\n\nIf the check serves no purpose, remove it. Else, verify that the proper type is being checked for.\n\n## References\n\n- Oracle Java Language Specification - [Section 15.20.2](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2) - Type Comparison Operator `instanceof`",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Classes that contain only static members should not be instantiated",
                "tags": [],
                "shortcode": "JAVA-W1035",
                "shortDescription": "This code seems to be creating an instance of a class with only static members. Such a class does not need to be instantiated, since all members can be accessed with just the class itself.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6em5qYWtl",
                "description": "This code seems to be creating an instance of a class with only static members. Such a class does not need to be instantiated, since all members can be accessed with just the class itself.\n\n<!--more-->\n\n### Bad Practice\n\n```java\n\nfinal class StaticHolder {\n    public final static Object THING1 = new Object();\n    public final static Object THING2 = new Object();\n}\n\n// ... elsewhere ...\n\nStaticHolder someHolder = new StaticHolder();\n\n// OR\n\nObject thing = new StaticHolder().THING1; // Unnecessary!\n```\n\n### Recommended\n\nUse the class instance directly.\n\n```java\nObject thing = StaticHolder.THING1;\n```",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Avoid catching assertions in tests",
                "tags": [],
                "shortcode": "JAVA-W1076",
                "shortDescription": "Avoid catching assertion exceptions, they are meant to indicate that something should not have happened.",
                "severity": "CRITICAL",
                "isRecommended": true,
                "id": "SXNzdWU6emV2ZGp2",
                "description": "Avoid catching assertion exceptions, they are meant to indicate that something should not have happened.\n\n<!--more-->\n\nThis can happen when there is a catch block for `Throwable` or `Error`, or if one tries to directly catch an `AssertionError` or its descendents. \n\nBecause `Throwable` is the parent of all exception and error types, and even assertion failures are represented as thrown `Error`s, it is inadvisable to catch either of `Throwable` or `Error` in a test.\n\n### Bad Practice\n\n```java\ntry {\n    assertTrue(someCondition);\n} catch (Throwable e) { // Don't catch Throwable in tests!\n    // ...\n}\n```\n\n### Recommended\n\nAvoid catching overly generic exception types such as `Throwable` or `Error`, and do not attempt to catch `AssertionError`s.\n\nIf you really require generic exception handling within a test, catch only `Exception`s.\n\n```java\ntry {\n    assertTrue(someCondition);\n} catch (Exception e) {  // this will not interfere with assertions.\n    // ...\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Explicit invocation of garbage collection is detrimental apart from some benchmarking use cases",
                "tags": [],
                "shortcode": "JAVA-P0065",
                "shortDescription": "This code explicitly invokes garbage collection via `System.gc()` or `Runtime.gc()`. Except for specific use in benchmarking, this is very dubious.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6YndwbGFu",
                "description": "This code explicitly invokes garbage collection via `System.gc()` or `Runtime.gc()`. Except for specific use in benchmarking, this is very dubious.\n\n<!--more-->\n\nThe JVM may choose to freeze the entire application to perform GC, may completely ignore the invocation (if the `-XX:DisableExplicitGC` flag is set for the VM for example) or defer GC for later. Also, it is impossible to say how the garbage collection will take place since there are many factors which affect GC behavior.\n\nBecause its behavior is so variable, it cannot be relied on to reduce memory consumption and can in fact actively kill performance instead.\n\n### Bad Practice\n\n```java\nSystem.gc();\n\n// Or\n\nRuntime.getRuntime().gc();\n```\n\n### Recommended\n\nAvoid calling `System.gc()`. Instead, consider profiling your application to find the underlying cause of any memory issues that force you to use it.\n\nProfiling your application can provide useful insights into such issues and can help in understanding areas where and how memory usage could be improved.\n\n## References\n- Spotbugs - [DM\\_GC](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#dm-explicit-garbage-collection-extremely-dubious-except-in-benchmarking-code-dm-gc)\n- Stackoverflow - [Why is calling `System.gc` bad?](https://stackoverflow.com/questions/2414105/why-is-it-bad-practice-to-call-system-gc)\n- Stackoverflow - [How to profile memory in java](https://stackoverflow.com/questions/10108942/how-to-memory-profile-in-java)",
                "category": "PERFORMANCE",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "`setUp` and `tearDown` methods must be properly annotated",
                "tags": [],
                "shortcode": "JAVA-E1028",
                "shortDescription": "JUnit 3 introduced the `setUp` and `tearDown` methods as part of the `TestCase` API. These methods allow tests to perform operations before and after a test has run.\n\nHowever, they cannot be directly used in JUnit 4 and 5; they must be marked with specific annotations to preserve their functionality.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6YnJnamFv",
                "description": "JUnit 3 introduced the `setUp` and `tearDown` methods as part of the `TestCase` API. These methods allow tests to perform operations before and after a test has run.\n\nHowever, they cannot be directly used in JUnit 4 and 5; they must be marked with specific annotations to preserve their functionality.\n\n<!--more-->\n\nWhen migrating from JUnit3 to JUnit4,  the [`@Before`](https://junit.org/junit4/javadoc/latest/org/junit/Before.html) and [`@After`](https://junit.org/junit4/javadoc/latest/org/junit/After.html) annotations, or the [`@BeforeClass`](https://junit.org/junit4/javadoc/latest/org/junit/BeforeClass.html) and [`@AfterClass`](https://junit.org/junit4/javadoc/latest/org/junit/AfterClass.html) annotations must be used.\n\nWhen migrating to JUnit5, the [`@BeforeEach`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/BeforeEach.html) and [`@AfterEach`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/AfterEach.html) annotations, or the [`@BeforeAll`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/BeforeAll.html) and [`@AfterAll`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/AfterAll.html) annotations must be used.\n\n### Bad Practice\n\n```java\npublic void setUp() { // Needs an annotation now...\n    // ...\n}\n\n// Needs to be annotated.\npublic void tearDown() {\n    // ...\n}\n```\n\n### Recommended\n\nFor JUnit4:\n```java\n@Before\npublic void setUp() {\n    // ...\n}\n\n@After\npublic void tearDown() {\n    // ...\n}\n```\n\nFor JUnit5:\n```java\n@BeforeEach\npublic void setUp() {\n    // ...\n}\n```\n\n## References\n\n- JUnit4 - [Annotations](https://junit.org/junit4/javadoc/latest/org/junit/package-summary.html)\n- JUnit5 - [Annotations](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/package-summary.html)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Boxed Boolean values should not be used in conditional expressions",
                "tags": [],
                "shortcode": "JAVA-E1054",
                "shortDescription": "A boxed boolean value (`java.lang.Boolean`) is being used in a potentially dangerous manner. Such usage may lead to a `NullPointerException` being thrown.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YmRscGt3",
                "description": "A boxed boolean value (`java.lang.Boolean`) is being used in a potentially dangerous manner. Such usage may lead to a `NullPointerException` being thrown.\n\n<!--more-->\n\nJava's primitive types differ from normal classes in that primitives can never be null. However, classes *can* be null, even primitive wrapper classes such as `Boolean` or `Character`. For `Boolean` in particular, this means that turning a `boolean` into a `Boolean` promotes it from a binary `true` or `false` to a ternary `true`, `false` or `null`. This may be undesirable in most cases, and is worth avoiding.\n\nThe nullability of wrapper types becomes an issue when the wrapper types are used directly in expressions without null checks.\n\n### Bad Practice\n\nIn the example below, the `if` statement evaluates the value of `nullable` when its value is `null`. This will lead to a `NullPointerException` being thrown.\n\n```java\nBoolean nullable = null\n\nif (nullable) { // This would throw a NullPointerException.\n    // ...\n}\n```\n\n### Recommended\n\nYou could perform an explicit comparison with the required value.\n\n```java\nif (nullable == true) {\n    // ...\n}\n\n// OR\n\nif (Boolean.TRUE.equals(nullable)) {\n    // ...\n}\n```\n\nUsing `Boolean.TRUE` here can prevent an unnecessary unboxing conversion when performing a comparison.",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Switch case without appropriate control flow break",
                "tags": [],
                "shortcode": "JAVA-A1068",
                "shortDescription": "This switch case does not terminate in a `break` or other such control flow statement. This can result in accidental switch case fallthrough, unintentionally executing code.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YmV2cHFw",
                "description": "This switch case does not terminate in a `break` or other such control flow statement. This can result in accidental switch case fallthrough, unintentionally executing code.\n\n<!--more-->\n\n### Bad Practice\n\n```java\nswitch (something) {\n    case 1: {\n        // Do something...\n        // No break statement...\n    case 2:\n        // do something else...\n        break;\n    default:\n        // Default behavior.\n}\n```\n\n### Recommended\n\nAdd a break statement at the end of each case unless the fallthrough behavior is intentional.\n\n```java\nswitch (something) {\n    case 1: {\n        // Do something...\n        break;\n    case 2:\n        // do something else...\n        break;\n    default:\n        // Default behavior.\n}\n```\n\n## Exceptions\n\nThis issue can be safely ignored if the fallthrough behavior was intentional.",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Classes should not have the same name as any of their superclasses or implemented interfaces",
                "tags": [],
                "shortcode": "JAVA-E0169",
                "shortDescription": "This class/interface has a name that is identical to that of an implemented/extended class or interface, except that the supertype is in a different package (e.g., `alpha.Foo` extends `beta.Foo`).",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6enFkanlu",
                "description": "This class/interface has a name that is identical to that of an implemented/extended class or interface, except that the supertype is in a different package (e.g., `alpha.Foo` extends `beta.Foo`).\n\n<!--more-->\n\n\n\nConsider the following 3 classes:\n\n```java\npackage com.example.A;\n\npublic class Foo {\n\n    // ...\n\n}\n\n// different file, different package\n\npackage com.example.B;\n\nimport com.example.A.Foo;\n\npublic class Bar extends Foo {\n\n    // ...\n\n}\n\n// different file, same package as Bar\n\npackage com.example.B;\n\npublic class Foo extends Bar {\n\n    // ...\n\n}\n```\n\nThe example given above is perfectly legal, albeit potentially confusing. Because the two classes named `Foo` are separated by the package hierarchy, no name clashes occur. However, any reader who does not already know this codebase could be confused as to where a class, method or field came from.\n\nThis could lead to accidental overloading of a method due to lack of knowledge.\n\nAvoid giving multiple classes the same name, even across packages.\n\n## References\n\n- Spotbugs - [NM\\_SAME\\_SIMPLE\\_NAME\\_AS\\_INTERFACE](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#nm-class-names-shouldn-t-shadow-simple-name-of-implemented-interface-nm-same-simple-name-as-interface)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "For loop appears to check one variable and increment another",
                "tags": [],
                "shortcode": "JAVA-E0214",
                "shortDescription": "There is a complicated, subtle or wrong increment in this `for` loop. It appears that the variable being checked in the loop's condition is not the same as the one being updated.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6Ym5qanBk",
                "description": "There is a complicated, subtle or wrong increment in this `for` loop. It appears that the variable being checked in the loop's condition is not the same as the one being updated.\n\n<!--more-->\n\nThis issue is usually caused by a typo. Always be mindful of the loop variable being checked or updated, especially in nested loops.\n\n### Bad Practice\n\n```java\nfor (int i = 0; i < 20; i++) {\n    for (int j = i; j < 20; i++) { // i is updated, not j.\n        // ...\n    }\n}\n```\n\nIn most cases, this will result in an infinite loop.\n\n### Recommended\n\nEnsure that the variable which is checked in the condition is what is also updated.\n\n```java\nfor (int i = 0; i < 20; i++) {\n    for (int j = i; j < 20; j++) { // j is updated now, as it should be.\n        // ...\n    }\n}\n```\n\n## Exceptions\n\nSometimes, the variable may be updated in a more non-obvious way. In such cases, it is safe to ignore this issue as long as you can verify that the variable is truly updated properly.\n\nIf this is intended, make sure to document the behavior if what is going on isn't easily obvious.\n\n## References\n- Spotbugs - [QF\\_QUESTIONABLE\\_FOR\\_LOOP](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#qf-complicated,-subtle-or-wrong-increment-in-for-loop-qf-questionable-for-loop)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Shift amounts outside the valid range may produce unexpected results",
                "tags": [],
                "shortcode": "JAVA-E0399",
                "shortDescription": "The code performs a shift of an `int` or `long` by a constant amount outside the acceptable range. This could potentially cause overflow or other similar errors and is at best very confusing.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ymd4eGt5",
                "description": "The code performs a shift of an `int` or `long` by a constant amount outside the acceptable range. This could potentially cause overflow or other similar errors and is at best very confusing.\n\n<!--more-->\n\nThe Java Language Specification, Section [15.19](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.19) has the following to say on this matter:\n\n> If the promoted type of the left-hand operand is int, then only the five lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator `&` ([§15.22.1](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1)) with the mask value `0x1f` (`0b11111`). The shift distance actually used is therefore always in the range `0` to `31`, inclusive.\n>\n> If the promoted type of the left-hand operand is long, then only the six lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator `&` ([§15.22.1](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1)) with the mask value `0x3f` (`0b111111`). The shift distance actually used is therefore always in the range `0` to `63`, inclusive.\n\n### Bad Practice\n\nConsider the following shift operations on the `int` value `a`, and the `long` value `b`.\n\n```java\nint a = 2;\n\na << 40 == a << 8 // true, 40 % 32 = 8\n\na << 32 == a // true, 32 % 32 = 0\n\nlong b = 2;\n\nb << 72 == b << 8 // true, 72 % 64 = 8\n\nb << 64 == b // true, 64 % 64 = 0\n```\n\n### Recommended\n\nThe absolute shift amounts for `int` and `long` values must always be one less than the number of bits in their representation. That is, 64-bit values can only have shift amounts in the range [-63, 63] while 32-bit values can only have shift amounts in the range of [-31, 31].\n\n## References\n\n- SpotBugs - [ICAST\\_BAD\\_SHIFT\\_AMOUNT](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#bshift-32-bit-int-shifted-by-an-amount-not-in-the-range--31-31-icast-bad-shift-amount)\n- Java SE 11 [JLS Section 15.19](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.19) - Shift Operators",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Wrong argument type for Collection remove method",
                "tags": [],
                "shortcode": "JAVA-E1036",
                "shortDescription": "Arguments to collection `remove*` methods must be of the same type as the collection itself.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6emRsb2ty",
                "description": "Arguments to collection `remove*` methods must be of the same type as the collection itself.\n\n<!--more-->\n\nThough `Collection` is parameterised on the type of the contained values, [`Collection.remove()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#remove(java.lang.Object)) is not; it accepts a parameter of type `Object` instead. This means any value can be passed to a collection's `remove()` method, regardless of whether the value's type matches the collection's type.\n\nThis is also exacerbated for lists that store integers; `List` has both an `Object` and an `int` overload for `remove()` that are easy to confuse.\n\n### Bad Practice\n\n```java\nList<Integer> ints = Arrays.asList(3);\n\nints.remove(\"3\"); // this will fail silently!\n```\n\n### Recommended\n\nEnsure that the type of the value passed to `remove()` is the same as the collection's type.\n\n```java\nints.remove((Object)3);\n```\n\n## References\n- Oracle Java 11 JavaDocs - [`java.util.Collection`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Public fields should not be synchronized on",
                "tags": [
                  "cwe-412"
                ],
                "shortcode": "JAVA-E1061",
                "shortDescription": "This code uses a public value as the monitor in a `synchronized` block.\n\nPublic values can be accessed from anywhere, and if some other code synchronizes on, or changes the value of such a public field, the chance of multithreading errors such as deadlocks and race conditions occurring is high.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6emFseG9x",
                "description": "This code uses a public value as the monitor in a `synchronized` block.\n\nPublic values can be accessed from anywhere, and if some other code synchronizes on, or changes the value of such a public field, the chance of multithreading errors such as deadlocks and race conditions occurring is high.\n\n<!--more-->\n\n### Bad Practice\n\n```java\npublic Object somePublicObject;\n\n// ... Elsewhere\n\nsynchronized (somePublicObject) {\n    // ...\n}\n```\n\n### Recommended\n\nUse a private value which cannot easily be accessed externally instead.\n\n```java\nprivate Object somePrivateObject;\n\n\nsynchronized(somePrivateObject) {\n    // ...\n}\n```\n\n## References\n\n- [CWE-412](https://cwe.mitre.org/data/definitions/412.html) - Unrestricted Externally Accessible Lock",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Private field is never initialized",
                "tags": [],
                "shortcode": "JAVA-E1065",
                "shortDescription": "This private field is never initialized before use. This may cause improper behavior at runtime, or even a `NullPointerException`.\n\n\nCheck if the logic that uses the field is correct; add an initializer to the declaration or initialize the field at an appropriate point before use.",
                "severity": "CRITICAL",
                "isRecommended": true,
                "id": "SXNzdWU6YnFkd2px",
                "description": "This private field is never initialized before use. This may cause improper behavior at runtime, or even a `NullPointerException`.\n\n\nCheck if the logic that uses the field is correct; add an initializer to the declaration or initialize the field at an appropriate point before use.\n\n<!--more-->\n\nIf a field is not explicitly initialized, Java will set the value of the field to a default value at runtime. This default value depends on the type:\n\n* For primitives, it is `0` (or the floating point equivalent)\n* For descendants of `Object`, the default value is `null`.\n\nJava does not check if a field is properly initialized in the way it checks local variables, and this can easily prevent one from immediately noticing that something is wrong.\n\n### Bad Practice\n\n```java\n// Never initialized, never assigned a value.\nprivate String internalField;\n\nString someMethod() {\n    someInternalCode(internalField); // `internalField` will be null!\n}\n```\n\n### Recommended\n\nAssign a valid default to the field, or initialize it wherever sensible.\n\n```java\nprivate String internalField = \"defaultValue\";\n\n// ...\n```\n\n## Exceptions\n\nThis issue will not be reported for fields marked as being injected (marked with annotations such as `@Inject` or `@Autowired`).",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "NullPointerException should not be caught",
                "tags": [],
                "shortcode": "JAVA-E1070",
                "shortDescription": "This code appears to catch a `NullPointerException`. This may hide bad errors in code.\n\nConsider removing the offending clause and debugging the underlying cause of the exception instead.",
                "severity": "CRITICAL",
                "isRecommended": true,
                "id": "SXNzdWU6enFkd3Fk",
                "description": "This code appears to catch a `NullPointerException`. This may hide bad errors in code.\n\nConsider removing the offending clause and debugging the underlying cause of the exception instead.\n\n<!--more-->\n\nWhen an NPE is caught solely so it can be silenced, it can indicate that the underlying cause of the exception is not properly known. If an NPE is thrown, it may be that the application is in an inconsistent state which should not be ignored.\n\n### Bad Practice\n\n```java\ntry {\n    // ...\n} catch (NullPointerException n) { // Debug the cause instead!\n    n.printStackTrace();\n}\n```\n\n### Recommended\n\nRemove the catch clause that handles `NullPointerException` and debug the underlying issue instead.\n\n## Exceptions\n\nIf the reason for throwing NPEs is within library code or within code that you have no control over, it may not be possible to easily fix the issue. In such cases, consider ignoring this issue with a `skipcq` comment above the offending line.\n\n```java\n    // skipcq\n    somethingThatThrows();\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Missing enum elements in switch cases",
                "tags": [],
                "shortcode": "JAVA-E1082",
                "shortDescription": "Switch statements that have expression of an enum type and don't have the default label must specify all the enum elements in their cases.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnJnd2pl",
                "description": "Switch statements that have expression of an enum type and don't have the default label must specify all the enum elements in their cases.\n\n<!--more-->\nEven if the current state of the application doesn't require certain enum elements to be considered in switch cases, a patch in the future may\nchange that. When this happens, and the programmer forgets to handle the additional enum elements, this will almost always result\nin a bug in the application. For this reason, it's highly encouraged to cover all the enum fields in cases of a switch statement.\n\n### Bad Practice\n\n```java\nenum Color {\n    RED,\n    BLUE\n}\n\npublic void test() {\n    Color color = getColor();\n    // Bad, missing `Color::BLUE` or `default`.\n    switch (color) {\n        case RED:\n            paintRed();\n            break;\n    }\n}\n```\n\nConsider specifying all the enum elements or specify a `default` case.\n\n### Recommended\n\n```java\nenum Color {\n    RED,\n    BLUE\n}\n\npublic void test() {\n    Color color = getColor();\n    switch (color) {\n        case RED:\n            paintRed();\n            break;\n\n        case BLUE:\n            paintBlue();\n            break;\n    }\n}\n```\n## References\n - StackOverflow - [How to ensure completeness in an enum switch?](https://stackoverflow.com/questions/16797529/how-to-ensure-completeness-in-an-enum-switch-at-compile-time)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Mutable data passed in to nonpublic field may be externally modifiable",
                "tags": [],
                "shortcode": "JAVA-E1086",
                "shortDescription": "This code seems to assign mutable data, such as an `ArrayList`, or a native Java array (like `int[]`) to a non-public\nfield without first copying the data. This may lead to errors caused by inconsistent state if the passed in data is\nlater modified from caller-side code.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enJnd3Zy",
                "description": "This code seems to assign mutable data, such as an `ArrayList`, or a native Java array (like `int[]`) to a non-public\nfield without first copying the data. This may lead to errors caused by inconsistent state if the passed in data is\nlater modified from caller-side code.\n\n<!--more-->\n\nWhen initializing an object, or invoking a setter for a field, it is common practice in Java to perform\na [defensive copy](http://www.javapractices.com/topic/TopicAction.do?Id=15), where a deep copy of the input data is\nfirst made before it is used or assigned to anything else. This helps ensure that any change to the state of the object\nonly happens by way of the object's methods, not by some external operation.\n\n### Bad Practice\n\nConsider this class declaration. It has one setter, `setIpAddrs`, which assigns the value of\n\n```java\nclass SomeClass {\n    private String[] ipAddrs;\n\n    public void setIpAddrs(String[] addrs) {\n        this.ipAddrs = addrs;\n    }\n\n    public void printAddrs() {\n        for (int i = 0; i < ipAddrs.length; i++) {\n            System.out.println(addrs[i]);\n        }\n    }\n}\n\n```\n\nNow, consider this usage of the class:\n\n```java\n\nString[] addrs = new String[] { \"192.168.10.23\", \"10.0.0.123\" };\n\nSomeClass instance = new SomeClass();\n\ninstance.setIpAddrs(addrs); // At this point, we have assigned addrs to ipAddrs.\n```\n\nIf, at this point, we were to invoke `printAddrs()`, we would see this output:\n\n```\n192.168.10.23\n10.0.0.123\n```\n\nNow, consider what would happen if we change the value of one of `addrs`'s elements:\n\n```java\naddrs[1] = \"Some random string\";\n\ninstance.printAddrs();\n```\n\nThis would print the following instead!\n\n```\n192.168.10.23\nSome random string\n```\n\n### Recommended\n\nTo avoid such problems, make a defensive copy of the data first.\n\n```java\nimport java.util.Arrays;\n\nclass SomeClass {\n    private String[] ipAddrs;\n\n    public void setIpAddrs(String[] addrs) {\n        // What we store is now a copy of the original array.\n        this.ipAddrs = Arrays.copyOf(addrs, addrs.length);\n    }\n}\n```\n\nNow, even if the original array were modified, the array stored inside `SomeClass` itself would be preserved.\n\n## References\n\n- javapractices.com - [defensive copies](http://www.javapractices.com/topic/TopicAction.do?Id=15)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Inefficient use of `toArray` with non-zero sized array argument",
                "tags": [],
                "shortcode": "JAVA-P0335",
                "shortDescription": "This method uses `toArray` with a non-zero sized array argument. This is less efficient than passing a zero-sized array.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnJnZHl2",
                "description": "This method uses `toArray` with a non-zero sized array argument. This is less efficient than passing a zero-sized array.\n\n<!--more-->\n\nThis method invokes `toArray` on a `Collection` object, and passes in an array with a size greater than zero as an argument. It used to be that this was faster than providing an array of size zero (`new Type[0]`) in older versions of Java prior to 6. This is because the cost of performing reflection operations was quite high in old Java versions.\n\nThis is no longer the case, and providing a zero sized array is now just as fast (or even faster) than providing an array of the same size as the original collection. It is now generally better to use a zero-length array as the argument to `toArray`.\n\n### Bad Practice\n\n```java\nList<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\nInteger[] arr1 = list.toArray(new Integer[list.size()]); // Inefficient\n\n```\n\n### Recommended\n\n```\nInteger[] arr2 = list.toArray(new Integer[0]);           // Better\n```\n\n## References\n\n- [Arrays of Wisdom of the Ancients](https://shipilev.net/blog/2016/arrays-wisdom-ancients/)\n- PMD - [OptimizableToArrayCall](https://pmd.github.io/latest/pmd_rules_java_performance.html#optimizabletoarraycall)",
                "category": "PERFORMANCE",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Function with cyclomatic complexity higher than threshold found",
                "tags": [],
                "shortcode": "JAVA-R1000",
                "shortDescription": "A function with high cyclomatic complexity can be hard to understand and\nmaintain. Cyclomatic complexity is a software metric that measures the number of\nindependent paths through a function. A higher cyclomatic complexity indicates\nthat the function has more decision points and is more complex.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6emxseWd3",
                "description": "A function with high cyclomatic complexity can be hard to understand and\nmaintain. Cyclomatic complexity is a software metric that measures the number of\nindependent paths through a function. A higher cyclomatic complexity indicates\nthat the function has more decision points and is more complex.\n\n<!--more-->\n\nFunctions with high cyclomatic complexity are more likely to have bugs and be\nharder to test. They may lead to reduced code maintainability and increased\ndevelopment time.\n\nTo reduce the cyclomatic complexity of a function, you can:\n\n- Break the function into smaller, more manageable functions.\n- Refactor complex logic into separate functions or classes.\n- Avoid multiple return paths and deeply nested control expressions.\n\n### Bad practice\n\nThe method below (from the source code of the Maven build system, non-branch lines have been abbreviated)\nhas a complexity of 25, and should be refactored if possible.\n\n```java\n    public VersionResult resolveVersion(RepositorySystemSession session, VersionRequest request) // 1\n            throws VersionResolutionException {\n        // ...\n\n        if (cache != null && !ConfigUtils.getBoolean(session, false, \"aether.versionResolver.noCache\")) { // +2\n            // ...\n            if (obj instanceof Record) { // +1\n\n            }\n        }\n\n        Metadata metadata = null;\n\n        // This section could be refactored, as all operations here are independent of external control flow.\n        if (RELEASE.equals(version)) { // +1\n            metadata = new DefaultMetadata(\n                    artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML, Metadata.Nature.RELEASE);\n        } else if (LATEST.equals(version)) { // +1\n            metadata = new DefaultMetadata(\n                    artifact.getGroupId(),\n                    artifact.getArtifactId(),\n                    MAVEN_METADATA_XML,\n                    Metadata.Nature.RELEASE_OR_SNAPSHOT);\n        } else if (version.endsWith(SNAPSHOT)) { // +1\n            WorkspaceReader workspace = session.getWorkspaceReader();\n            if (workspace != null && workspace.findVersions(artifact).contains(version)) { // +2\n                metadata = null;\n                result.setRepository(workspace.getRepository());\n            } else {\n                metadata = new DefaultMetadata(\n                        artifact.getGroupId(),\n                        artifact.getArtifactId(),\n                        version,\n                        MAVEN_METADATA_XML,\n                        Metadata.Nature.SNAPSHOT);\n            }\n        } else {\n            metadata = null;\n        }\n\n        if (metadata == null) { // +1\n            result.setVersion(version);\n        } else {\n            // ...\n            for (RemoteRepository repository : request.getRepositories()) { // +1\n                // ...\n            }\n\n            // ...\n\n            for (MetadataResult metadataResult : metadataResults) { // +1\n                // ...\n                if (repository == null) { // +1\n                    // ...\n                }\n\n                Versioning v = readVersions(session, trace, metadataResult.getMetadata(), repository, result);\n                merge(artifact, infos, v, repository);\n            }\n\n            // This section could also be extracted for the same reasons.\n            if (RELEASE.equals(version)) { // +1\n                resolve(result, infos, RELEASE);\n            } else if (LATEST.equals(version)) { // +1\n                if (!resolve(result, infos, LATEST)) { // +1\n                    resolve(result, infos, RELEASE);\n                }\n\n                if (result.getVersion() != null && result.getVersion().endsWith(SNAPSHOT)) { // +2\n                    VersionRequest subRequest = new VersionRequest();\n                    subRequest.setArtifact(artifact.setVersion(result.getVersion()));\n                    if (result.getRepository() instanceof RemoteRepository) { // +1\n                        RemoteRepository r = (RemoteRepository) result.getRepository();\n                        subRequest.setRepositories(Collections.singletonList(r));\n                    } else {\n                        subRequest.setRepositories(request.getRepositories());\n                    }\n                    VersionResult subResult = resolveVersion(session, subRequest);\n                    result.setVersion(subResult.getVersion());\n                    result.setRepository(subResult.getRepository());\n                    for (Exception exception : subResult.getExceptions()) { // +1\n                        result.addException(exception);\n                    }\n                }\n            } else {\n                String key = SNAPSHOT + getKey(artifact.getClassifier(), artifact.getExtension());\n                merge(infos, SNAPSHOT, key);\n                if (!resolve(result, infos, key)) { // +1\n                    result.setVersion(version);\n                }\n            }\n\n            if (StringUtils.isEmpty(result.getVersion())) { // +1\n                throw new VersionResolutionException(result);\n            }\n        }\n\n        if (cacheKey != null && metadata != null && isSafelyCacheable(session, artifact)) { // +3\n            cache.put(session, cacheKey, new Record(result.getVersion(), result.getRepository()));\n        }\n\n        return result;\n    }\n\n```\n\n### Recommended\n\nIt is best to refactor the method into multiple separate methods, so that the complexity of individual methods is reduced.\n\n\nHere, after extracting the parts of the code highlighted above, the complexity is reduced to `12`, and shifted into two other methods instead.\n\n```java\npublic VersionResult resolveVersion(RepositorySystemSession session, VersionRequest request) // 1\n        throws VersionResolutionException {\n    // ...\n\n    if (cache != null && !ConfigUtils.getBoolean(session, false, \"aether.versionResolver.noCache\")) { // +2\n        // ...\n        if (obj instanceof Record) { // +1\n            // ...\n        }\n    }\n\n    Metadata metadata = getMetadataForVersion(session, version, artifact, result);\n\n    if (metadata == null) { // +1\n        // ...\n    } else {\n        // ...\n        for (RemoteRepository repository : request.getRepositories()) { // +1\n            // ...\n        }\n\n        // ...\n\n        for (MetadataResult metadataResult : metadataResults) { // +1\n            // ...\n            if (repository == null) { // +1\n                // ...\n            }\n            // ...\n        }\n\n        resolveBasedOnVersion(session, request, version, result, infos, artifact);\n\n        if (StringUtils.isEmpty(result.getVersion())) { // +1\n            throw new VersionResolutionException(result);\n        }\n    }\n\n    if (cacheKey != null && metadata != null && isSafelyCacheable(session, artifact)) { // +3\n        cache.put(session, cacheKey, new Record(result.getVersion(), result.getRepository()));\n    }\n\n    return result;\n}\n\nprivate void resolveBasedOnVersion(RepositorySystemSession session, VersionRequest request, String version, VersionResult result, Map<String, VersionInfo> infos, Artifact artifact) throws VersionResolutionException {\n    if (RELEASE.equals(version)) { // +1\n        resolve(result, infos, RELEASE);\n    } else if (LATEST.equals(version)) { // +1\n        if (!resolve(result, infos, LATEST)) { // +1\n            resolve(result, infos, RELEASE);\n        }\n\n        if (result.getVersion() != null && result.getVersion().endsWith(SNAPSHOT)) { // +2\n            // ...\n            if (result.getRepository() instanceof RemoteRepository) { // +1\n                // ...\n            } else {\n                // ...\n            }\n            // ...\n            for (Exception exception : subResult.getExceptions()) { // +1\n                result.addException(exception);\n            }\n        }\n    } else {\n        // ...\n        if (!resolve(result, infos, key)) { // +1\n            result.setVersion(version);\n        }\n    }\n}\n\n@Nullable\nprivate static Metadata getMetadataForVersion(RepositorySystemSession session, String version, Artifact artifact, VersionResult result) {\n    if (RELEASE.equals(version)) { // +1\n        // ...\n    } else if (LATEST.equals(version)) { // +1\n        // ...\n    } else if (version.endsWith(SNAPSHOT)) { // +1\n        WorkspaceReader workspace = session.getWorkspaceReader();\n        if (workspace != null && workspace.findVersions(artifact).contains(version)) { // +2\n            // ...\n        } else {\n            // ...\n        }\n    } else {\n        metadata = null;\n    }\n    return metadata;\n}\n```\n\n### Issue configuration\n\nCyclomatic complexity threshold can be configured using the\n`cyclomatic_complexity_threshold` [meta field](https://docs.deepsource.com/docs/analyzers-java#cyclomatic_complexity_threshold) in your repository's\n`.deepsource.toml` config file.\n\nConfiguring this is optional. If you don't provide a value, the Analyzer will\nraise issues for functions with complexity higher than the default threshold,\nwhich is \"medium\" (which raises issues for complexity > `15`) for the Java Analyzer.\n\nHere's a mapping of risk category to cyclomatic complexity score to\nhelp you configure this better:\n\n| Risk category | Cyclomatic complexity range |                                                Recommended action                                                |\n|:-------------:|:---------------------------:|:----------------------------------------------------------------------------------------------------------------:|\n| low           | 1-5                         |                                                No action needed.                                                 |\n| medium        | 6-15                        |                                               Review and monitor.                                                |\n| high          | 16-25                       | Review and refactor. It is recommended to add explanatory comments if the function absolutely cannot be changed. |\n| very-high     | 26-50                       |                                        Refactor to reduce the complexity.                                        |\n| critical      | >50                         |           The function must be refactored. Such high complexity can harm testability and readability.            |",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Mutable fields should not directly be returned",
                "tags": [],
                "shortcode": "JAVA-S1049",
                "shortDescription": "A mutable field (which is either an array type or a class with public non-final fields) is returned directly (without being copied). This could result in the internal state of your API being exposed, or worse, open to manipulation.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6YnFkd3Zl",
                "description": "A mutable field (which is either an array type or a class with public non-final fields) is returned directly (without being copied). This could result in the internal state of your API being exposed, or worse, open to manipulation.\n\n<!--more-->\n\nThe side effects of modifying the returned data can range from unexplainable crashes to data theft or injection attacks.\n\n### Bad Practice\n\n```java\nclass FilteredOperationPerformer {\n    private final String[] blacklist = new String[] { \"a\", \"b\", \"c\" };\n\n    String[] getBlacklist() {\n        return blacklist; // Bad!\n    }\n\n    // ...\n}\n\n// Elsewhere...\n\nFilteredOperationPerformer fop = new FilteredOperationPerformer();\n\nString[] blacklistExternal = fop.getBlacklist();\n\nblacklistExternal[0] = \"Something else\";\n\nSystem.out.println(\"External blacklist entries are:\");\nfor (String s : blacklistExternal) {\n    System.out.println(s);\n}\n\nSystem.out.println(\"\nInternal blacklist entries are:\");\nfor (String s : fop.getBlacklist()) {\n    System.out.println(s);\n}\n```\n\nThe output of this code looks like this:\n\n```\nExternal blacklist entries are:\nSomething else\nb\nc\n\nInternal blacklist entries are:\nSomething else                  <---- !!!\nb\nc\n```\n\nWhile the expectation may be that the internal `blacklist` value would not be affected by a change in an external value, it is still affected. This is because the reference returned by `getBlacklist()` points to the same `String[]` object as the inner `blacklist` value.\n\n### Recommended\n\nUse the `Arrays.copyOf()` method to make a copy of an array when returning it.\n\n```java\nString[] getBlacklist() {\n    return Arrays.copyOf(blacklist);\n}\n```\n\nIf you need to expose a field of a mutable type, either create a new object and copy over the data and return the copied object, or consider adding a copy method to the mutable type which would create a new copy.\n\n```java\n\nSomeMutableClass getInternalData() {\n\n    // Here, a copy constructor has been defined\n    // for the `SomeMutableClass` type which will\n    // properly copy over all fields of the object.\n    return new SomeMutableClass(internalData);\n}\n\n```\n\nDeep copies in Java are not very well supported and generally rely on tricks like [abuse of the serialization API or using external libraries](https://stackoverflow.com/questions/64036/how-do-you-make-a-deep-copy-of-an-object) to clone objects. Whatever method you choose, be aware of the risks and pitfalls of performing a clone operation on an object.\n\n## References\n- Oracle Java 11 JavaDocs - [`java.util.Arrays.copyOf(T[], int)`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#copyOf(T%5B%5D,int))",
                "category": "SECURITY",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Non-final static fields should not be public",
                "tags": [],
                "shortcode": "JAVA-S1050",
                "shortDescription": "This code contains a public static field which is not final, or is mutable even when declared as final.\n\nConsider making the field private, as it is possible that such a field could be manipulated to produce unintended results.",
                "severity": "CRITICAL",
                "isRecommended": true,
                "id": "SXNzdWU6Ynhqa3B4",
                "description": "This code contains a public static field which is not final, or is mutable even when declared as final.\n\nConsider making the field private, as it is possible that such a field could be manipulated to produce unintended results.\n<!--more-->\n\n### Bad Practice\n\nHere, the `NUM_RETRIES` field could be manipulated to perform a Denial of Service (DoS) attack when set to some very high number.\n\n```java\nclass SomeClass {\n\n    public static int NUM_RETRIES = 3;\n\n}\n\n// Elsewhere...\n\nSomeClass someObj = ...;\nSomeClass.NUM_RETRIES = Integer.MAX_VALUE; // This could make an application hang!\n```\n\n### Recommended\n\nThere are multiple ways to avoid this, and you must choose the best method as per your requirements.\n\n**Make the field final**\n\nIf you do not need the field to be mutable, consider just making it final:\n\n```java\npublic static final int NUM_RETRIES = 3;\n```\n\n**Make the field private**\n\nIf you require the field to be mutable, consider making the field private. If you also need to expose the field to API consumers, consider adding a static or instance getter method for the field:\n\n```java\nprivate static int NUM_RETRIES = 3;\n\n// Static getter\npublic static final int getNumRetries() {\n    return NUM_RETRIES;\n}\n\n// Instance getter, only usable when we have an instance of this class created.\npublic final int getNumRetries() {\n    return NUM_RETRIES;\n}\n```\n\nIf you also need to be able to set the value, make sure to sanitize the assigned data. You could check if the retry value is within a maximum permissible limit (`MAX_NUM_RETRIES`) and if the assigned value is below 0 or above the maximum limit, clamp that value to within those limits.\n\n```java\npublic static final void setNumRetries(int retries) {\n    // clamp retries to within the range 0 to MAX_NUM_RETRIES.\n    retries = (retries > MAX_NUM_RETRIES) ? MAX_NUM_RETRIES : ((retries < 0) ? 0 : retries);\n\n    NUM_RETRIES = retries;\n}\n```",
                "category": "SECURITY",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Use of identifier that is a keyword in later Java versions",
                "tags": [],
                "shortcode": "JAVA-W0050",
                "shortDescription": "This identifier is reserved as a keyword in later versions of Java. If/when this code is migrated to a newer Java version, it will not compile unless the identifier is renamed.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6YmtnZ2Fu",
                "description": "This identifier is reserved as a keyword in later versions of Java. If/when this code is migrated to a newer Java version, it will not compile unless the identifier is renamed.\n\n<!--more-->\n\nKeywords such as `enum`, `var` or `assert` were not always keywords. Older code that uses them as identifiers may break when ported to newer Java versions. \n\nThe following tokens used to be treated as identifiers but are now treated as keywords:\n\n- `strictfp` - Since Java 1.2. Used to make floating point operations more portable across all Java platforms. \n- `assert` - Since Java 1.4\n- `enum` - Since Java 1.5\n\nThe tokens listed below on the other hand are \"restricted\", and only behave as keywords in certain contexts. Though it is still possible to use them as identifiers, the Java analyzer will raise warnings for such usages, as they could confuse readers of this code in the future.\n\n- `yield` - Since Java 13. Allows the return value of `switch` blocks to be assigned to a variable. \n- `record` - Since Java 14. Used to declare record classes.\n- `var` - Since Java 10. Used to declare local variables. The type of the value is inferred.\n- `sealed` - Since Java 15. Marks an interface as being implemented by a restricted set of classes.\n- `permits` - Since Java 15. Used to specify the set of classes/interfaces which can directly implement/extend a particular sealed interface.\n\n## References\n\n- [Wikipedia article](https://en.wikipedia.org/wiki/List_of_Java_keywords) on Java keywords\n- Spotbugs - [NM\\_FUTURE\\_KEYWORD\\_USED\\_AS\\_MEMBER\\_IDENTIFIER](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#nm-use-of-identifier-that-is-a-keyword-in-later-versions-of-java-nm-future-keyword-used-as-member-identifier)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Class doesn't override `equals` from superclass",
                "tags": [],
                "shortcode": "JAVA-W0100",
                "shortDescription": "This class extends a class that defines `equals` and adds fields, but doesn't define `equals` itself. Thus, equality on instances of this class will ignore its identity and its added fields.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6emRscXlh",
                "description": "This class extends a class that defines `equals` and adds fields, but doesn't define `equals` itself. Thus, equality on instances of this class will ignore its identity and its added fields.\n\n<!--more-->\n\n### Bad Practice\n```java\n\nclass Parent {\n\n  int field1 = 3;\n\n  @Override\n  public boolean equals(Object other) {\n    if (other is Parent && field1 == (Parent)other.field1)\n      // ...\n  }\n}\n\nclass Child extends Parent {\n  int field2 = 5;\n}\n\n```\n\nHere, comparison of `Child` objects will use the `equals` method implemented in `Parent`.\n\nBe sure this is what is intended, and that you don't need to override the `equals` method. Even if you don't need to override the `equals` method, consider overriding it anyway to document the fact that equality for the subclass works the same way as equality for the superclass.\n\n### Recommended\n\nOverride the equals method in the child class even if you intend the current behavior; it will make the decision not to include the extra field in the equality condition explicit.\n```java\n\nclass Child extends Parent {\n  int field2 = 5;\n\n  @Override\n  public boolean equals(Object other) {\n    return super.equals(other);\n  }\n}\n\n```\n\n## References\n- Spotbugs - [EQ\\_DOESNT\\_OVERRIDE\\_EQUALS](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#eq-class-doesn-t-override-equals-in-superclass-eq-doesnt-override-equals)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Clone method does not invoke super method",
                "tags": [],
                "shortcode": "JAVA-E0048",
                "shortDescription": "Non-final class defines a `clone` method that does not call `super.clone`.",
                "severity": "CRITICAL",
                "isRecommended": false,
                "id": "SXNzdWU6enJnZ3B4",
                "description": "Non-final class defines a `clone` method that does not call `super.clone`.\n\n<!--more-->\n\n### Bad Practice\n```java\nclass T implements Cloneable {\n\n    @Override\n    public Object clone() {\n        // Does not call super.clone();\n\n        T newObj = new T(...);\n\n        // ...\n\n        return newObj;\n    }\n\n}\n\n// ...\n\nclass U extends T implements Cloneable {\n\n    @Override\n    public Object clone() {\n        U newObj = (U)super.clone(); // This is an object of type T! This cast will fail with a ClassCastException.\n        // ...\n\n        return newObj;\n    }\n}\n```\n\nIf `T` is extended by a subclass `U`, and `U` calls `super.clone`, then it is likely that `U`'s `clone` method will get an object of type `T`. This will likely fail within the clone method itself when the subclass modifies data. Such code violates the standard contract for `clone` as stated by the [JavaDocs](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#clone()):\n\n> By convention, the returned object should be obtained by calling `super.clone`. If a class and all of its superclasses (except `Object`) obey this convention, it will be the case that `x.clone().getClass() == x.getClass()`.\n\n### Recommended\n\nAlways make sure to call `super.clone` when implementing `Cloneable` for any class.\n\n```java\nclass T implements Cloneable {\n    @Override\n    public Object clone() {\n        try {\n            T newObj = super.clone();\n\n            // ...\n\n            return newObj;\n        } catch (CloneNotSupportedException e) {\n            // ...\n        }\n    }\n}\n```\n\n## References\n\n- Spotbugs - [CN\\_IDIOM\\_NO\\_SUPER\\_CALL](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#cn-clone-method-does-not-call-super-clone-cn-idiom-no-super-call)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Non-static nested class found",
                "tags": [],
                "shortcode": "JAVA-W1019",
                "shortDescription": "This nested class is declared without a `static` modifier, meaning all instances of the class will hold a reference to an instance of the enclosing class.\n\nThe Java analyzer has detected that there are no explicit references to the enclosing class here, meaning this nested class can be safely treated as static.\n\nConsider adding a `static` modifier to the nested class.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6em5qb2xq",
                "description": "This nested class is declared without a `static` modifier, meaning all instances of the class will hold a reference to an instance of the enclosing class.\n\nThe Java analyzer has detected that there are no explicit references to the enclosing class here, meaning this nested class can be safely treated as static.\n\nConsider adding a `static` modifier to the nested class.\n\n<!--more-->\n\nNon-static nested classes are generally known as \"inner\" classes.\n\n### Bad Practice\n\n```java\nclass Outer {\n\n    class Inner {\n        // ...\n    }\n\n    // ...\n}\n```\n\nThere are a number of things one should be aware of when using inner classes:\n* An instance of `Inner` will contain a reference to an instance of `Outer`.\n    * If the `Inner` instance continues to exist after all other references to the `Outer` instance are deleted, the `Outer` instance will still exist because of the reference held by the still-alive `Inner` class.\n* The syntax for instantiating a nested class is relatively obscure, and may confuse future code maintainers.\n* Referring to private fields of the enclosing class from the nested class requires Java to generate synthetic accessor methods for that sole purpose, bloating the class's bytecode.\n\n### Recommended\n\nDeclare the nested class as static if possible.\n\n```java\nclass Outer {\n    static class Inner {\n        // ...\n    }\n\n    // ...\n}\n```\n\n## Exceptions\n\nIf the inner class refers to the outer class's instance fields, this issue will not be reported.\n\n## References\n\n- Oracle Java Tutorials - [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)\n- Oracle Java 11 Language Specification - Section [8.1.3](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3) - Inner Classes and Enclosing Instances",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "`Iterable` objects must not return `this` in `iterator()` method",
                "tags": [],
                "shortcode": "JAVA-E1015",
                "shortDescription": "Do not return `this` in the `iterator()` method of a type that implements `java.lang.Iterable<T>`.  <!-more-->",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6em1sam1l",
                "description": "Do not return `this` in the `iterator()` method of a type that implements `java.lang.Iterable<T>`.\n\n<!-more-->\n\n`java.lang.Iterable<T>` represents a collection of values which can be iterated over. It can be iterated over any number of times.\n\n`java.util.Iterator<T>` represents a stateful \"cursor\" over an iterable collection. It can only be iterated over once.\n\nIf you need to attach an [`Iterator`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html) API to an `Iterable` structure, one way to do so would be to have the type implement both `Iterable` and `Iterator`, and return `this` in the [`iterator()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html#iterator()) method:\n\n```java\n/// This type implements both Iterator and Iterable.\npublic class SomeCollection implements Iterator<T>, Iterable<T> {\n\n    private T[] inner = ...;\n    private int idx = 0;\n\n    // Iterable.iterator() implementation\n    @Override\n    public Iterator<T> iterator() {\n        return this;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return idx < inner.length;\n    }\n\n    @Override\n    public T next() {\n        return inner[idx++];\n    }\n\n    // ...\n}\n```\n\nIt is a bad idea to do this however; getting an iterator from `SomeCollection.iterator()` will likely only work once. Consider what would happen when an instance of `SomeCollection` is iterated over more than once:\n\n```java\nSomeCollection si = new SomeCollection();\n\nfor (T i : si) {\n    // ...\n}\n\n// This loop never executes!\nfor (T j : si) {\n    // ...\n}\n\n```\n\nThe second loop will never execute! This is because once the first loop finishes, the internal index variable `idx` is equal to the length of the internal array `inner`. The `hasNext()` method will always return `false` and thus the second loop will never execute.\n\nIn certain cases such behavior is desirable: consider [`java.nio.file.DirectoryStream`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/DirectoryStream.html). `DirectoryStream` is an `Iterable` over file paths that is intended to only be traversed once. It does so by ensuring that the `iterator()` method will always throw an exception after it is first called.\n\n```java\nDirectoryStream<Path> ds = Files.newDirectoryStream(somePath);\n\nfor (Path entry : ds) {\n    // ...\n}\n\n// An IllegalStateException will be thrown here.\nfor (Path reEntry : ds) {\n    // ...\n}\n\nds.close();\n```\n\nAlways return a fresh `Iterator` instance when implementing `Iterable<T>.iterator()`.\n\n### Bad Practice\n\n```java\nclass SomeIterable implements Iterable<SomeElement>, Iterator<SomeElement> {\n    private SomeElement[] internalList = new SomeElement[10];\n    private int idx = 0;\n    private int capacity = 10;\n\n    @Override\n    public boolean hasNext() {\n        return idx < capacity;\n    }\n\n    @Override\n    public SomeElement next() {\n        return internalList[idx++];\n    }\n\n    // Don't return this here!\n    @Override\n    public Iterator<SomeElement> iterator() {\n        return this;\n    }\n\n    // ...\n}\n```\n\n### Recommended\n\nCreate a new `Iterator` instance whenever the `iterator()` method is called. This will prevent state from persisting across invocations of the method.\n\n```java\nclass SomeIterable implements Iterable<SomeElement> {\n  private SomeElement[] internalList;\n\n  public Iterator<SomeElement> iterator() {\n    return new Iterator<SomeElement>() {\n      private idx = 0;\n      public boolean hasNext() {\n        return idx < internalList.length;\n      }\n      public SomeElement next() {\n        return internalList[idx++];\n      }\n    };\n  }\n\n  // ...\n}\n```\n\n## References\n\n- Oracle Java 11 JavaDocs - [java.lang.Iterable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html)\n- Oracle Java 11 JavaDocs - [java.util.Iterator](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Serializable class with non-serializable superclass and no default constructor detected",
                "tags": [],
                "shortcode": "JAVA-E1034",
                "shortDescription": "This serializable class has a non-serializable superclass that does not declare a default constructor. Deserializing such a class will fail with an [`InvalidClassException`](https://docs.oracle.com/javase/8/docs/api/java/io/InvalidClassException.html) because Java will not be able to instantiate it.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enFkd2Vl",
                "description": "This serializable class has a non-serializable superclass that does not declare a default constructor. Deserializing such a class will fail with an [`InvalidClassException`](https://docs.oracle.com/javase/8/docs/api/java/io/InvalidClassException.html) because Java will not be able to instantiate it.\n\n<!--more-->\n\nJava's `Serializable` interface enforces specific requirements on serializable classes that extend a non-serializable class:\n\n> To allow subtypes of non-serializable classes to be serialized, the subtype may assume responsibility for saving and restoring the state of the supertype's public, protected, and (if accessible) package fields. The subtype may assume this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state. It is an error to declare a class `Serializable` if this is not the case. The error will be detected at runtime.\n\nPut simply, given the following conditions:\n\n1. The class implements `Serializable`.\n2. The class extends a non-serializable class.\n3. The superclass does not define a no-argument (default) constructor.\n\nJava will throw an `InvalidClassException` when attempting to deserialize an instance of the class.\n\n### Bad Practice\n\n```java\nclass SuperClass {\n    int x;\n    public SuperClass(int a) {\n        x = a;\n    }\n}\n\n// Java will fail to deserialize this class.\nclass SubClass extends SuperClass implements Serializable {\n    // ...\n}\n```\n\n### Recommended\n\n```java\nclass SuperClass {\n    int x;\n    public SuperClass(int a) {\n        x = a;\n    }\n\n    public SuperClass() {\n        x = 0;\n    }\n}\n\nclass SubClass extends SuperClass implements Serializable {\n    // ...\n}\n```\n\n## References\n\n- Oracle Java 11 JavaDocs - [java.io.Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Class overrides `compareTo()` but not `equals()`",
                "tags": [],
                "shortcode": "JAVA-W1056",
                "shortDescription": "This class implements `Comparable<T>` and overrides `compareTo()`, but it does not override `equals()` so that the implementations of `compareTo` and `equals` are in sync.\n\nThis will cause issues when performing comparison/equality checks, and may cause inconsistent behaviour when collections of this class are sorted.\n\nMake sure to add a corresponding `equals()` implementation which agrees with `compareTo()`.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ymxsa2ty",
                "description": "This class implements `Comparable<T>` and overrides `compareTo()`, but it does not override `equals()` so that the implementations of `compareTo` and `equals` are in sync.\n\nThis will cause issues when performing comparison/equality checks, and may cause inconsistent behaviour when collections of this class are sorted.\n\nMake sure to add a corresponding `equals()` implementation which agrees with `compareTo()`.\n\n<!--more-->\n\nThis class defines a `compareTo(...)` method but inherits its `equals()` method from `java.lang.Object`. Generally, the value of `compareTo()` should return zero if and only if `equals()` returns true.\n\nFrom the JavaDoc for [`Comparable<T>.compareTo()`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Comparable.html#compareTo(T)):\n\n> It is strongly recommended, but not strictly required that `(x.compareTo(y)==0) == (x.equals(y))`. Generally speaking, any class that implements the `Comparable` interface and violates this condition should clearly indicate this fact. The recommended language is:\n>> Note: this class has a natural ordering that is inconsistent with `equals`.\n\n### Bad Practice\n\n```java\nclass OnlyCompareTo implements Comparable<OnlyCompareTo> {\n    int field1 = 0;\n\n    @Override\n    int compareTo(OnlyCompareTo other) {\n        if (other == null) return 1;\n        return Integer.compare(field1, other.field1);\n    }\n}\n```\n\n### Recommended\n\nConsider implementing an `equals` method that matches the behavior of the defined `compareTo` method.\n\n```java\n\nclass CompareToAndEquals implements Comparable<CompareToAndEquals> {\n    int field1 = 0;\n\n    @Override\n    int compareTo(CompareToAndEquals other) {\n        if (other == null) return 1;\n        return Integer.compare(field1, other.field1);\n    }\n\n    @Override\n    boolean equals(Object other) {\n        return this == other || (other != null && other.field1 == this.field1);\n    }\n}\n```",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Lines not covered in tests",
                "tags": [],
                "shortcode": "TCV-001",
                "shortDescription": "A source line is considered covered when at least one instruction that is assigned to this line has been executed by a test case. These lines were not executed during any of the test cases.",
                "severity": "CRITICAL",
                "isRecommended": false,
                "id": "SXNzdWU6Ymd4bXJ6",
                "description": "A source line is considered covered when at least one instruction that is assigned to this line has been executed by a test case. These lines were not executed during any of the test cases.",
                "category": "COVERAGE",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Unsynchronized lazy initialization of static value detected",
                "tags": [
                  "sans-top-25",
                  "cwe-362",
                  "cwe-609"
                ],
                "shortcode": "JAVA-E1053",
                "shortDescription": "A static field has been lazy initialized without any synchronization used. This will allow race conditions to occur if the field's getter is called on multiple threads at once.",
                "severity": "CRITICAL",
                "isRecommended": true,
                "id": "SXNzdWU6Ym92cHhx",
                "description": "A static field has been lazy initialized without any synchronization used. This will allow race conditions to occur if the field's getter is called on multiple threads at once.\n\n<!--more-->\n\n### Bad Practice\n\n```java\npublic class UnsynchronizedLazyInit {\n    private static SomeResource u = null;\n\n    static SomeResource getResource() {\n        // There is no synchronization used here...\n        if (u == null) {\n            u = new SomeResource();\n        }\n\n        return u;\n    }\n}\n```\n\nHere, if two threads were to call `getResource()` while `u` were `null`, both threads would attempt to assign a new `SomeResource` instance to `u`. In this scenario, one of the threads is likely to overwrite the value of `u` set in the other thread.\n\n### Recommended\n\nThere are a number of ways to solve this issue.\n\n**Use a synchronized method**\n\nThis solution may be problematic if some other code also synchronizes on `this` when a synchronized method is called.\n\n```java\nstatic synchronized SomeResource getResource() {\n    if (u == null) {\n        u = new SomeResource();\n    }\n\n    return u;\n}\n```\n\n**Synchronize on a private lock variable**\n\nThis method is safer, since we are now using a private and final value which cannot be locked on directly by external code.\n\n```java\nprivate final Object LOCK = new Object();\n\nstatic SomeResource getResource() {\n    synchronized(LOCK) {\n        if (u == null) {\n            u = new SomeResource();\n        }\n\n        return u;\n    }\n}\n```\n\n## References\n\n- [CWE-362](https://cwe.mitre.org/data/definitions/362.html) - Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n- [CWE-609](https://cwe.mitre.org/data/definitions/609.html) - Double-Checked Locking",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Concrete collection type used in method declaration",
                "tags": [],
                "shortcode": "JAVA-W1065",
                "shortDescription": "Concrete collection types (such as `ArrayList`, `HashMap`, etc.)  should not be used in a `public` method's signature.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enBqZWdr",
                "description": "Concrete collection types (such as `ArrayList`, `HashMap`, etc.)  should not be used in a `public` method's signature.\n\n<!--more-->\nJava encourages the use of abstract types/interfaces at the API boundary over concrete types. This helps one design generic APIs\nthat are easy to modify and extend.\n\nAlthough designing generic APIs is generally preferable, one should especially emphasize their use over concrete types\nwhen elements of the collection API are involved. This is because almost all non-trivial Java applications depend heavily on abstract types defined in Java's\ncollection framework.\n\n### Bad Practice\n\n```java\n// Return type is `ArrayList` instead of `List`.\npublic ArrayList<Integer> method() {\n    // ..rest of the code\n}\n\n// Parameter type is `HashMap` instead of `Map`.\npublic void methodWithParams(HashMap<String, String> demo) {\n    // ..rest of the code\n}\n```\n\n### Recommended\n\nConsider using abstract types in return values and parameters of `public` methods.\n\n```java\npublic List<Integer> method() {\n    // ..rest of the code\n}\n\npublic void methodWithParams(Map<String, String> demo) {\n    // ..rest of the code\n}\n```\n\n## References\n- StackOverflow - [Why we should use interface instead of concrete types?](https://stackoverflow.com/questions/19176781/why-we-should-use-interface-instead-of-concrete-types)\n- Oracle Java Documentation - [Polymorphism](https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Method returning collection/array type returns `null` instead",
                "tags": [],
                "shortcode": "JAVA-W1066",
                "shortDescription": "`null` should not be returned from methods that are supposed to return collection instances or arrays.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6enJnd2dl",
                "description": "`null` should not be returned from methods that are supposed to return collection instances or arrays.\n\n<!--more-->\nReturning `null` from such methods results in uglier code because now every caller has to check if the method has returned `null`.\nIf the caller fails to do this, there's a chance that executing such code will result in a `NullPointerException`.\n\nWhen dealing with collections or arrays, the absence of values can usually be communicated by returning an empty instance instead of `null`.\nThis is much more convenient because this rids the caller from the responsibility of checking for `null` every time this\nmethod is called.\n\n### Bad Practice\n\n```java\npublic List<Integer> method() {\n    // ... method body\n\n    if (/* some condition */)\n        return null;\n}\n\npublic int[] m2() {\n    // ... method body\n\n    if (/* some condition */)\n        return null;\n}\n```\n\n### Recommended\n\nConsider returning empty collection instances or arrays instead of `null`.\n\n```java\npublic List<Integer> method() {\n    // ... method body\n\n    if (/* some condition */)\n        return Collections.emptyList();\n}\n\npublic int[] m2() {\n    // ... method body\n\n    if (/* some condition */)\n        return new int[];\n}\n```\n\n## References\n- StackOverflow - [Is it better to return null or empty collection?](https://stackoverflow.com/questions/1969993/is-it-better-to-return-null-or-empty-collection)\n- CMU - [Return an empty array or collection instead of null](https://wiki.sei.cmu.edu/confluence/display/java/MET55-J.+Return+an+empty+array+or+collection+instead+of+a+null+value+for+methods+that+return+an+array+or+collection)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Calls to assertion chain methods should be terminated with an assertion",
                "tags": [],
                "shortcode": "JAVA-E1109",
                "shortDescription": "Always terminate calls to `assertThat()` or `verify()` with a relevant assertion call, such as `equals()`, or similar.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6emV2bWR4",
                "description": "Always terminate calls to `assertThat()` or `verify()` with a relevant assertion call, such as `equals()`, or similar.\n\n<!--more-->\n\nAssertion frameworks such as Assert4J and Truth have fluent APIs, where assertions are represented as chained method calls.\n\n```java\nassertThat(something).isEqualTo(\"somethingElse\");\n```\n\nWhile the fluent style is very convenient and can improve the developer experience, it is also easy to make a mistake by starting an assertion chain, but forgetting to end it.\n\nThis would make the assertion useless.\n\nWhat's worse is that such an incomplete assertion will not fail your tests, lulling you into a false sense of security.\n\nThis issue is reported for any test frameworks such as Assert4J or Mockito which support fluent assertions through methods such as `assertThat` or `verify`.\n\n## Bad Practice\n\n```java\nassertThat(someValue); // This assertion is incomplete.\n\n// for mockito\nverify(someMethod);\n```\n\n\n## Recommended\n\n```java\nassertThat(someValue).isGreaterThan(expectedValue);\n```\n\n## Exceptions\n\nThis issue will not be reported if the call is used within an expression, such as by returning it or passing it to a different function.",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Redundant cast of return value",
                "tags": [],
                "shortcode": "JAVA-W1067",
                "shortDescription": "The return value of a method call should not be cast if it is used in an expression that expects a value of the same type that the method is returning.",
                "severity": "MAJOR",
                "isRecommended": true,
                "id": "SXNzdWU6Ym1sYWpu",
                "description": "The return value of a method call should not be cast if it is used in an expression that expects a value of the same type that the method is returning.\n\n<!--more-->\nCasting the return value of a method is generally considered bad practice because it can lead to unnecessary complexity and makes the code harder to read.\n\nUnnecessary casting can also be confusing if the method's return type is either the same as the type of the cast or if the return type inherits from the cast type.\n### Bad Practice\n\n```java\npublic List<String> manyStrings() {\n    return List.of(\"a\", \"b\");\n}\n\nfor (String s : (List<String>) manyStrings()) { // ... }\n```\n\n```java\npublic String oneString() {\n    return \"ab\";\n}\n\nObject value = oneString();\n```\n\n### Recommended\n\nConsider removing the redundant casts.\n\n```java\npublic List<String> manyStrings() {\n    return List.of(\"a\", \"b\");\n}\n\nfor (String s : manyStrings()) { // ... }\n```\n\n```java\npublic String oneString() {\n    return \"ab\";\n}\n\nObject value = oneString();\n```\n\n## References\n- Oracle Java Language Specifications - [Conversions and Promotions](https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html)",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Test files should contain tests",
                "tags": [],
                "shortcode": "JAVA-W1088",
                "shortDescription": "Classes that look like test cases should contain tests.",
                "severity": "MINOR",
                "isRecommended": true,
                "id": "SXNzdWU6enBqeGtn",
                "description": "Classes that look like test cases should contain tests.\n\n<!--more-->\n\nThis issue is reported when a file within a test directory looks like a test file (has \"Test\" in its name, or contains classes with test framework related annotations) but contains no actual test code.\n\nThis issue will be reported if no symbols related to any of the following frameworks are found:\n\n- Junit 3\n- Junit 4\n- Junit 5\n- TestNG\n- ArchUnit\n\n### Bad Practice\n\nAvoid declaring classes that seem like tests but don't contain any test cases.\n\n```java\nclass SomethingTest {\n    // no test methods.\n}\n```\n\n### Recommended\n\nGive the class a better name, or remove it altogether if there is no need for it.",
                "category": "ANTI_PATTERN",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Inefficient use of keySet iterator instead of entrySet iterator",
                "tags": [],
                "shortcode": "JAVA-P0361",
                "shortDescription": "This method accesses the value of a Map entry, using a key that was retrieved from a `keySet` iterator.\n\nIt is more efficient to use an iterator on the `entrySet` of the map, to avoid the `Map.get(key)` lookup.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ym5qYW5n",
                "description": "This method accesses the value of a Map entry, using a key that was retrieved from a `keySet` iterator.\n\nIt is more efficient to use an iterator on the `entrySet` of the map, to avoid the `Map.get(key)` lookup.\n\n<!--more-->\n\n### Bad Practice\n```java\nfor (String key: map.keySet()) {\n    ...\n    if (satisfiesCriteria(key))\n        value = map.get(key); // Inefficient\n    ...\n}\n```\n\n### Recommended\n```java\nfor (Map.Entry<String, Integer> entry : map.entrySet()) {\n    ...\n    if (satisfiesCriteria(entry.getKey())\n        value = entry.getValue();\n    ...\n}\n```\n\nWhile the performance benefits of this change may not be very high for smaller maps, it is worth making this change if you will be handling maps with very large capacities (entry count in the millions for example), and/or slower or bad hashing implementations.\n\n## References\n- SpotBugs - [WMI\\_WRONG\\_MAP\\_ITERATOR](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#wmi-inefficient-use-of-keyset-iterator-instead-of-entryset-iterator-wmi-wrong-map-iterator)",
                "category": "PERFORMANCE",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Fields must not shadow other fields with the same name from super classes",
                "tags": [],
                "shortcode": "JAVA-W1007",
                "shortDescription": "This field appears to have the same name as a field in a super class.\n\nThis will prevent the superclass field from being accessed, and you will only be able to access the new field.",
                "severity": "MAJOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ynhqd21h",
                "description": "This field appears to have the same name as a field in a super class.\n\nThis will prevent the superclass field from being accessed, and you will only be able to access the new field.\n\n<!--more-->\n\nRename the new field to avoid conflicts.\n\n### Bad Practice\n```java\npublic class A {\n    public String firstValue;\n\n    public int secondValue;\n}\n\npublic class B extends A {\n    public boolean firstValue; // Wasn't firstValue a string before?\n}\n```\n\n### Recommended\n\n```java\npublic class A {\n    public String firstValue;\n\n    public int secondValue;\n}\n\npublic class B extends A {\n    public boolean thirdValue;\n}\n```\n\n### Exceptions\n\nThis issue will not be raised for static fields, or when the parent class field is private.",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          },
          {
            "node": {
              "issue": {
                "title": "Class overrides `hashCode` but not `equals`",
                "tags": [],
                "shortcode": "JAVA-W0117",
                "shortDescription": "This class defines a `hashCode` method but inherits its `equals` method from `java.lang.Object` (which defines equality by comparing object references). Although this will probably satisfy the contract that equal objects must have equal hashcodes, it is probably not what was intended by overriding the `hashCode` method.",
                "severity": "MINOR",
                "isRecommended": false,
                "id": "SXNzdWU6Ymxsd294",
                "description": "This class defines a `hashCode` method but inherits its `equals` method from `java.lang.Object` (which defines equality by comparing object references). Although this will probably satisfy the contract that equal objects must have equal hashcodes, it is probably not what was intended by overriding the `hashCode` method.\n\n<!--more-->\n\nOverriding `hashCode` implies that the object's identity is based on criteria more complicated than simple reference equality. If the accompanying `equals` implementation does not follow similar criteria as the `hashCode` implementation, situations where two objects may compare as equal but may not have the same hashCode may arise.\n\nNote that while it is required by contract that two objects which compare as equal also have the same hashCode values, it is *not* required for both objects to have different hashCodes when they are **not** equal.\n\n### Bad Practice\n```java\nclass SomeClass {\n\n    /* fields */\n\n    @Override\n    int hashCode() {\n        // ... hashCode computation ...\n        return computedHashcode;\n    }\n\n    // no equals implementation.\n}\n```\n\n### Recommended\n\nOverride the `equals` method as well to explicitly specify conditions for equality.\n\n```java\nclass SomeClass {\n\n    /* fields */\n\n    @Override\n    int hashCode() {\n        // ... hashCode computation ...\n        return computedHashcode;\n    }\n\n    @Override\n    boolean equals() {\n        // equality condition\n    }\n}\n```\n\nIf you don't think instances of this class will ever be inserted into a HashMap/HashTable,\nthe recommended `hashCode` implementation to use is:\n\n```java\npublic int hashCode() {\n    throw new NotImplementedException(\"hashCode not designed\");\n    return 42; // any arbitrary constant will do\n}\n```\n\n## References\n- Spotbugs - [HE\\_HASHCODE\\_USE\\_OBJECT\\_EQUALS](https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#he-class-defines-hashcode-and-uses-object-equals-he-hashcode-use-object-equals)",
                "category": "BUG_RISK",
                "autofixAvailable": false
              }
            }
          }
        ]
      }
    }
  }
}