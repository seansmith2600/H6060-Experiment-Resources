#!/usr/bin/env python3

import re
import os
import csv
import sys
import time
import json
import pandas as pd
import logging
import argparse
import requests
import itertools
from datetime import datetime
from packageurl import PackageURL
from requests.auth import HTTPBasicAuth
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry


class LogFilter:  # pragma: no cover
    def __init__(self, level):
        self.__level = level

    def filter(self, log_record):
        return log_record.levelno <= self.__level


class Cache:  # pragma: no cover
    def __init__(self, not_found_obj=None):
        self.cache = {}
        self.not_found_obj = not_found_obj

    def set(self, key, value):
        self.cache[key] = {"value": value}

    def get(self, key):
        if key in self.cache:
            entry = self.cache[key]
            return entry["value"]
        return self.not_found_obj

    def clear(self):
        self.cache = {}


# Set default values
default_not_found_value = "Not found"
default_manual_review_value = "Manual review required"
default_not_applicable_value = "N/A"

static_application_security_testing = "SAST"
software_composition_analysis = "SCA"

# OpenCVE API is rate limited, caching CWE details to reduce API calls
cwe_name_cache = Cache()
cwe_description_cache = Cache()

# NVD API is rate limited, caching CVE details to reduce API calls
cve_description_cache = Cache()
cve_published_date_cache = Cache()
cve_last_modified_date = Cache()
cve_status_cache = Cache()
cve_source_cache = Cache()
cve_cvss_v2_vector_cache = Cache()
cve_cvss_v3_vector_cache = Cache()
cve_cvss_v4_vector_cache = Cache()
cve_cwe_id_cache = Cache()


def get_args(args: argparse.Namespace) -> argparse.Namespace:
    """Parse and return the arguments of the application

    :parameter
        args:argparse.Namespace -- Submitted arguments to parse

    :return
        argparse.Namespace -- Parsed arguments
    """
    parser = argparse.ArgumentParser(description="Generate Vulnerability Results Report.")
    parser.add_argument(
        "--nvd-api-key",
        action="store",
        required=True,
        help="NIST NVD API key",
    )
    parser.add_argument(
        "--github-server-url",
        action="store",
        required=True,
        help="GitHub server URL",
    )
    parser.add_argument(
        "--github-api-url",
        action="store",
        required=True,
        help="GitHub API URL",
    )
    parser.add_argument(
        "--github-api-token",
        action="store",
        required=True,
        help="GitHub API token",
    )
    parser.add_argument(
        "--opencve-username",
        action="store",
        required=True,
        help="OpenCVE registered username",
    )
    parser.add_argument(
        "--opencve-password",
        action="store",
        required=True,
        help="OpenCVE registered password",
    )
    parser.add_argument(
        "--experiment-id",
        action="store",
        required=True,
        help="Experiment ID",
    )
    parser.add_argument(
        "--experiment-github-project-name",
        action="store",
        required=True,
        help="Experiment GitHub project name",
    )
    parser.add_argument(
        "--experiment-github-repository",
        action="store",
        required=True,
        help="Experiment GitHub repository",
    )
    parser.add_argument(
        "--experiment-github-branch",
        action="store",
        required=True,
        help="Experiment GitHub branch",
    )
    parser.add_argument(
        "--experiment-github-commit",
        action="store",
        required=True,
        help="Experiment GitHub commit",
    )
    parser.add_argument(
        "--experiment-github-workflow-name",
        action="store",
        required=True,
        help="Experiment GitHub workflow name",
    )
    parser.add_argument(
        "--experiment-github-workflow-run-id",
        action="store",
        required=True,
        help="Experiment GitHub workflow run ID",
    )
    parser.add_argument(
        "--experiment-programming-language",
        action="store",
        required=True,
        help="Experiment programming language",
    )
    parser.add_argument(
        "--sonarqube-url",
        nargs="?",
        const="",
        required=False,
        help="SonarQube URL",
    )
    parser.add_argument(
        "--sonarqube-token",
        nargs="?",
        const="",
        required=False,
        help="SonarQube Token",
    )
    parser.add_argument(
        "--sonarqube-project-key",
        nargs="?",
        const="",
        required=False,
        help="SonarQube Project Key",
    )
    parser.add_argument(
        "--deepsource-api-key",
        nargs="?",
        const="",
        required=False,
        help="DeepSource API Key",
    )
    parser.add_argument(
        "--sast-codeql-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting CodeQL CSV report",
    )
    parser.add_argument(
        "--sast-deepsource-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting DeepSource CSV report",
    )
    parser.add_argument(
        "--sast-horusec-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Horusec JSON report",
    )
    parser.add_argument(
        "--sast-horusec-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Horusec CSV report",
    )
    parser.add_argument(
        "--sast-semgrep-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Semgrep JSON report",
    )
    parser.add_argument(
        "--sast-semgrep-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Semgrep CSV report",
    )
    parser.add_argument(
        "--sast-snyk-code-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Snyk Code JSON report",
    )
    parser.add_argument(
        "--sast-snyk-code-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Snyk Code CSV report",
    )
    parser.add_argument(
        "--sast-sonarqube-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting SonarQube CSV report",
    )
    parser.add_argument(
        "--sca-dependabot-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Dependabot CSV report",
    )
    parser.add_argument(
        "--sca-eclipse-steady-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Eclipse Steady report",
    )
    parser.add_argument(
        "--sca-eclipse-steady-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Eclipse Steady CSV report",
    )
    parser.add_argument(
        "--sca-grype-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Grype report",
    )
    parser.add_argument(
        "--sca-grype-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Grype CSV report",
    )
    parser.add_argument(
        "--sca-snyk-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of Snyk report",
    )
    parser.add_argument(
        "--sca-snyk-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting Snyk CSV report",
    )
    parser.add_argument(
        "--sca-owasp-dependency-check-report-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of OWASP Dependency Check JSON report",
    )
    parser.add_argument(
        "--sca-owasp-dependency-check-csv-result-filename",
        nargs="?",
        const="",
        required=False,
        help="Name of resulting OWASP Dependency Check CSV report",
    )
    return parser.parse_args(args)


# =====================
# API Request functions
# =====================
def send_vulnerability_get_request(
    url: str, api_key: str = None, username: str = None, password: str = None, sleep: int = 5
) -> requests:  # pragma: no cover
    """Send GET request to NVD, OpenCVE URL

    :parameter
        url:str -- URL to make GET request
        api_key:str -- API key for authentication
        username:str -- Username for authentication
        password:str -- Password for authentication
        sleep:int -- Time to sleep before making request

    :return
        requests.models.Response -- Response from GET request
    """
    log.info(f"Initiating GET request: {url}")
    session = requests.Session()
    retries = Retry(
        total=3,
        backoff_factor=3,
        status_forcelist=[404, 408, 500, 502, 503, 504],
    )
    session.mount("https://", HTTPAdapter(max_retries=retries))
    if api_key:
        headers = {"Accept": "application/json", "apiKey": api_key}
        request = session.get(url, headers=headers)
    else:
        headers = {"Accept": "application/json"}
        request = session.get(url, headers=headers, auth=HTTPBasicAuth(username, password))
    if request.ok:
        log.info(f"GET request successful: {url}")
        # Avoid rate limiting
        if sleep:
            log.info(f"Sleeping for {sleep} seconds before making next request")
            time.sleep(sleep)
        return request
    log.error(f"GET request failed: \n{request.text.encode('utf8')}")
    return None


def send_deepsource_get_request(
    url: str, api_key: str, request_body: str, request_variables: str, sleep: int = 5
) -> requests:  # pragma: no cover
    """Send GET request to GitHub API URL

    :parameter
        url:str -- URL to make GET request
        api_key:str -- DeepSource API key
        request_body:str -- Request body for DeepSource API
        request_variables:str -- Request variables for DeepSource API

    :return
        requests.models.Response -- Response from GET request
    """
    log.info(f"Initiating GET request: {url}")
    session = requests.Session()
    retries = Retry(
        total=3,
        backoff_factor=3,
        status_forcelist=[404, 408, 500, 502, 503, 504],
    )
    session.mount("https://", HTTPAdapter(max_retries=retries))
    headers = {"Authorization": f"Bearer {api_key}"}
    request = session.get(url, headers=headers, json={"query": request_body, "variables": request_variables})
    if request.ok:
        log.info(f"GET request successful: {url}")
        # Avoid rate limiting
        if sleep:
            log.info(f"Sleeping for {sleep} seconds before making next request")
            time.sleep(sleep)
        return request
    log.error(f"GET request failed: \n{request.text.encode('utf8')}")
    return None


def send_github_get_request(url: str, github_api_token=None, sleep: int = 5) -> requests:  # pragma: no cover
    """Send GET request to GitHub API URL

    :parameter
        url:str -- URL to make GET request
        github_api_token:str -- GitHub API token
        sleep:int -- Time to sleep before making request

    :return
        requests.models.Response -- Response from GET request
    """
    log.info(f"Initiating GET request: {url}")
    session = requests.Session()
    retries = Retry(
        total=3,
        backoff_factor=3,
        status_forcelist=[404, 408, 500, 502, 503, 504],
    )
    session.mount("https://", HTTPAdapter(max_retries=retries))
    headers = {"Accept": "application/vnd.github+json", "X-GitHub-Api-Version": "2022-11-28", "Authorization": f"Bearer {github_api_token}"}
    request = session.get(url, headers=headers)
    if request.ok:
        log.info(f"GET request successful: {url}")
        # Avoid rate limiting
        if sleep:
            log.info(f"Sleeping for {sleep} seconds before making next request")
            time.sleep(sleep)
        return request
    log.error(f"GET request failed: \n{request.text.encode('utf8')}")
    return None


def send_sonarqube_get_request(url: str, token: str, sleep: int = 5) -> requests:  # pragma: no cover
    """Send GET request to SonarQube URL

    :parameter
        url:str -- URL to make GET request
        token:str -- Token for authentication
        sleep:int -- Time to sleep before making request

    :return
        requests.models.Response -- Response from GET request
    """
    log.info(f"Initiating GET request: {url}")
    session = requests.Session()
    retries = Retry(
        total=3,
        backoff_factor=3,
        status_forcelist=[404, 408, 500, 502, 503, 504],
    )
    session.mount("https://", HTTPAdapter(max_retries=retries))
    headers = {"Accept": "application/json"}
    request = session.get(url, headers=headers, auth=HTTPBasicAuth(token, ""))
    if request.ok:
        log.info(f"GET request successful: {url}")
        # Avoid rate limiting
        if sleep:
            log.info(f"Sleeping for {sleep} seconds before making next request")
            time.sleep(sleep)
        return request
    log.error(f"GET request failed: \n{request.text.encode('utf8')}")
    return None


# =================
# Top CWE functions
# =================
def get_mitre_top_25_cwe() -> list:
    """Top 25 CWE of 2024

    :return
        list -- Top 25 CWE IDs
    """
    return [
        "CWE-787",
        "CWE-79",
        "CWE-89",
        "CWE-416",
        "CWE-78",
        "CWE-20",
        "CWE-125",
        "CWE-22",
        "CWE-352",
        "CWE-434",
        "CWE-862",
        "CWE-476",
        "CWE-287",
        "CWE-190",
        "CWE-502",
        "CWE-77",
        "CWE-119",
        "CWE-798",
        "CWE-918",
        "CWE-306",
        "CWE-362",
        "CWE-269",
        "CWE-94",
        "CWE-863",
        "CWE-276",
    ]


def get_owasp_top_10_cwe() -> set:
    """Top 10 OWASP CWE of 2024

    :return
        list -- CWE IDs corresponding to the OWASP security category
    """
    return {
        "A01 Broken Access Control": [
            "CWE-22",
            "CWE-23",
            "CWE-35",
            "CWE-59",
            "CWE-200",
            "CWE-201",
            "CWE-219",
            "CWE-264",
            "CWE-275",
            "CWE-276",
            "CWE-284",
            "CWE-285",
            "CWE-352",
            "CWE-359",
            "CWE-377",
            "CWE-402",
            "CWE-425",
            "CWE-441",
            "CWE-497",
            "CWE-538",
            "CWE-540",
            "CWE-548",
            "CWE-552",
            "CWE-566",
            "CWE-601",
            "CWE-639",
            "CWE-651",
            "CWE-668",
            "CWE-706",
            "CWE-862",
            "CWE-863",
            "CWE-913",
            "CWE-922",
            "CWE-1275",
        ],
        "A02 Cryptographic Failures": [
            "CWE-261",
            "CWE-296",
            "CWE-310",
            "CWE-319",
            "CWE-321",
            "CWE-322",
            "CWE-323",
            "CWE-324",
            "CWE-325",
            "CWE-326",
            "CWE-327",
            "CWE-328",
            "CWE-329",
            "CWE-330",
            "CWE-331",
            "CWE-335",
            "CWE-336",
            "CWE-337",
            "CWE-338",
            "CWE-339",
            "CWE-340",
            "CWE-347",
            "CWE-523",
            "CWE-720",
            "CWE-757",
            "CWE-759",
            "CWE-760",
            "CWE-780",
            "CWE-818",
            "CWE-916",
        ],
        "A03 Injection": [
            "CWE-20",
            "CWE-74",
            "CWE-75",
            "CWE-77",
            "CWE-78",
            "CWE-79",
            "CWE-80",
            "CWE-83",
            "CWE-87",
            "CWE-88",
            "CWE-89",
            "CWE-90",
            "CWE-91",
            "CWE-93",
            "CWE-94",
            "CWE-95",
            "CWE-96",
            "CWE-97",
            "CWE-98",
            "CWE-99",
            "CWE-100",
            "CWE-113",
            "CWE-116",
            "CWE-138",
            "CWE-184",
            "CWE-470",
            "CWE-471",
            "CWE-564",
            "CWE-610",
            "CWE-643",
            "CWE-644",
            "CWE-652",
            "CWE-917",
        ],
        "A04 Insecure Design": [
            "CWE-73",
            "CWE-183",
            "CWE-209",
            "CWE-213",
            "CWE-235",
            "CWE-256",
            "CWE-257",
            "CWE-266",
            "CWE-269",
            "CWE-280",
            "CWE-311",
            "CWE-312",
            "CWE-313",
            "CWE-316",
            "CWE-419",
            "CWE-430",
            "CWE-434",
            "CWE-444",
            "CWE-451",
            "CWE-472",
            "CWE-501",
            "CWE-522",
            "CWE-525",
            "CWE-539",
            "CWE-579",
            "CWE-598",
            "CWE-602",
            "CWE-642",
            "CWE-646",
            "CWE-650",
            "CWE-653",
            "CWE-656",
            "CWE-657",
            "CWE-799",
            "CWE-807",
            "CWE-840",
            "CWE-841",
            "CWE-927",
            "CWE-1021",
            "CWE-1173",
        ],
        "A05 Security Misconfiguration": [
            "CWE-2",
            "CWE-11",
            "CWE-13",
            "CWE-15",
            "CWE-16",
            "CWE-260",
            "CWE-315",
            "CWE-266",
            "CWE-520",
            "CWE-526",
            "CWE-537",
            "CWE-541",
            "CWE-547",
            "CWE-611",
            "CWE-614",
            "CWE-756",
            "CWE-776",
            "CWE-942",
            "CWE-1004",
            "CWE-1032",
            "CWE-1174",
        ],
        "A06 Vulnerable And Outdated Components": [
            "Drupal",
            "WordPress",
            "Joomla",
        ],
        "A07 Identification and Authentication Failures": [
            "CWE-255",
            "CWE-259",
            "CWE-287",
            "CWE-288",
            "CWE-290",
            "CWE-294",
            "CWE-295",
            "CWE-297",
            "CWE-300",
            "CWE-302",
            "CWE-304",
            "CWE-306",
            "CWE-307",
            "CWE-346",
            "CWE-384",
            "CWE-521",
            "CWE-613",
            "CWE-620",
            "CWE-640",
            "CWE-798",
            "CWE-940",
            "CWE-1216",
        ],
        "A08 Software and Data Integrity Failures": [
            "CWE-345",
            "CWE-353",
            "CWE-426",
            "CWE-494",
            "CWE-502",
            "CWE-565",
            "CWE-784",
            "CWE-829",
            "CWE-830",
            "CWE-913",
        ],
        "A09 Security Logging and Monitoring Failures": [
            "CWE-117",
            "CWE-223",
            "CWE-532",
            "CWE-778",
        ],
        "A10 Server Side Request Forgery (SSRF)": ["CWE-918"],
    }


# ====================
# CSV header functions
# ====================
def get_csv_sca_column_headers() -> str:
    """Get column headers for SCA CSV report

    :return
        list -- Column headers for SCA CSV report
    """
    csv_headers = [
        "Experiment ID",
        "Experiment Date",
        "Experiment Project Name",
        "Experiment Upstream GitHub Repository",
        "Experiment GitHub Repository",
        "Experiment GitHub Branch",
        "Experiment GitHub Commit",
        "Experiment GitHub Workflow Name",
        "Experiment GitHub Workflow Run URL",
        "Security Tool Category",
        "Security Tool Type",
        "Security Tool Name",
        "Security Tool Classification",
        "Security Tool CLI Version",
        "Programming Language",
        "Severity",
        "Confidence",
        "Component Type",
        "Component Name",
        "Component Version",
        "Component PURL",
        "Component License",
        "Component Location",
        "CVE ID",
        "CVE Description",
        "CVE Source",
        "CVE Published Date",
        "CVE Last Modified Date",
        "CVE Status",
        "CVE Malicious",
        "CVE Disputed",
        "CVSS V2 Vector",
        "CVSS V3 Vector",
        "CVSS V4 Vector",
        "CWE ID",
    ]
    return f"{convert_list_to_csv_row(csv_headers)}\n"


def get_csv_sast_column_headers() -> str:
    """Get column headers for SAST CSV report

    :return
        list -- Column headers for SAST CSV report
    """
    csv_headers = [
        "Experiment ID",
        "Experiment Date",
        "Experiment Project Name",
        "Experiment Upstream GitHub Repository",
        "Experiment GitHub Repository",
        "Experiment GitHub Branch",
        "Experiment GitHub Commit",
        "Experiment GitHub Workflow Name",
        "Experiment GitHub Workflow Run URL",
        "Security Tool Category",
        "Security Tool Type",
        "Security Tool Name",
        "Security Tool Classification",
        "Security Tool CLI Version",
        "Programming Language",
        "Severity",
        "Confidence",
        "CWE ID",
        "CWE Name",
        "CWE Description",
        "CWE Impact",
        "CWE Likelihood",
        "OWASP Top 10",
        "Mitre Top 25",
        "Rule ID",
        "File",
        "Line",
        "Main Source Code",
    ]
    return f"{convert_list_to_csv_row(csv_headers)}\n"


# ====================
# CSV writer functions
# ====================
def write_csv_report_header(security_testing_tool_category: str, csv_output_filename: str) -> None:
    """Write CSV report header

    :parameter
        security_testing_tool_category:str -- Type of tool to write header for (sca or sast)
        csv_output_filename:str -- Name of CSV report to write
    """
    log.info(f"Writing CSV report header to {get_directory_path()}/{csv_output_filename}")

    with open(os.path.join(get_directory_path(), csv_output_filename), "w") as file:
        if security_testing_tool_category.upper() == static_application_security_testing:
            file.write(get_csv_sast_column_headers())
        elif security_testing_tool_category.upper() == software_composition_analysis:
            file.write(get_csv_sca_column_headers())
        else:
            log.error(f"Tool type {security_testing_tool_category} not supported")
            sys.exit(1)

    log.info(f"Successfully wrote CSV report header to {get_directory_path()}/{csv_output_filename}")


def write_to_csv_report(csv_data: list, csv_output_filename: str) -> None:
    """Write parsed vulnerability data to CSV report

    :parameter
        csv_data:list -- Data to write to CSV report
        csv_output_filename:str -- Name of CSV report to write
    """
    log.info(f"Writing parsed vulnerability data to {get_directory_path()}/{csv_output_filename}")

    csv_data.sort()
    csv_data = list(item for item, _ in itertools.groupby(csv_data))

    with open(os.path.join(get_directory_path(), csv_output_filename), "a") as csv_file:
        writer = csv.writer(csv_file)
        writer.writerows(csv_data)

    log.info(f"Successfully wrote SBOM and OSV data to {get_directory_path()}/{csv_output_filename}")


def combine_csv_reports(security_testing_tool_category: str, csv_files: list) -> None:  # pragma: no cover
    """Combine CSV reports based on security testing tool type

    :param
        security_testing_tool_category:str -- Type of tool to combine CSV reports for (sca or sast)
        csv_files:list -- List of CSV files to combine
    """
    df_list = []
    for csv_file in csv_files:
        csv_file_path = os.path.join(get_directory_path(), csv_file)
        try:
            df = pd.read_csv(csv_file_path, keep_default_na=False)
            df_list.append(df)
        except UnicodeDecodeError:
            try:
                df = pd.read_csv(csv_file_path, keep_default_na=False, sep="\t", encoding="utf-16")
                df_list.append(df)
            except Exception as e:
                log.error(f"Error reading CSV report: {e}")
                sys.exit(1)
        except Exception as e:
            log.error(f"Error combining CSV reports: {e}")
            sys.exit(1)

    # Concatenate all data into one DataFrame
    combined_df = pd.concat(df_list, ignore_index=True)

    # Save the final result to a new CSV file
    combined_file_name = f"{security_testing_tool_category.lower()}_combined_report.csv"
    combined_df.to_csv(os.path.join(get_directory_path(), combined_file_name), index=False)


# ================
# Helper functions
# ================
def get_directory_path() -> str:
    """Get directory path of script

    :return
        str -- Directory path of script
    """
    return os.path.dirname(os.path.realpath(__file__))


def convert_list_to_string(data: list) -> str:
    """Convert list to string

    :parameter
        data:list -- Data to convert to string

    :return
        str -- Data as string
    """
    if len(data) > 0:
        return ",".join(data)
    return default_not_found_value


def convert_list_to_csv_row(data: list) -> str:
    """Convert list to CSV row

    :parameter
        data:list -- Data to convert to CSV row

    :return
        str -- CSV row
    """
    return ",".join(map(str, data))


def get_current_date() -> str:
    """Get current date in YYYY-MM-DD format

    :return
        str -- Current date
    """
    return datetime.today().strftime("%Y-%m-%d")


def get_experiment_information(args: argparse.Namespace, upstream_github_repository, github_repository) -> list:
    """Get experiment information

    :parameter
        args:argparse.Namespace -- Experiment information

    :return
        list -- Experiment information
    """
    return [
        str(args.experiment_id),
        get_current_date(),
        args.experiment_github_project_name.title(),
        upstream_github_repository,
        github_repository,
        args.experiment_github_branch,
        str(args.experiment_github_commit),
        args.experiment_github_workflow_name,
        get_github_actions_workflow_run_url(args),
    ]


def get_security_testing_tool_category(security_testing_tool_name: str) -> str:
    """Get security testing tool category

    :parameter
        security_testing_tool_name:str -- Name of security testing tool

    :return
        str -- Security testing tool category
    """
    security_testing_tool_name = security_testing_tool_name.upper()

    if (
        security_testing_tool_name == "CODEQL"
        or security_testing_tool_name == "SNYK CODE"
        or security_testing_tool_name == "DEEPSOURCE"
        or security_testing_tool_name == "SEMGREP"
        or security_testing_tool_name == "SONARQUBE"
        or security_testing_tool_name == "HORUSEC"
    ):
        return static_application_security_testing
    elif (
        security_testing_tool_name == "ECLIPSE STEADY"
        or security_testing_tool_name == "DEPENDABOT"
        or security_testing_tool_name == "GRYPE"
        or security_testing_tool_name == "OWASP DEPENDENCY CHECK"
        or security_testing_tool_name == "SNYK"
    ):
        return software_composition_analysis
    else:
        return default_not_found_value


def get_security_testing_tool_type(security_testing_tool_name: str) -> str:
    """Get Security Testing Tool Type

    :parameter
        security_testing_tool_name:str -- Name of security testing tool

    :return
        str -- Security testing tool type
    """
    security_testing_tool_name = security_testing_tool_name.upper()

    if (
        security_testing_tool_name == "CODEQL"
        or security_testing_tool_name == "DEPENDABOT"
        or security_testing_tool_name == "ECLIPSE STEADY"
        or security_testing_tool_name == "GRYPE"
        or security_testing_tool_name == "HORUSEC"
        or security_testing_tool_name == "OWASP DEPENDENCY CHECK"
        or security_testing_tool_name == "SONARQUBE"
    ):
        return "FOSS"
    elif (
        security_testing_tool_name == "DEEPSOURCE"
        or security_testing_tool_name == "SEMGREP"
        or security_testing_tool_name == "SNYK"
        or security_testing_tool_name == "SNYK CODE"
    ):
        return "Commercial"
    else:
        return default_not_found_value


def get_security_testing_tool_classification(security_testing_tool_name: str) -> str:
    """Get tool classification

    :parameter
        security_testing_tool_name:str -- Name of tool

    :return
        str -- Tool classification
    """
    security_testing_tool_name = security_testing_tool_name.upper()

    if (
        security_testing_tool_name == "CODEQL"
        or security_testing_tool_name == "SNYKCODE"
        or security_testing_tool_name == "DEEPSOURCE"
        or security_testing_tool_name == "SEMGREP"
        or security_testing_tool_name == "SONARQUBE"
    ):
        return "Semantic-Based"
    elif security_testing_tool_name == "HORUSEC":
        return "Syntactic-Based"
    elif security_testing_tool_name == "ECLIPSE STEADY":
        return "Code Centric and Usage-Based"
    elif (
        security_testing_tool_name == "DEPENDABOT"
        or security_testing_tool_name == "GRYPE"
        or security_testing_tool_name == "OWASP DEPENDENCY CHECK"
        or security_testing_tool_name == "SNYK"
    ):
        return "Metadata-Based"
    else:
        return default_not_found_value


def get_vulnerability_main_source_code(file_path: str) -> str:
    """Check if vulnerability is in main source code

    :parameter
        file_path:str -- File path of vulnerability

    :return
        str -- If vulnerability is in main source code
    """
    if "src" in file_path.lower() and "test" not in file_path.lower():
        return "Yes"
    elif "test" in file_path.lower():
        return "No"
    else:
        return default_manual_review_value


def remove_new_lines_from_cve_description(cve_description: str) -> str:
    """Remove new lines from CVE description

    :parameter
        cve_description:str -- Description of CVE

    :return
        str -- Description of CVE without new lines
    """
    return os.linesep.join([s for s in cve_description.splitlines() if s])


def get_github_actions_workflow_run_url(args: argparse.Namespace) -> str:
    """Get GitHub Actions workflow run URL

    :parameter
        args:argparse.Namespace -- Parsed arguments supplied to script

    :return
        str -- GitHub Actions workflow run URL
    """
    return f"{args.github_server_url}/{args.experiment_github_repository}/actions/runs/{args.experiment_github_workflow_run_id}"


def get_json_value(
    json_data: dict,
    data_key_1: str,
    data_key_2: str = None,
    data_key_3: str = None,
    default_value: str = default_not_found_value,
) -> str:
    """Get JSON value if exists

    :parameter
        json_data:dict -- JSON response data
        data_key_1:str -- Primary key of JSON response data
        data_key_2:str -- Optional second key of JSON response data
        data_key_3:str -- Optional third key of JSON response data
        default_value:str -- Default value if key not found

    :return
        str -- JSON value
    """
    if data_key_3 is not None:
        if data_key_1 in json_data:
            if data_key_2 in json_data[data_key_1]:
                if data_key_3 in json_data[data_key_1][data_key_2]:
                    # Check if value is not empty
                    if json_data[data_key_1][data_key_2][data_key_3]:
                        return json_data[data_key_1][data_key_2][data_key_3]
    elif data_key_2 is not None:
        if data_key_1 in json_data:
            if data_key_2 in json_data[data_key_1]:
                # Check if value is not empty
                if json_data[data_key_1][data_key_2]:
                    return json_data[data_key_1][data_key_2]
    elif data_key_1 in json_data:
        # Check if value is not empty
        if json_data[data_key_1]:
            return json_data[data_key_1]
    return default_value


def get_cwe_regex() -> str:
    """Get regex pattern for CWE ID

    :return
        str -- CWE ID regex pattern
    """
    return r"CWE-(\d{1,9})"


def search_owasp_top_10(cwe_id: str) -> str:
    """Search OWASP Top 10 for CWE ID

    :parameter
        cwe_id:str -- CWE ID to check if in OWASP top 10

    :return
        str -- OWASP category associated with CWE ID
    """
    for key, value in get_owasp_top_10_cwe().items():
        if cwe_id in value:
            log.info(f"{cwe_id} found in OWASP Top 10: {key}")
            return key
    log.info(f"{cwe_id} not found in OWASP Top 10")
    return "No"


def search_mitre_top_25(cwe_id: str) -> str:
    """Search MITRE Top 25 for CWE ID

    :parameter
        cwe_id:str -- CWE ID to check if in MITRE top 25

    :return
        str -- MITRE ranking for CWE ID
    """
    if cwe_id in get_mitre_top_25_cwe():
        cwe_index = str(get_mitre_top_25_cwe().index(cwe_id) + 1)
        log.info(f"{cwe_id} found in MITRE Top 25 at index {cwe_index}")
        return cwe_index
    log.info(f"{cwe_id} not found in MITRE Top 25")
    return "No"


# OpenCVE API is rate limited
def get_opencve_api_url(cwe_id: str) -> str:
    """Get OpenCVE API URL for CWE ID

    :parameter
        cwe_id:str -- CWE ID to search in OpenCVE

    :return
        str -- OpenCVE API URL for CWE ID
    """
    return f"https://www.opencve.io/api/cwe/{cwe_id}"


# OpenCVE extracts CVE details from NVD but NVD API rate limiting is less restrictive
def get_nvd_api_url(cve_id: str) -> str:
    """Get NVD API URL for CVE ID

    :parameter
        cwe_id:str -- CVE ID to search in NVD

    :return
        str -- NVD API URL for CVE ID
    """
    return f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={cve_id}"


def get_github_api_url(github_api_url: str, github_repository: str, api_endpoint: str = None) -> str:
    """Get GitHub API URL for repository scan information

    :parameter
        github_api_url:str -- GitHub API URL
        github_repository:str -- GitHub repository name
        api_endpoint:str -- GitHub API endpoint

    :return
        str -- GitHub API URL for repository
    """
    if api_endpoint is None:
        return f"{github_api_url}/repos/{github_repository}"
    else:
        return f"{github_api_url}/repos/{github_repository}/{api_endpoint}"


def get_snyk_code_severity_levels(level: str) -> str:
    """
    Get Snyk Code severity levels

    :param
        level: str -- Snyk Code severity level

    :return:
        str -- Snyk Code severity level
    """
    # See https://docs.snyk.io/snyk-cli/scan-and-maintain-projects-using-the-cli/snyk-cli-for-snyk-code/view-snyk-code-cli-results#severity-levels-in-json-and-sarif-files
    if level.upper() == "ERROR":
        return "High"
    elif level.upper() == "WARNING":
        return "Medium"
    elif level.upper() == "NOTE" or level.upper() == "INFO":
        return "Low"
    else:
        return default_not_found_value


def get_grype_cvss_vector(cvss_data: dict, cvss_version_primary: str, cvss_version_secondary=None) -> str:
    """Get Grype CVSS vector

    :parameter
        cvss_data:dict -- Grype CVSS data
        cvss_version_primary:str -- Primary CVSS version
        cvss_version_secondary:str -- Secondary CVSS version

    :return
        str -- Grype CVSS vector
    """
    for cvss_version in cvss_data["cvss"]:
        if get_json_value(cvss_version, "version") == cvss_version_primary:
            return get_json_value(cvss_version, "vector")
        elif get_json_value(cvss_version, "version") == cvss_version_secondary:
            return get_json_value(cvss_version, "vector")
    return default_not_found_value


def get_snyk_cvss_vector(cvss_data: dict, cvss_version_key: str) -> str:
    """Get Snyk CVSS vector

    :parameter
        cvss_data:dict -- Snyk CVSS data
        cvss_version_primary:str -- CVSS version key

    :return
        str -- Snyk CVSS vector
    """
    if cvss_version_key in cvss_data:
        return get_json_value(cvss_data, cvss_version_key)
    return default_not_found_value


def get_nvd_cvss_vector(nvd_data: dict, cvss_version: str) -> str:
    """Get NVD CVSS vector

    :parameter
        nvd_data:dict -- NVD response data
        cvss_version:str -- CVSS version

    :return
        str -- NVD CVSS vector
    """
    if "cvssMetricV4" in nvd_data and cvss_version == "4.0":
        cvss_details = get_json_value(nvd_data, "cvssMetricV4")
        return get_json_value(cvss_details[0], "cvssData", "vectorString")
    elif "cvssMetricV31" in nvd_data and cvss_version == "3.1":
        cvss_details = get_json_value(nvd_data, "cvssMetricV31")
        return get_json_value(cvss_details[0], "cvssData", "vectorString")
    elif "cvssMetricV3" in nvd_data and cvss_version == "3.0":
        cvss_details = get_json_value(nvd_data, "cvssMetricV3")
        return get_json_value(cvss_details[0], "cvssData", "vectorString")
    elif "cvssMetricV2" in nvd_data and cvss_version == "2.0":
        cvss_details = get_json_value(nvd_data, "cvssMetricV2")
        return get_json_value(cvss_details[0], "cvssData", "vectorString")
    return default_not_found_value


def get_cwe_from_nvd(nvd_data: dict) -> str:
    """Get CWE ID from NVD data

    :parameter
        nvd_data:dict -- NVD data to extract CWE ID from

    :return
        str -- CWE ID extracted from NVD data
    """
    nvd_weaknesses = get_json_value(nvd_data, "cve", "weaknesses")
    if nvd_weaknesses is default_not_found_value:
        return nvd_weaknesses
    cwe_list = []
    for weakness in nvd_weaknesses:
        for description in weakness["description"]:
            # Only consider vulnerabilities with CWE ID
            match = re.search(get_cwe_regex(), description["value"])
            if match:
                vulnerability_cwe_id = match.group(0).upper()
                log.info(f"Extracted CWE ID from NVD: {vulnerability_cwe_id}")
                cwe_list.append(vulnerability_cwe_id)
    return convert_list_to_string(cwe_list)


def get_sonarqube_cwe_ids(sonarqube_data: dict) -> list:
    """Get CWE IDs from SonarQube data

    :parameter
        sonarqube_data:dict -- SonarQube data to extract CWE IDs from

    :return
        list -- CWE IDs extracted from SonarQube data
    """
    cwe_ids = []
    sonarqube_fix_recommendations = get_json_value(sonarqube_data, "rule", "fixRecommendations").strip()
    if sonarqube_fix_recommendations is not default_not_found_value:
        # Extract CWE IDs from fix recommendations
        regex = re.compile(get_cwe_regex())
        cwe_list = regex.findall(sonarqube_fix_recommendations)
        cwe_ids = ["CWE-" + cwe_id for cwe_id in cwe_list]

        log.info(f"Extracted CWE IDs from SonarQube Hotspot: {cwe_ids}")
        return cwe_ids
    else:
        log.info("No CWE IDs found in SonarQube Hotspot")
        return cwe_ids


def get_component_from_purl(component_purl: str) -> dict:
    """Get component details from Package URL

    :parameter
        component_purl:str -- Package URL to extract component details from

    :return
        dict -- Component details extracted from Package URL
    """
    return PackageURL.from_string(component_purl).to_dict()


def clear_cwe_caches():
    """Clear CWE caches"""
    global cwe_name_cache
    global cwe_description_cache

    cwe_name_cache.clear()
    cwe_description_cache.clear()


def clear_cve_caches():
    """Clear CVE caches"""
    global cve_description_cache
    global cve_published_date_cache
    global cve_last_modified_date
    global cve_status_cache
    global cve_source_cache
    global cve_cvss_v2_vector_cache
    global cve_cvss_v3_vector_cache
    global cve_cvss_v4_vector_cache
    global cve_cwe_id_cache

    cve_description_cache.clear()
    cve_published_date_cache.clear()
    cve_last_modified_date.clear()
    cve_status_cache.clear()
    cve_source_cache.clear()
    cve_cvss_v2_vector_cache.clear()
    cve_cvss_v3_vector_cache.clear()
    cve_cvss_v4_vector_cache.clear()
    cve_cwe_id_cache.clear()


# ========================
# Data retrieval functions
# ========================
def get_github_repository_data(args: argparse.Namespace) -> dict:
    """Get GitHub repository data from GitHub API

    :param
        args:argparse.Namespace -- Parsed arguments supplied to script

    :return
        dict -- GitHub repository data from GitHub API
    """
    log.info(f"Retrieving GitHub repository data for {args.experiment_github_repository}")
    github_api_url = get_github_api_url(args.github_api_url, args.experiment_github_repository)
    github_data = send_github_get_request(github_api_url, args.github_api_token)
    if github_data:
        log.info(f"Successfully retrieved GitHub repository data for {args.experiment_github_repository}")
        return github_data.json()
    else:
        log.error(f"Failed to retrieve GitHub repository data for {args.experiment_github_repository}")
        sys.exit(1)


def get_codeql_data(args: argparse.Namespace) -> list:
    """Get CodeQL data from GitHub API

    :parameter
        args:argparse.Namespace -- Parsed arguments supplied to script

    :return
        list -- CodeQL data from GitHub API
    """
    log.info("Retrieving CodeQL data")
    github_api_url = get_github_api_url(args.github_api_url, args.experiment_github_repository, "code-scanning/alerts")
    codeql_data = send_github_get_request(github_api_url, args.github_api_token)
    if codeql_data:
        log.info("Successfully retrieved CodeQL data")
        # Removes any uni-block special characters in CodeQL data
        return json.loads(codeql_data.text.encode("raw-unicode-escape"))
    else:
        log.error("Failed to retrieve CodeQL data")
        sys.exit(1)


def get_deepsource_data(args: argparse.Namespace) -> list:
    """Get DeepSource data from DeepSource API

    :parameter
        args:argparse.Namespace -- Parsed arguments supplied to script

    :return
        list -- DeepSource data from DeepSource API
    """
    log.info("Retrieving DeepSource data")
    deepsource_api_url = "https://api.deepsource.io/graphql/"
    request_body = """
        query (
            $name: String!
            $login: String!
            $vcsProvider: VCSProvider!
        ) {
            repository(name: $name, login: $login, vcsProvider: $vcsProvider) {
                issues {
                    totalCount
                    edges {
                        node {
                            issue {
                                title
                                tags
                                shortcode
                                shortDescription
                                severity
                                isRecommended
                                id
                                description
                                category
                                autofixAvailable
                            }
                        }
                    }
                }
            }
        }
        """
    github_organisation_name = args.experiment_github_repository.split("/")[0]
    github_repository_name = args.experiment_github_repository.split("/")[1]
    request_variables = {"name": github_repository_name, "login": github_organisation_name, "vcsProvider": "GITHUB"}

    deepsource_data = send_deepsource_get_request(deepsource_api_url, args.deepsource_api_key, request_body, request_variables)
    if deepsource_data:
        log.info("Successfully retrieved DeepSource data")
        return deepsource_data.json()
    else:
        log.error("Failed to retrieve DeepSource data")
        sys.exit(1)


def get_dependabot_data(args: argparse.Namespace) -> list:
    """Get Dependabot data from GitHub API

    :parameter
        args:argparse.Namespace -- Parsed arguments supplied to script

    :return
        list -- Dependabot data from GitHub API
    """
    log.info("Retrieving Dependabot data")
    github_api_url = get_github_api_url(args.github_api_url, args.experiment_github_repository, "dependabot/alerts")
    dependabot_data = send_github_get_request(github_api_url, args.github_api_token)
    if dependabot_data:
        log.info("Successfully retrieved Dependabot data")
        return dependabot_data.json()
    else:
        log.error("Failed to retrieve Dependabot data")
        sys.exit(1)


def get_sonarqube_hotspots_search_data(args: argparse.Namespace) -> list:
    """Get SonarQube hotspots search data from SonarQube API

    :parameter
        args:argparse.Namespace -- Parsed arguments supplied to script

    :return
        list -- SonarQube data from SonarQube API
    """
    log.info("Retrieving SonarQube hotspots search data")
    sonarqube_api_url = f"{args.sonarqube_url}/api/hotspots/search?projectKey={args.sonarqube_project_key}"
    sonarqube_data = send_sonarqube_get_request(sonarqube_api_url, args.sonarqube_token)
    if sonarqube_data:
        log.info("Successfully retrieved SonarQube hotspots search data")
        return sonarqube_data.json()
    else:
        log.error("Failed to retrieve SonarQube hotspots search data")
        sys.exit(1)


def get_sonarqube_hotspots_show_data(sonarqube_url: str, sonarqube_token: str, hotspot_key: str) -> list:
    """Get SonarQube hotspots show data from SonarQube API

    :parameter
        sonarqube_url:str -- SonarQube URL
        sonarqube_token:str -- SonarQube token
        hotspot_key:str -- SonarQube hotspot key

    :return
        list -- SonarQube data from SonarQube API
    """
    log.info("Retrieving SonarQube hotspots show data")
    sonarqube_api_url = f"{sonarqube_url}/api/hotspots/show?hotspot={hotspot_key}"
    sonarqube_data = send_sonarqube_get_request(sonarqube_api_url, sonarqube_token)
    if sonarqube_data:
        log.info("Successfully retrieved SonarQube hotspots show data")
        return sonarqube_data.json()
    else:
        log.error("Failed to retrieve SonarQube hotspots show data")
        sys.exit(1)


def get_additional_cwe_details(security_testing_tool_name: str, cwe_id: str, opencve_username: str, opencve_password: str) -> str:
    """Get additional CWE details from OpenCVE

    :parameter
        security_testing_tool_name:str -- Tool name
        cwe_id:str -- CWE ID
        opencve_username:str -- OpenCVE username
        opencve_password:str -- OpenCVE password

    :return
        str -- CWE name and description
    """
    global cwe_name_cache
    global cwe_description_cache

    # Set default values
    vulnerability_cwe_name = default_not_found_value
    vulnerability_cwe_description = default_not_found_value

    if cwe_name_cache.get(cwe_id):
        log.info(f"Fetching additional CWE vulnerability details for {security_testing_tool_name} from cache: {cwe_id}")

        # Get CWE details from cache
        vulnerability_cwe_name = cwe_name_cache.get(cwe_id)
        vulnerability_cwe_description = cwe_description_cache.get(cwe_id)
    else:
        log.info(f"CWE vulnerability not in cache: {cwe_id}")
        log.info(f"Fetching additional CWE vulnerability details for {security_testing_tool_name} from OpenCVE: {cwe_id}")

        # Get CWE details from OpenCVE
        opencve_cwe_details = send_vulnerability_get_request(get_opencve_api_url(cwe_id), None, opencve_username, opencve_password)
        if opencve_cwe_details:
            opencve_details = opencve_cwe_details.json()
            vulnerability_cwe_name = get_json_value(opencve_details, "name")
            vulnerability_cwe_description = get_json_value(opencve_details, "description")
            vulnerability_cwe_description = vulnerability_cwe_description.strip()

            log.info(f"Fetched additional CWE vulnerability details for {security_testing_tool_name} from OpenCVE: {cwe_id}")
        else:
            log.error(f"Failed to fetch additional CWE vulnerability details for {security_testing_tool_name} from OpenCVE: {cwe_id}")

        # Cache CWE details
        cwe_name_cache.set(cwe_id, vulnerability_cwe_name)
        cwe_description_cache.set(cwe_id, vulnerability_cwe_description)

    return vulnerability_cwe_name, vulnerability_cwe_description


def get_severity_alias(severity: str) -> str:
    """Get severity alias for Semgrep and DeepSource

    :parameter
        severity:str -- Severity level

    :return
        str -- Severity alias
    """
    if severity.upper() == "ERROR" or severity.upper() == "MAJOR":
        return "High"
    elif severity.upper() == "WARNING":
        return "Medium"
    elif severity.upper() == "INFO" or severity.upper() == "MINOR":
        return "Low"
    else:
        return severity


# ======================
# Parsing data functions
# ======================
def parse_codeql_data(
    args: argparse.Namespace,
    experiment_information: list,
    codeql_data: list,
) -> None:
    """Parse CodeQL data and write data to output file

    :param
        args:argparse.Namespace -- Parsed arguments supplied to script
        experiment_information:list -- Experiment information
        codeql_data:list -- CodeQL data to parse
    """
    log.info("Parsing CodeQL data")
    csv_rows = []

    try:
        # Check if vulnerabilities exist in report
        if codeql_data is None or len(codeql_data) == 0:
            log.info("No CWE vulnerabilities found in CodeQL data")
        else:
            security_testing_tool_name = "CodeQL"
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Iterate through all vulnerabilities
            for vulnerability in codeql_data:
                security_testing_tool_cli_version = get_json_value(vulnerability, "tool", "version")

                vulnerability_severity = get_json_value(vulnerability, "rule", "security_severity_level")
                vulnerability_rule_id = get_json_value(vulnerability, "rule", "id")
                vulnerability_file = get_json_value(vulnerability, "most_recent_instance", "location", "path")
                vulnerability_line = get_json_value(vulnerability, "most_recent_instance", "location", "start_line")
                vulnerability_main_source_code = get_vulnerability_main_source_code(vulnerability_file)

                for tag in vulnerability["rule"]["tags"]:
                    # Only consider vulnerabilities with CWE ID
                    match = re.search(get_cwe_regex(), tag.upper())
                    if match:
                        vulnerability_cwe_id = match.group(0).upper()
                        # CodeQL bug: Some CVE IDs contain leading zero
                        if vulnerability_cwe_id.startswith("CWE-0"):
                            vulnerability_cwe_id = vulnerability_cwe_id.replace("CWE-0", "CWE-")
                        log.info(f"Fetching CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                        vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                        vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                        # Get additional CWE details from OpenCVE
                        vulnerability_cwe_name, vulnerability_cwe_description = get_additional_cwe_details(
                            security_testing_tool_name, vulnerability_cwe_id, args.opencve_username, args.opencve_password
                        )

                        vulnerability_results_data = experiment_information + [
                            security_testing_tool_category,
                            security_testing_tool_type,
                            security_testing_tool_name,
                            security_testing_tool_classification,
                            security_testing_tool_cli_version.lstrip("v"),
                            args.experiment_programming_language.title(),
                            vulnerability_severity.title(),
                            default_not_applicable_value,
                            vulnerability_cwe_id,
                            vulnerability_cwe_name,
                            vulnerability_cwe_description,
                            default_not_applicable_value,
                            default_not_applicable_value,
                            vulnerability_owasp_top_10,
                            vulnerability_mitre_top_25,
                            vulnerability_rule_id,
                            vulnerability_file,
                            vulnerability_line,
                            vulnerability_main_source_code,
                        ]
                        log.info(f"Fetched all CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                        # Add vulnerability data to CSV row
                        csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sast_codeql_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse CodeQL data: {e}")
        sys.exit(1)
    else:
        log.info("Successfully parsed CodeQL data")
    return None


def parse_deepsource_data(
    args: argparse.Namespace,
    experiment_information: list,
    deepsource_data: list,
) -> None:
    """Parse DeepSource data and write data to output file

    :param
        args:argparse.Namespace -- Parsed arguments supplied to script
        experiment_information:list -- Experiment information
        deepsource_data:list -- DeepSource data to parse
    """
    log.info("Parsing DeepSource data")
    csv_rows = []

    try:
        deepsource_issues = deepsource_data["data"]["repository"]["issues"]

        # Check if vulnerabilities exist in report
        if deepsource_issues["totalCount"] == 0:
            log.info("No CWE vulnerabilities found in DeepSource data")
        else:
            security_testing_tool_name = "DeepSource"
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Iterate through all vulnerabilities
            for deepsource_edge in deepsource_issues["edges"]:
                deepsource_edge_issue = deepsource_edge["node"]["issue"]

                vulnerability_severity_alias = get_json_value(deepsource_edge_issue, "severity")
                vulnerability_severity = get_severity_alias(vulnerability_severity_alias)

                vulnerability_rule_id = get_json_value(deepsource_edge_issue, "id")

                for tag in deepsource_edge_issue["tags"]:
                    # Only consider vulnerabilities with CWE ID
                    if "CWE-" in tag.upper():
                        vulnerability_cwe_id = tag.upper()
                        log.info(f"Fetching CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                        vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                        vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                        # Get additional CWE details from OpenCVE
                        vulnerability_cwe_name, vulnerability_cwe_description = get_additional_cwe_details(
                            security_testing_tool_name, vulnerability_cwe_id, args.opencve_username, args.opencve_password
                        )

                        vulnerability_results_data = experiment_information + [
                            security_testing_tool_category,
                            security_testing_tool_type,
                            security_testing_tool_name,
                            security_testing_tool_classification,
                            default_not_applicable_value,
                            args.experiment_programming_language.title(),
                            vulnerability_severity.title(),
                            default_not_applicable_value,
                            vulnerability_cwe_id,
                            vulnerability_cwe_name,
                            vulnerability_cwe_description,
                            default_not_applicable_value,
                            default_not_applicable_value,
                            vulnerability_owasp_top_10,
                            vulnerability_mitre_top_25,
                            vulnerability_rule_id,
                            default_manual_review_value,
                            default_manual_review_value,
                            default_manual_review_value,
                        ]
                        log.info(f"Fetched all CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                        # Add vulnerability data to CSV row
                        csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sast_deepsource_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse DeepSource data: {e}")
        sys.exit(1)
    else:
        log.info("Successfully parsed DeepSource data")
    return None


def parse_horusec_data(
    args: argparse.Namespace,
    experiment_information: list,
) -> None:
    """Parse Horusec SAST JSON report and write data to output file

    :parameter
        args: argparse.Namespace -- Parsed arguments supplied to script
        experiment_information: list -- Experiment information
    """
    log.info(f"Parsing Horusec report: {args.sast_horusec_report_filename}")
    with open(args.sast_horusec_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    try:
        # Check if vulnerabilities exist in report
        if data["analysisVulnerabilities"] is None or len(data["analysisVulnerabilities"]) == 0:
            log.info(f"No CWE vulnerabilities found in Horusec report: {args.sast_horusec_report_filename}")
        else:
            security_testing_tool_name = "Horusec"
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Iterate through all vulnerabilities
            for analysis in data["analysisVulnerabilities"]:
                vulnerability = analysis["vulnerabilities"]
                vulnerability_details = get_json_value(vulnerability, "details")

                security_testing_tool_cli_version = get_json_value(data, "version")

                # Only consider vulnerabilities with CWE ID
                match = re.search(get_cwe_regex(), vulnerability_details)
                if match:
                    vulnerability_cwe_id = match.group(0).upper()
                    log.info(f"Fetching CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")
                    vulnerability_severity = get_json_value(vulnerability, "severity")
                    vulnerability_confidence = get_json_value(vulnerability, "confidence")
                    vulnerability_rule_id = get_json_value(vulnerability, "rule_id")
                    vulnerability_file = get_json_value(vulnerability, "file")
                    vulnerability_line = get_json_value(vulnerability, "line")
                    vulnerability_main_source_code = get_vulnerability_main_source_code(vulnerability_file)

                    vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                    vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                    # Get additional CWE details from OpenCVE
                    vulnerability_cwe_name, vulnerability_cwe_description = get_additional_cwe_details(
                        security_testing_tool_name, vulnerability_cwe_id, args.opencve_username, args.opencve_password
                    )

                    vulnerability_results_data = experiment_information + [
                        security_testing_tool_category,
                        security_testing_tool_type,
                        security_testing_tool_name,
                        security_testing_tool_classification,
                        security_testing_tool_cli_version.lstrip("v"),
                        args.experiment_programming_language.title(),
                        vulnerability_severity.title(),
                        vulnerability_confidence.title(),
                        vulnerability_cwe_id,
                        vulnerability_cwe_name,
                        vulnerability_cwe_description,
                        default_not_applicable_value,
                        default_not_applicable_value,
                        vulnerability_owasp_top_10,
                        vulnerability_mitre_top_25,
                        vulnerability_rule_id,
                        vulnerability_file,
                        vulnerability_line,
                        vulnerability_main_source_code,
                    ]
                    log.info(f"Fetched all CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                    # Add vulnerability data to CSV row
                    csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sast_horusec_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Horusec report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed Horusec report: {args.sast_horusec_report_filename}")
    return None


def parse_semgrep_data(
    args: argparse.Namespace,
    experiment_information: list,
) -> None:
    """Parse Semgrep SAST JSON report and write data to output file

    :parameter
        args: argparse.Namespace -- Parsed arguments supplied to script
        experiment_information: list -- Experiment information
    """
    log.info(f"Parsing Semgrep report: {args.sast_semgrep_report_filename}")
    with open(args.sast_semgrep_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    try:
        # Check if vulnerabilities exist in report
        if data["results"] is None or len(data["results"]) == 0:
            log.info(f"No CWE vulnerabilities found in Semgrep report: {args.sast_semgrep_report_filename}")
        else:
            security_testing_tool_name = "Semgrep"
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_cli_version = get_json_value(data, "version")
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Iterate through all vulnerabilities
            for vulnerability in data["results"]:
                vulnerability_metadata = get_json_value(vulnerability, "extra", "metadata")
                for vulnerability_cwe_id in vulnerability_metadata["cwe"]:
                    match = re.search(get_cwe_regex(), vulnerability_cwe_id)
                    if match:
                        vulnerability_cwe_id = match.group(0).upper()
                        log.info(f"Fetching CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                        vulnerability_severity_alias = get_json_value(vulnerability, "extra", "severity")
                        vulnerability_severity = get_severity_alias(vulnerability_severity_alias)

                        vulnerability_file = get_json_value(vulnerability, "path")
                        vulnerability_line = get_json_value(vulnerability, "start", "line")
                        vulnerability_main_source_code = get_vulnerability_main_source_code(vulnerability_file)

                        vulnerability_confidence = get_json_value(vulnerability_metadata, "confidence")
                        vulnerability_rule_id = get_json_value(vulnerability_metadata, "semgrep.dev", "rule", "rule_id")
                        vulnerability_impact = get_json_value(vulnerability_metadata, "impact", None, None)
                        vulnerability_likelihood = get_json_value(vulnerability_metadata, "likelihood", None, None)

                        vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                        vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                        # Get additional CWE details from OpenCVE
                        vulnerability_cwe_name, vulnerability_cwe_description = get_additional_cwe_details(
                            security_testing_tool_name, vulnerability_cwe_id, args.opencve_username, args.opencve_password
                        )

                        vulnerability_results_data = experiment_information + [
                            security_testing_tool_category,
                            security_testing_tool_type,
                            security_testing_tool_name,
                            security_testing_tool_classification,
                            security_testing_tool_cli_version.lstrip("v"),
                            args.experiment_programming_language.title(),
                            vulnerability_severity.title(),
                            vulnerability_confidence.title(),
                            vulnerability_cwe_id,
                            vulnerability_cwe_name,
                            vulnerability_cwe_description,
                            vulnerability_impact.title(),
                            vulnerability_likelihood.title(),
                            vulnerability_owasp_top_10,
                            vulnerability_mitre_top_25,
                            vulnerability_rule_id,
                            vulnerability_file,
                            vulnerability_line,
                            vulnerability_main_source_code,
                        ]
                        log.info(f"Fetched all CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                        # Add vulnerability data to CSV row
                        csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sast_semgrep_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Semgrep report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed Semgrep report: {args.sast_semgrep_report_filename}")
    return None


def parse_snyk_code_data(
    args: argparse.Namespace,
    experiment_information: list,
) -> None:
    """Parse Snyk Code SAST JSON report and write data to output file

    :parameter
        args: argparse.Namespace -- Parsed arguments supplied to script
        experiment_information: list -- Experiment information
    """
    log.info(f"Parsing Snyk Code report: {args.sast_snyk_code_report_filename}")
    with open(args.sast_snyk_code_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    try:
        report_runs = data["runs"][0]
        report_rules = get_json_value(report_runs, "tool", "driver", "rules")
        report_results = get_json_value(report_runs, "results")

        # Check if vulnerabilities exist in report
        if len(report_runs["results"]) == 0:
            log.info(f"No CWE vulnerabilities found in Snyk Code report: {args.sast_snyk_code_report_filename}")
        else:
            # Get tool details
            security_testing_tool_name = "Snyk Code"
            security_testing_tool_cli_version = get_json_value(data, "version")
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Iterate through all vulnerabilities
            for vulnerability_rule in report_rules:
                vulnerability_rule_id = get_json_value(vulnerability_rule, "id")
                vulnerability_rule_property = vulnerability_rule["properties"]
                vulnerability_confidence = get_json_value(vulnerability_rule_property, "precision")

                # Iterate over each CWE ID
                for vulnerability_cwe_id in vulnerability_rule_property["cwe"]:
                    vulnerability_cwe_id = vulnerability_cwe_id.upper()
                    log.info(f"Fetching CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                    vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                    vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                    # Get additional CWE details from OpenCVE
                    vulnerability_cwe_name, vulnerability_cwe_description = get_additional_cwe_details(
                        security_testing_tool_name, vulnerability_cwe_id, args.opencve_username, args.opencve_password
                    )

                    # Iterate over results for each CWE
                    for vulnerability_result in report_results:
                        if vulnerability_rule_id == get_json_value(vulnerability_result, "ruleId"):
                            log.info(
                                f"Found CWE vulnerability result for {security_testing_tool_name} with rule ID: {vulnerability_rule_id}"
                            )

                            vulnerability_severity = get_snyk_code_severity_levels(get_json_value(vulnerability_result, "level"))
                            vulnerability_locations = get_json_value(vulnerability_result, "locations")[0]

                            vulnerability_file = get_json_value(vulnerability_locations, "physicalLocation", "artifactLocation", "uri")
                            vulnerability_line = get_json_value(vulnerability_locations, "physicalLocation", "region", "startLine")
                            vulnerability_main_source_code = get_vulnerability_main_source_code(vulnerability_file)

                            vulnerability_results_data = experiment_information + [
                                security_testing_tool_category,
                                security_testing_tool_type,
                                security_testing_tool_name,
                                security_testing_tool_classification,
                                security_testing_tool_cli_version.lstrip("v"),
                                args.experiment_programming_language.title(),
                                vulnerability_severity.title(),
                                vulnerability_confidence.title(),
                                vulnerability_cwe_id,
                                vulnerability_cwe_name,
                                vulnerability_cwe_description,
                                default_not_applicable_value,
                                default_not_applicable_value,
                                vulnerability_owasp_top_10,
                                vulnerability_mitre_top_25,
                                vulnerability_rule_id,
                                vulnerability_file,
                                vulnerability_line,
                                vulnerability_main_source_code,
                            ]
                            log.info(f"Fetched all CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                            # Add vulnerability data to CSV row
                            csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sast_snyk_code_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Snyk Code report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed Snyk Code report: {args.sast_snyk_code_report_filename}")
    return None


def parse_sonarqube_data(
    args: argparse.Namespace,
    experiment_information: list,
    sonarqube_data: str,
) -> None:
    """Parse SonarQube data and write data to output file

    :parameter
        args: argparse.Namespace -- Parsed arguments supplied to script
        experiment_information: list -- Experiment information
        sonarqube_data:str -- SonarQube data to parse
    """
    log.info("Parsing SonarQube data")
    csv_rows = []

    try:
        # Check if vulnerabilities exist in report
        if sonarqube_data is None or sonarqube_data["paging"]["total"] == 0:
            log.info("No CWE vulnerabilities found in SonarQube data")
        else:
            security_testing_tool_name = "SonarQube"
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # See https://github.com/SonarSource/sonarqube-scan-action/blob/8c8682dac7c144ee82da08feadfd0b169522397e/Dockerfile#L1
            security_testing_tool_cli_version = "5.0.1.3006"

            # Iterate through all hotspots
            for sonarqube_hotspot in sonarqube_data["hotspots"]:
                sonarqube_hotspot_key = get_json_value(sonarqube_hotspot, "key")

                # Get hotspot details
                sonarqube_hotspot_show_data = get_sonarqube_hotspots_show_data(
                    args.sonarqube_url, args.sonarqube_token, sonarqube_hotspot_key
                )

                # Only consider vulnerabilities with CWE ID
                vulnerability_cwe_ids = get_sonarqube_cwe_ids(sonarqube_hotspot_show_data)

                for vulnerability_cwe_id in vulnerability_cwe_ids:
                    vulnerability_cwe_id = vulnerability_cwe_id.upper()
                    log.info(f"Fetching CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                    vulnerability_severity = get_json_value(sonarqube_hotspot_show_data, "rule", "vulnerabilityProbability")
                    vulnerability_rule_id = get_json_value(sonarqube_hotspot_show_data, "rule", "key")
                    vulnerability_file = get_json_value(sonarqube_hotspot_show_data, "component", "path")
                    vulnerability_line = get_json_value(sonarqube_hotspot_show_data, "line")
                    vulnerability_main_source_code = get_vulnerability_main_source_code(vulnerability_file)

                    vulnerability_owasp_top_10 = search_owasp_top_10(vulnerability_cwe_id)
                    vulnerability_mitre_top_25 = search_mitre_top_25(vulnerability_cwe_id)

                    # Get additional CWE details from OpenCVE
                    vulnerability_cwe_name, vulnerability_cwe_description = get_additional_cwe_details(
                        security_testing_tool_name, vulnerability_cwe_id, args.opencve_username, args.opencve_password
                    )

                    vulnerability_results_data = experiment_information + [
                        security_testing_tool_category,
                        security_testing_tool_type,
                        security_testing_tool_name,
                        security_testing_tool_classification,
                        security_testing_tool_cli_version,
                        args.experiment_programming_language.title(),
                        vulnerability_severity.title(),
                        default_not_applicable_value,
                        vulnerability_cwe_id,
                        vulnerability_cwe_name,
                        vulnerability_cwe_description,
                        default_not_applicable_value,
                        default_not_applicable_value,
                        vulnerability_owasp_top_10,
                        vulnerability_mitre_top_25,
                        vulnerability_rule_id,
                        vulnerability_file,
                        vulnerability_line,
                        vulnerability_main_source_code,
                    ]
                    log.info(f"Fetched all CWE vulnerability details for {security_testing_tool_name}: {vulnerability_cwe_id}")

                    # Add vulnerability data to CSV row
                    csv_rows.append(vulnerability_results_data)
            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sast_sonarqube_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse SonarQube data: {e}")
        sys.exit(1)
    else:
        log.info("Successfully parsed SonarQube data")
    return None


def parse_dependabot_data(
    args: argparse.Namespace,
    experiment_information: list,
    dependabot_data: list,
) -> None:
    """Parse Dependabot data and write data to output file

    :parameter
        args: argparse.Namespace -- Parsed arguments supplied to script
        experiment_information: list -- Experiment information
        dependabot_data:list -- Dependabot data to parse
    """
    log.info("Parsing Dependabot data")
    csv_rows = []

    # Set globals
    global cve_published_date_cache
    global cve_last_modified_date
    global cve_status_cache
    global cve_source_cache
    global cve_cvss_v2_vector_cache
    global cve_cvss_v3_vector_cache
    global cve_cvss_v4_vector_cache

    try:
        if dependabot_data is None or len(dependabot_data) == 0:
            log.info("No CVE vulnerabilities found in Dependabot data")
        else:
            security_testing_tool_name = "Dependabot"
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Iterate through all vulnerabilities
            for vulnerability in dependabot_data:
                vulnerability_cve_id = get_json_value(vulnerability, "security_advisory", "cve_id")

                # Only consider vulnerabilities with CVE ID
                if vulnerability_cve_id != default_not_found_value:
                    log.info(f"Fetching CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")

                    vulnerability_security = get_json_value(vulnerability, "security_vulnerability")
                    vulnerability_severity = get_json_value(vulnerability_security, "severity")

                    # Get Component details
                    vulnerability_component_type = get_json_value(vulnerability_security, "package", "ecosystem")
                    vulnerability_component_name = get_json_value(vulnerability_security, "package", "name")
                    vulnerability_component_version = get_json_value(vulnerability_security, "vulnerable_version_range")
                    vulnerability_component_location = get_json_value(vulnerability, "dependency", "manifest_path")

                    # Get CVE details
                    vulnerability_cve_description = get_json_value(vulnerability, "security_advisory", "summary")
                    vulnerability_cve_description = vulnerability_cve_description.strip()

                    # Get CWE IDs
                    cwe_ids = []
                    if len(vulnerability["security_advisory"]["cwes"]) > 0:
                        vulnerability_cwe_ids = get_json_value(vulnerability, "security_advisory", "cwes")
                        for cwe in vulnerability_cwe_ids:
                            cwe_id = cwe["cwe_id"]
                            cwe_ids.append(cwe_id.upper())
                        vulnerability_cwe_id = convert_list_to_string(cwe_ids)
                    else:
                        vulnerability_cwe_id = default_not_found_value

                    # Set default values
                    vulnerability_cve_published_date = default_not_found_value
                    vulnerability_cve_last_modified_date = default_not_found_value
                    vulnerability_cve_source = default_not_found_value
                    vulnerability_cve_status = default_not_found_value
                    vulnerability_cve_cvss_v2_vector = default_not_found_value
                    vulnerability_cve_cvss_v3_vector = default_not_found_value
                    vulnerability_cve_cvss_v4_vector = default_not_found_value

                    if cve_published_date_cache.get(vulnerability_cve_id):
                        log.info(
                            f"Fetching additional CVE vulnerability details for {security_testing_tool_name} from cache: {vulnerability_cve_id}"
                        )

                        # Get CVE details from cache
                        vulnerability_cve_published_date = cve_published_date_cache.get(vulnerability_cve_id)
                        vulnerability_cve_last_modified_date = cve_last_modified_date.get(vulnerability_cve_id)
                        vulnerability_cve_source = cve_source_cache.get(vulnerability_cve_id)
                        vulnerability_cve_status = cve_status_cache.get(vulnerability_cve_id)
                        vulnerability_cve_cvss_v2_vector = cve_cvss_v2_vector_cache.get(vulnerability_cve_id)
                        vulnerability_cve_cvss_v3_vector = cve_cvss_v3_vector_cache.get(vulnerability_cve_id)
                        vulnerability_cve_cvss_v4_vector = cve_cvss_v4_vector_cache.get(vulnerability_cve_id)
                    else:
                        log.info(f"CVE vulnerability not in cache: {vulnerability_cve_id}")
                        log.info(
                            f"Fetching additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}"
                        )

                        # Get additional CVE details from NVD
                        nvd_response = send_vulnerability_get_request(get_nvd_api_url(vulnerability_cve_id), args.nvd_api_key)
                        if nvd_response:
                            nvd_details = nvd_response.json()
                            if nvd_details["totalResults"] > 0:
                                nvd_cve_details = nvd_details["vulnerabilities"][0]

                                vulnerability_cve_published_date = get_json_value(nvd_cve_details, "cve", "published")
                                vulnerability_cve_last_modified_date = get_json_value(nvd_cve_details, "cve", "lastModified")
                                vulnerability_cve_status = get_json_value(nvd_cve_details, "cve", "vulnStatus")
                                vulnerability_cve_source = get_json_value(nvd_cve_details, "cve", "sourceIdentifier")

                                # Get CVSS vectors
                                vulnerability_cve_metrics = get_json_value(nvd_cve_details, "cve", "metrics")
                                vulnerability_cve_cvss_v2_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "2.0")
                                vulnerability_cve_cvss_v3_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "3.1")
                                if vulnerability_cve_cvss_v3_vector == default_not_found_value:
                                    vulnerability_cve_cvss_v3_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "3.0")
                                vulnerability_cve_cvss_v4_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "4.0")

                                log.info(
                                    f"Fetched additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_status}"
                                )
                            else:
                                log.info(
                                    f"No additional CVE vulnerability details for {security_testing_tool_name} found in NVD: {vulnerability_cve_id}"
                                )
                        else:
                            log.error(
                                f"Failed to fetch additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}"
                            )

                        # Cache CVE details
                        cve_published_date_cache.set(vulnerability_cve_id, vulnerability_cve_published_date)
                        cve_last_modified_date.set(vulnerability_cve_id, vulnerability_cve_last_modified_date)
                        cve_status_cache.set(vulnerability_cve_id, vulnerability_cve_status)
                        cve_source_cache.set(vulnerability_cve_id, vulnerability_cve_source)
                        cve_cvss_v2_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v2_vector)
                        cve_cvss_v3_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v3_vector)
                        cve_cvss_v4_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v4_vector)

                    vulnerability_results_data = experiment_information + [
                        security_testing_tool_category,
                        security_testing_tool_type,
                        security_testing_tool_name,
                        security_testing_tool_classification,
                        default_not_applicable_value,
                        args.experiment_programming_language.title(),
                        vulnerability_severity.title(),
                        default_not_applicable_value,
                        vulnerability_component_type.title(),
                        vulnerability_component_name,
                        vulnerability_component_version,
                        default_not_applicable_value,
                        default_not_applicable_value,
                        vulnerability_component_location,
                        vulnerability_cve_id.upper(),
                        remove_new_lines_from_cve_description(vulnerability_cve_description),
                        vulnerability_cve_source,
                        vulnerability_cve_published_date,
                        vulnerability_cve_last_modified_date,
                        vulnerability_cve_status.title(),
                        default_not_applicable_value,
                        default_not_applicable_value,
                        vulnerability_cve_cvss_v2_vector,
                        vulnerability_cve_cvss_v3_vector,
                        vulnerability_cve_cvss_v4_vector,
                        vulnerability_cwe_id,
                    ]
                    log.info(f"Fetched all CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")

                    # Add vulnerability data to CSV row
                    csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sca_dependabot_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Dependabot data: {e}")
        sys.exit(1)
    else:
        log.info("Successfully parsed Dependabot data")

    # Cleanup CVE caches
    clear_cve_caches()
    return None


def parse_eclipse_steady_data(
    args: argparse.Namespace,
    experiment_information: list,
) -> None:
    """Parse Eclipse Steady SCA JSON report and write data to output file

    :parameter
        args: argparse.Namespace -- Parsed arguments supplied to script
        experiment_information: list -- Experiment information
    """
    log.info(f"Parsing Eclipse Steady report: {args.sca_eclipse_steady_report_filename}")
    with open(args.sca_eclipse_steady_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cve_description_cache
    global cve_published_date_cache
    global cve_last_modified_date
    global cve_status_cache
    global cve_source_cache
    global cve_cvss_v2_vector_cache
    global cve_cvss_v3_vector_cache
    global cve_cvss_v4_vector_cache
    global cve_cwe_id_cache

    try:
        if len(data["vulasReport"]["vulnerabilities"]) == 0:
            log.info(f"No CVE vulnerabilities found in Eclipse Steady report: {args.sca_eclipse_steady_report_filename}")
        else:
            security_testing_tool_name = "Eclipse Steady"
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Pinned in Eclipse Steady GitHub Action
            security_testing_tool_cli_version = "3.2.5"

            # Iterate through all vulnerabilities
            vulnerabilities = get_json_value(data, "vulasReport", "vulnerabilities")
            for vulnerability in vulnerabilities:
                vulnerability_cve_id = get_json_value(vulnerability, "bug", "id")
                if "CVE" in vulnerability_cve_id:
                    log.info(f"Fetching CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")

                    # Get Component details
                    vulnerability_component_details = get_json_value(vulnerability, "filename")
                    vulnerability_component = vulnerability_component_details.rsplit(".", 1)[0]
                    vulnerability_component_name = vulnerability_component.rsplit("-", 1)[0]
                    vulnerability_component_version = vulnerability_component.rpartition("-")[-1]

                    # Set default values
                    vulnerability_cve_description = default_not_found_value
                    vulnerability_cve_published_date = default_not_found_value
                    vulnerability_cve_last_modified_date = default_not_found_value
                    vulnerability_cve_source = default_not_found_value
                    vulnerability_cve_status = default_not_found_value
                    vulnerability_cve_cvss_v2_vector = default_not_found_value
                    vulnerability_cve_cvss_v3_vector = default_not_found_value
                    vulnerability_cve_cvss_v4_vector = default_not_found_value
                    vulnerability_cwe_id = default_not_found_value

                    if cve_published_date_cache.get(vulnerability_cve_id):
                        log.info(
                            f"Fetching additional CVE vulnerability details for {security_testing_tool_name} from cache: {vulnerability_cve_id}"
                        )

                        # Get CVE details from cache
                        vulnerability_cve_description = cve_description_cache.get(vulnerability_cve_id)
                        vulnerability_cve_published_date = cve_published_date_cache.get(vulnerability_cve_id)
                        vulnerability_cve_last_modified_date = cve_last_modified_date.get(vulnerability_cve_id)
                        vulnerability_cve_source = cve_source_cache.get(vulnerability_cve_id)
                        vulnerability_cve_status = cve_status_cache.get(vulnerability_cve_id)
                        vulnerability_cve_cvss_v2_vector = cve_cvss_v2_vector_cache.get(vulnerability_cve_id)
                        vulnerability_cve_cvss_v3_vector = cve_cvss_v3_vector_cache.get(vulnerability_cve_id)
                        vulnerability_cve_cvss_v4_vector = cve_cvss_v4_vector_cache.get(vulnerability_cve_id)
                        vulnerability_cwe_id = cve_cwe_id_cache.get(vulnerability_cve_id)
                    else:
                        log.info(f"CVE vulnerability not in cache: {vulnerability_cve_id}")
                        log.info(
                            f"Fetching additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}"
                        )

                        # Get additional CVE details from NVD
                        nvd_response = send_vulnerability_get_request(get_nvd_api_url(vulnerability_cve_id), args.nvd_api_key)
                        if nvd_response:
                            nvd_details = nvd_response.json()
                            if nvd_details["totalResults"] > 0:
                                nvd_cve_details = nvd_details["vulnerabilities"][0]

                                for description in nvd_cve_details["cve"]["descriptions"]:
                                    description_language = get_json_value(description, "lang")
                                    if description_language.upper() == "EN":
                                        vulnerability_cve_description = get_json_value(description, "value")
                                        vulnerability_cve_description = vulnerability_cve_description.strip()
                                        break

                                vulnerability_cve_published_date = get_json_value(nvd_cve_details, "cve", "published")
                                vulnerability_cve_last_modified_date = get_json_value(nvd_cve_details, "cve", "lastModified")
                                vulnerability_cve_status = get_json_value(nvd_cve_details, "cve", "vulnStatus")
                                vulnerability_cve_source = get_json_value(nvd_cve_details, "cve", "sourceIdentifier")

                                # Get CVSS vectors
                                vulnerability_cve_metrics = get_json_value(nvd_cve_details, "cve", "metrics")
                                vulnerability_cve_cvss_v2_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "2.0")
                                vulnerability_cve_cvss_v3_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "3.1")
                                if vulnerability_cve_cvss_v3_vector == default_not_found_value:
                                    vulnerability_cve_cvss_v3_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "3.0")
                                vulnerability_cve_cvss_v4_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "4.0")

                                # Eclipse Steady does not provide CWEs associated with the CVE ID, so we need to extract it from NVD
                                vulnerability_cwe_id = get_cwe_from_nvd(nvd_cve_details)
                                log.info(
                                    f"Fetched additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_status}"
                                )
                            else:
                                log.info(
                                    f"No additional CVE vulnerability details for {security_testing_tool_name} found in NVD: {vulnerability_cve_id}"
                                )
                        else:
                            log.error(
                                f"Failed to fetch additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}"
                            )

                        # Cache CVE details
                        cve_description_cache.set(vulnerability_cve_id, vulnerability_cve_description)
                        cve_published_date_cache.set(vulnerability_cve_id, vulnerability_cve_published_date)
                        cve_last_modified_date.set(vulnerability_cve_id, vulnerability_cve_last_modified_date)
                        cve_status_cache.set(vulnerability_cve_id, vulnerability_cve_status)
                        cve_source_cache.set(vulnerability_cve_id, vulnerability_cve_source)
                        cve_cvss_v2_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v2_vector)
                        cve_cvss_v3_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v3_vector)
                        cve_cvss_v4_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v4_vector)
                        cve_cwe_id_cache.set(vulnerability_cve_id, vulnerability_cwe_id)

                    vulnerability_results_data = experiment_information + [
                        security_testing_tool_category,
                        security_testing_tool_type,
                        security_testing_tool_name,
                        security_testing_tool_classification,
                        security_testing_tool_cli_version,
                        args.experiment_programming_language.title(),
                        default_not_applicable_value,
                        default_not_applicable_value,
                        default_not_applicable_value,
                        vulnerability_component_name,
                        vulnerability_component_version,
                        default_not_applicable_value,
                        default_not_applicable_value,
                        default_not_applicable_value,
                        vulnerability_cve_id.upper(),
                        vulnerability_cve_description,
                        vulnerability_cve_source,
                        vulnerability_cve_published_date,
                        vulnerability_cve_last_modified_date,
                        vulnerability_cve_status.title(),
                        default_not_applicable_value,
                        default_not_applicable_value,
                        vulnerability_cve_cvss_v2_vector,
                        vulnerability_cve_cvss_v3_vector,
                        vulnerability_cve_cvss_v4_vector,
                        vulnerability_cwe_id,
                    ]
                    log.info(f"Fetched all CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")

                    # Add vulnerability data to CSV row
                    csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sca_eclipse_steady_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Eclipse Steady report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed Eclipse Steady report: {args.sca_eclipse_steady_report_filename}")

    # Cleanup CVE caches
    clear_cve_caches()
    return None


def parse_grype_data(
    args: argparse.Namespace,
    experiment_information: list,
) -> None:
    """Parse Grype SCA JSON report and write data to output file

    :parameter
        args: argparse.Namespace -- Parsed arguments supplied to script
        experiment_information: list -- Experiment information
    """
    log.info(f"Parsing Grype report: {args.sca_grype_report_filename}")
    with open(args.sca_grype_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cve_published_date_cache
    global cve_last_modified_date
    global cve_cwe_id_cache

    try:
        # Check if vulnerabilities exist in report
        if data["matches"] is None or len(data["matches"]) == 0:
            log.info(f"No CVE vulnerabilities found in Grype report: {args.sca_grype_report_filename}")
        else:
            security_testing_tool_name = get_json_value(data, "descriptor", "name").title()
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_cli_version = get_json_value(data, "descriptor", "version")
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Iterate through all vulnerabilities
            for vulnerability_index in data["matches"]:
                vulnerability = get_json_value(vulnerability_index, "vulnerability")

                # Only consider vulnerabilities with CVE ID
                vulnerability_cve_id = get_json_value(vulnerability, "id")
                if "CVE" in vulnerability_cve_id:
                    log.info(f"Fetching CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")

                    vulnerability_severity = get_json_value(vulnerability, "severity")

                    # Get Component details
                    vulnerability_component_purl = get_json_value(vulnerability_index, "artifact", "purl")
                    vulnerability_component_details = get_component_from_purl(vulnerability_component_purl)
                    vulnerability_component_type = vulnerability_component_details["type"]
                    vulnerability_component_name = vulnerability_component_details["name"]
                    vulnerability_component_version = vulnerability_component_details["version"]

                    # Convert list to comma-separated string
                    vulnerability_component_licenses = get_json_value(vulnerability_index, "artifact", "licenses")
                    vulnerability_component_license = convert_list_to_string(vulnerability_component_licenses)

                    # Get first uppermost path location
                    vulnerability_component_locations = get_json_value(vulnerability_index, "artifact", "locations")
                    vulnerability_component_location = vulnerability_component_locations[0]["path"]

                    # Get CVE details
                    vulnerability_cve_description = get_json_value(vulnerability_index, "description")
                    vulnerability_cve_description = vulnerability_cve_description.strip()
                    vulnerability_cve_source = get_json_value(vulnerability_index, "namespace")
                    vulnerability_cve_status = get_json_value(vulnerability_index, "fix", "state")

                    # Get CVSS vectors
                    vulnerability_cve_cvss_v2_vector = get_grype_cvss_vector(vulnerability, "2.0")
                    vulnerability_cve_cvss_v3_vector = get_grype_cvss_vector(vulnerability, "3.1", "3.0")
                    vulnerability_cve_cvss_v4_vector = get_grype_cvss_vector(vulnerability, "4.0")

                    # Set default values
                    vulnerability_cve_published_date = default_not_found_value
                    vulnerability_cve_last_modified_date = default_not_found_value
                    vulnerability_cwe_id = default_not_found_value

                    if cve_published_date_cache.get(vulnerability_cve_id):
                        log.info(
                            f"Fetching additional CVE vulnerability details for {security_testing_tool_name} from cache: {vulnerability_cve_id}"
                        )

                        # Get CVE details from cache
                        vulnerability_cve_published_date = cve_published_date_cache.get(vulnerability_cve_id)
                        vulnerability_cve_last_modified_date = cve_last_modified_date.get(vulnerability_cve_id)
                        vulnerability_cwe_id = cve_cwe_id_cache.get(vulnerability_cve_id)
                    else:
                        log.info(f"CVE vulnerability not in cache: {vulnerability_cve_id}")
                        log.info(f"Fetching additional CVE details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}")

                        # Get additional CVE details from NVD
                        nvd_response = send_vulnerability_get_request(get_nvd_api_url(vulnerability_cve_id), args.nvd_api_key)
                        if nvd_response:
                            nvd_details = nvd_response.json()
                            if nvd_details["totalResults"] > 0:
                                nvd_cve_details = nvd_details["vulnerabilities"][0]
                                vulnerability_cve_published_date = get_json_value(nvd_cve_details, "cve", "published")
                                vulnerability_cve_last_modified_date = get_json_value(nvd_cve_details, "cve", "lastModified")

                                # Grype does not provide CWEs associated with the CVE ID, so we need to extract it from NVD
                                vulnerability_cwe_id = get_cwe_from_nvd(nvd_cve_details)
                                log.info(
                                    f"Fetched additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_status}"
                                )
                            else:
                                log.info(
                                    f"No additional CVE vulnerability details for {security_testing_tool_name} found in NVD: {vulnerability_cve_id}"
                                )
                        else:
                            log.error(
                                f"Failed to fetch additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}"
                            )

                        # Cache CVE details
                        cve_published_date_cache.set(vulnerability_cve_id, vulnerability_cve_published_date)
                        cve_last_modified_date.set(vulnerability_cve_id, vulnerability_cve_last_modified_date)
                        cve_cwe_id_cache.set(vulnerability_cve_id, vulnerability_cwe_id)

                    vulnerability_results_data = experiment_information + [
                        security_testing_tool_category,
                        security_testing_tool_type,
                        security_testing_tool_name,
                        security_testing_tool_classification,
                        security_testing_tool_cli_version.lstrip("v"),
                        args.experiment_programming_language.title(),
                        vulnerability_severity.title(),
                        default_not_applicable_value,
                        vulnerability_component_type.title(),
                        vulnerability_component_name,
                        vulnerability_component_version,
                        vulnerability_component_purl,
                        vulnerability_component_license,
                        vulnerability_component_location,
                        vulnerability_cve_id.upper(),
                        remove_new_lines_from_cve_description(vulnerability_cve_description),
                        vulnerability_cve_source,
                        vulnerability_cve_published_date,
                        vulnerability_cve_last_modified_date,
                        vulnerability_cve_status.title(),
                        default_not_applicable_value,
                        default_not_applicable_value,
                        vulnerability_cve_cvss_v2_vector,
                        vulnerability_cve_cvss_v3_vector,
                        vulnerability_cve_cvss_v4_vector,
                        vulnerability_cwe_id,
                    ]
                    log.info(f"Fetched all CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")

                    # Add vulnerability data to CSV row
                    csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sca_grype_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Grype report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed Grype report: {args.sca_grype_report_filename}")

    # Cleanup CVE caches
    clear_cve_caches()
    return None


def parse_snyk_data(
    args: argparse.Namespace,
    experiment_information: list,
) -> None:
    """Parse Snyk SCA JSON report and write data to output file

    :parameter
        args: argparse.Namespace -- Parsed arguments supplied to script
        experiment_information: list -- Experiment information
    """
    log.info(f"Parsing Snyk report: {args.sca_snyk_report_filename}")
    with open(args.sca_snyk_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cve_status_cache

    try:
        # Check if vulnerabilities exist in report
        if data["vulnerabilities"] is None or len(data["vulnerabilities"]) == 0:
            log.info(f"No vulnerabilities found in Snyk report: {args.sca_snyk_report_filename}")
        else:
            security_testing_tool_name = "Snyk"
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Pinned in Snyk SCA GitHub Action
            security_testing_tool_cli_version = "1.1292.1"

            # Iterate through all vulnerabilities
            for vulnerability in data["vulnerabilities"]:
                # Only consider vulnerabilities with CVE ID
                for vulnerability_cve_id in vulnerability["identifiers"]["CVE"]:
                    log.info(f"Fetching CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")
                    vulnerability_severity = get_json_value(vulnerability, "severity")

                    # Get Component details
                    vulnerability_component_type = get_json_value(vulnerability, "packageManager")
                    vulnerability_component_name = get_json_value(vulnerability, "packageName")
                    vulnerability_component_version = get_json_value(vulnerability, "version")
                    vulnerability_component_purl = (
                        f"pkg:{vulnerability_component_type}/{vulnerability_component_name}@{vulnerability_component_version}"
                    )

                    vulnerability_component_path = get_json_value(data, "path")
                    vulnerability_component_file = get_json_value(data, "displayTargetFile")
                    vulnerability_component_location = f"{vulnerability_component_path}/{vulnerability_component_file}"

                    # Get CVE details
                    vulnerability_cve_description = get_json_value(vulnerability, "title")
                    vulnerability_cve_description = vulnerability_cve_description.strip()
                    vulnerability_cve_published_date = get_json_value(vulnerability, "publicationTime")
                    vulnerability_cve_last_modified_date = get_json_value(vulnerability, "modificationTime")
                    vulnerability_cve_malicious = str(get_json_value(vulnerability, "malicious"))
                    vulnerability_cve_disputed = str(get_json_value(vulnerability, "isDisputed"))

                    # Get CVSS vectors
                    vulnerability_cve_cvss_v2_vector = get_snyk_cvss_vector(vulnerability, "CVSSv2")
                    vulnerability_cve_cvss_v3_vector = get_snyk_cvss_vector(vulnerability, "CVSSv3")
                    vulnerability_cve_cvss_v4_vector = get_snyk_cvss_vector(vulnerability, "CVSSv4")

                    # Get CWE IDs
                    vulnerability_cwe_ids = get_json_value(vulnerability, "identifiers", "CWE")
                    vulnerability_cwe_id = convert_list_to_string(vulnerability_cwe_ids)

                    # Set default values
                    vulnerability_cve_status = default_not_found_value

                    if cve_status_cache.get(vulnerability_cve_id):
                        log.info(f"Fetching CVE vulnerability details for {security_testing_tool_name} from cache: {vulnerability_cve_id}")

                        # Get CVE details from cache
                        vulnerability_cve_status = cve_status_cache.get(vulnerability_cve_id)
                    else:
                        log.info(f"CVE vulnerability not in cache: {vulnerability_cve_id}")
                        log.info(
                            f"Fetching additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}"
                        )

                        # Get additional CVE details from NVD
                        nvd_response = send_vulnerability_get_request(get_nvd_api_url(vulnerability_cve_id), args.nvd_api_key)
                        if nvd_response:
                            nvd_details = nvd_response.json()
                            if nvd_details["totalResults"] > 0:
                                nvd_cve_details = nvd_details["vulnerabilities"][0]
                                vulnerability_cve_status = get_json_value(nvd_cve_details, "cve", "vulnStatus")
                                log.info(
                                    f"Fetched additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_status}"
                                )
                            else:
                                log.info(
                                    f"No additional CVE vulnerability details for {security_testing_tool_name} found in NVD: {vulnerability_cve_id}"
                                )
                        else:
                            log.error(
                                f"Failed to fetch additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}"
                            )

                        # Cache CVE details
                        cve_status_cache.set(vulnerability_cve_id, vulnerability_cve_status)

                    vulnerability_results_data = experiment_information + [
                        security_testing_tool_category,
                        security_testing_tool_type,
                        security_testing_tool_name,
                        security_testing_tool_classification,
                        security_testing_tool_cli_version.lstrip("v"),
                        args.experiment_programming_language.title(),
                        vulnerability_severity.title(),
                        default_not_applicable_value,
                        vulnerability_component_type.title(),
                        vulnerability_component_name,
                        vulnerability_component_version,
                        vulnerability_component_purl,
                        default_not_applicable_value,
                        vulnerability_component_location,
                        vulnerability_cve_id.upper(),
                        remove_new_lines_from_cve_description(vulnerability_cve_description),
                        default_not_applicable_value,
                        vulnerability_cve_published_date,
                        vulnerability_cve_last_modified_date,
                        vulnerability_cve_status.title(),
                        vulnerability_cve_malicious,
                        vulnerability_cve_disputed,
                        vulnerability_cve_cvss_v2_vector,
                        vulnerability_cve_cvss_v3_vector,
                        vulnerability_cve_cvss_v4_vector,
                        vulnerability_cwe_id,
                    ]
                    log.info(f"Fetched all CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")

                    # Add vulnerability data to CSV row
                    csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sca_snyk_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse Snyk report: {e}")
    else:
        log.info(f"Successfully parsed Snyk report: {args.sca_snyk_report_filename}")

    # Cleanup CVE caches
    clear_cve_caches()
    return None


def parse_owasp_dependency_check_data(
    args: argparse.Namespace,
    experiment_information: list,
) -> None:
    """Parse OWASP Dependency Check SCA JSON report and write data to output file

    :parameter
        args: argparse.Namespace -- Parsed arguments supplied to script
        experiment_information: list -- Experiment information
    """
    log.info(f"Parsing OWASP Dependency Check report: {args.sca_owasp_dependency_check_report_filename}")
    with open(args.sca_owasp_dependency_check_report_filename, "r") as f:
        data = json.load(f)
    csv_rows = []

    # Set globals
    global cve_published_date_cache
    global cve_last_modified_date
    global cve_status_cache
    global cve_cvss_v2_vector_cache
    global cve_cvss_v3_vector_cache
    global cve_cvss_v4_vector_cache

    try:
        # Check if dependencies exist in report
        if data["dependencies"] is None or len(data["dependencies"]) == 0:
            log.info(f"No dependencies found in OWASP Dependency Check report: {args.sca_owasp_dependency_check_report_filename}")
        else:
            security_testing_tool_name = "OWASP Dependency Check"
            security_testing_tool_category = get_security_testing_tool_category(security_testing_tool_name)
            security_testing_tool_type = get_security_testing_tool_type(security_testing_tool_name)
            security_testing_tool_cli_version = get_json_value(data, "scanInfo", "engineVersion")
            security_testing_tool_classification = get_security_testing_tool_classification(security_testing_tool_name)

            # Iterate through all dependencies
            for dependency in data["dependencies"]:
                dependency_packages = get_json_value(dependency, "packages")

                # Check if vulnerabilities exist in dependency and package details available
                if "vulnerabilities" in dependency and dependency_packages is not default_not_found_value:
                    for vulnerability in dependency["vulnerabilities"]:
                        # Only consider vulnerabilities with CVE ID
                        if "CVE" in vulnerability["name"]:
                            vulnerability_cve_id = get_json_value(vulnerability, "name")
                            log.info(f"Fetching CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")

                            # Get first uppermost path location
                            vulnerability_confidence = get_json_value(dependency_packages[0], "confidence")
                            vulnerability_severity = get_json_value(vulnerability, "severity")

                            # Get Component details
                            vulnerability_component_license = get_json_value(dependency, "license")
                            vulnerability_component_location = get_json_value(dependency, "filePath")
                            vulnerability_component_purl = get_json_value(dependency_packages[0], "id")
                            vulnerability_component_details = get_component_from_purl(vulnerability_component_purl)
                            vulnerability_component_type = vulnerability_component_details["type"]
                            vulnerability_component_name = vulnerability_component_details["name"]
                            vulnerability_component_version = vulnerability_component_details["version"]

                            # Get CVE details
                            vulnerability_cve_description = get_json_value(vulnerability, "description")
                            vulnerability_cve_description = vulnerability_cve_description.strip()
                            vulnerability_cve_source = get_json_value(vulnerability, "source")

                            # Get CWE IDs
                            vulnerability_cwe_ids = get_json_value(vulnerability, "cwes")
                            vulnerability_cwe_id = convert_list_to_string(vulnerability_cwe_ids)

                            # Set default values
                            vulnerability_cve_published_date = default_not_found_value
                            vulnerability_cve_last_modified_date = default_not_found_value
                            vulnerability_cve_status = default_not_found_value
                            vulnerability_cve_cvss_v2_vector = default_not_found_value
                            vulnerability_cve_cvss_v3_vector = default_not_found_value
                            vulnerability_cve_cvss_v4_vector = default_not_found_value

                            if cve_published_date_cache.get(vulnerability_cve_id):
                                log.info(
                                    f"Fetching additional CVE vulnerability details for {security_testing_tool_name} from cache: {vulnerability_cve_id}"
                                )

                                # Get CVE details from cache
                                vulnerability_cve_published_date = cve_published_date_cache.get(vulnerability_cve_id)
                                vulnerability_cve_last_modified_date = cve_last_modified_date.get(vulnerability_cve_id)
                                vulnerability_cve_status = cve_status_cache.get(vulnerability_cve_id)
                                vulnerability_cve_cvss_v2_vector = cve_cvss_v2_vector_cache.get(vulnerability_cve_id)
                                vulnerability_cve_cvss_v3_vector = cve_cvss_v3_vector_cache.get(vulnerability_cve_id)
                                vulnerability_cve_cvss_v4_vector = cve_cvss_v4_vector_cache.get(vulnerability_cve_id)
                            else:
                                log.info(f"CVE vulnerability not in cache: {vulnerability_cve_id}")
                                log.info(
                                    f"Fetching additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}"
                                )

                                # Get additional CVE details from NVD
                                nvd_response = send_vulnerability_get_request(get_nvd_api_url(vulnerability_cve_id), args.nvd_api_key)
                                if nvd_response:
                                    nvd_details = nvd_response.json()
                                    if nvd_details["totalResults"] > 0:
                                        nvd_cve_details = nvd_details["vulnerabilities"][0]

                                        vulnerability_cve_published_date = get_json_value(nvd_cve_details, "cve", "published")
                                        vulnerability_cve_last_modified_date = get_json_value(nvd_cve_details, "cve", "lastModified")
                                        vulnerability_cve_status = get_json_value(nvd_cve_details, "cve", "vulnStatus")

                                        # Get CVSS vectors
                                        vulnerability_cve_metrics = get_json_value(nvd_cve_details, "cve", "metrics")
                                        vulnerability_cve_cvss_v2_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "2.0")
                                        vulnerability_cve_cvss_v3_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "3.1")
                                        if vulnerability_cve_cvss_v3_vector == default_not_found_value:
                                            vulnerability_cve_cvss_v3_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "3.0")
                                        vulnerability_cve_cvss_v4_vector = get_nvd_cvss_vector(vulnerability_cve_metrics, "4.0")

                                        log.info(
                                            f"Fetched additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_status}"
                                        )
                                    else:
                                        log.info(
                                            f"No additional CVE vulnerability details for {security_testing_tool_name} found in NVD: {vulnerability_cve_id}"
                                        )
                                else:
                                    log.error(
                                        f"Failed to fetch additional CVE vulnerability details for {security_testing_tool_name} from NVD: {vulnerability_cve_id}"
                                    )

                                # Cache CVE details
                                cve_published_date_cache.set(vulnerability_cve_id, vulnerability_cve_published_date)
                                cve_last_modified_date.set(vulnerability_cve_id, vulnerability_cve_last_modified_date)
                                cve_status_cache.set(vulnerability_cve_id, vulnerability_cve_status)
                                cve_cvss_v2_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v2_vector)
                                cve_cvss_v3_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v3_vector)
                                cve_cvss_v4_vector_cache.set(vulnerability_cve_id, vulnerability_cve_cvss_v4_vector)

                            vulnerability_results_data = experiment_information + [
                                security_testing_tool_category,
                                security_testing_tool_type,
                                security_testing_tool_name,
                                security_testing_tool_classification,
                                security_testing_tool_cli_version.lstrip("v"),
                                args.experiment_programming_language.title(),
                                vulnerability_severity.title(),
                                vulnerability_confidence.title(),
                                vulnerability_component_type.title(),
                                vulnerability_component_name,
                                vulnerability_component_version,
                                vulnerability_component_purl,
                                vulnerability_component_license,
                                vulnerability_component_location,
                                vulnerability_cve_id.upper(),
                                remove_new_lines_from_cve_description(vulnerability_cve_description),
                                vulnerability_cve_source,
                                vulnerability_cve_published_date,
                                vulnerability_cve_last_modified_date,
                                vulnerability_cve_status.title(),
                                default_not_applicable_value,
                                default_not_applicable_value,
                                vulnerability_cve_cvss_v2_vector,
                                vulnerability_cve_cvss_v3_vector,
                                vulnerability_cve_cvss_v4_vector,
                                vulnerability_cwe_id,
                            ]
                            log.info(f"Fetched all CVE vulnerability details for {security_testing_tool_name}: {vulnerability_cve_id}")

                            # Add vulnerability data to CSV row
                            csv_rows.append(vulnerability_results_data)

            log.info(f"{str(len(csv_rows))} CSV rows generated for {security_testing_tool_name}")
            write_to_csv_report(csv_rows, args.sca_owasp_dependency_check_csv_result_filename)
    except Exception as e:  # pragma: no cover
        log.error(f"Failed to parse OWASP Dependency Check report: {e}")
        sys.exit(1)
    else:
        log.info(f"Successfully parsed OWASP Dependency Check report: {args.sca_owasp_dependency_check_report_filename}")

    # Cleanup CVE caches
    clear_cve_caches()
    return None


# =============
# Main function
# =============
def main(args: argparse.Namespace) -> None:
    """Main function of script

    :parameter
        args:argparse.Namespace -- Parsed arguments supplied to script
    """
    sast_csv_report_files = []
    sca_csv_report_files = []

    # Prerequisite - Get GitHub repository URL
    github_repository_data = get_github_repository_data(args)
    upstream_github_repository_url = get_json_value(github_repository_data, "parent", "svn_url")
    github_repository_url = get_json_value(github_repository_data, "svn_url")
    experiment_information = get_experiment_information(args, upstream_github_repository_url, github_repository_url)

    # SAST - CodeQL
    if args.sast_codeql_csv_result_filename:
        log.info(f"CodeQL GitHub repository: {args.experiment_github_repository}")
        write_csv_report_header(static_application_security_testing, args.sast_codeql_csv_result_filename)

        codeql_data = get_codeql_data(args)
        parse_codeql_data(args, experiment_information, codeql_data)
        sast_csv_report_files.append(args.sast_codeql_csv_result_filename)

    # SAST - DeepSource
    if args.sast_deepsource_csv_result_filename:
        log.info(f"DeepSource GitHub repository: {args.experiment_github_repository}")
        write_csv_report_header(static_application_security_testing, args.sast_deepsource_csv_result_filename)

        deepsource_data = get_deepsource_data(args)
        parse_deepsource_data(args, experiment_information, deepsource_data)
        sast_csv_report_files.append(args.sast_deepsource_csv_result_filename)

    # SAST - Horusec
    if args.sast_horusec_report_filename and args.sast_horusec_csv_result_filename:
        if os.path.isfile(args.sast_horusec_report_filename):
            log.info(f"Horusec report found: {args.sast_horusec_report_filename}")
            write_csv_report_header(static_application_security_testing, args.sast_horusec_csv_result_filename)

            parse_horusec_data(
                args,
                experiment_information,
            )
            sast_csv_report_files.append(args.sast_horusec_csv_result_filename)
        else:
            log.error(f"Horusec file not found: {args.sast_horusec_report_filename}")
            sys.exit(1)

    # SAST - Semgrep
    if args.sast_semgrep_report_filename and args.sast_semgrep_csv_result_filename:
        if os.path.isfile(args.sast_semgrep_report_filename):
            log.info(f"Semgrep report found: {args.sast_semgrep_report_filename}")
            write_csv_report_header(static_application_security_testing, args.sast_semgrep_csv_result_filename)

            parse_semgrep_data(
                args,
                experiment_information,
            )
            sast_csv_report_files.append(args.sast_semgrep_csv_result_filename)
        else:
            log.error(f"Semgrep file not found: {args.sast_semgrep_report_filename}")
            sys.exit(1)

    # SAST - Snyk Code
    if args.sast_snyk_code_report_filename and args.sast_snyk_code_csv_result_filename:
        if os.path.isfile(args.sast_snyk_code_report_filename):
            log.info(f"Snyk Code report found: {args.sast_snyk_code_report_filename}")
            write_csv_report_header(static_application_security_testing, args.sast_snyk_code_csv_result_filename)

            parse_snyk_code_data(
                args,
                experiment_information,
            )
            sast_csv_report_files.append(args.sast_snyk_code_csv_result_filename)
        else:
            log.error(f"Snyk Code file not found: {args.sast_snyk_code_report_filename}")
            sys.exit(1)

    # SAST - SonarQube
    if args.sast_sonarqube_csv_result_filename:
        if args.sonarqube_url and args.sonarqube_token and args.sonarqube_project_key:
            log.info(f"SonarQube project key found: {args.sonarqube_project_key}")
            write_csv_report_header(static_application_security_testing, args.sast_sonarqube_csv_result_filename)

            sonarqube_data = get_sonarqube_hotspots_search_data(args)
            parse_sonarqube_data(args, experiment_information, sonarqube_data)
            sast_csv_report_files.append(args.sast_sonarqube_csv_result_filename)
        else:
            log.error("SonarQube project key not found")
            sys.exit(1)

    # SCA - Dependabot
    if args.sca_dependabot_csv_result_filename:
        log.info(f"Dependabot GitHub repository: {args.experiment_github_repository}")
        write_csv_report_header(software_composition_analysis, args.sca_dependabot_csv_result_filename)

        dependabot_data = get_dependabot_data(args)
        parse_dependabot_data(args, experiment_information, dependabot_data)
        sca_csv_report_files.append(args.sca_dependabot_csv_result_filename)

    # SCA - Eclipse Steady
    if args.sca_eclipse_steady_report_filename and args.sca_eclipse_steady_csv_result_filename:
        if os.path.isfile(args.sca_eclipse_steady_report_filename):
            log.info(f"Eclipse Steady report found: {args.sca_eclipse_steady_report_filename}")
            write_csv_report_header(software_composition_analysis, args.sca_eclipse_steady_csv_result_filename)

            parse_eclipse_steady_data(args, experiment_information)
            sca_csv_report_files.append(args.sca_eclipse_steady_csv_result_filename)
        else:
            log.error(f"Eclipse Steady file not found: {args.sca_eclipse_steady_report_filename}")
            sys.exit(1)

    # SCA - Grype
    if args.sca_grype_report_filename and args.sca_grype_csv_result_filename:
        if os.path.isfile(args.sca_grype_report_filename):
            log.info(f"Grype report found: {args.sca_grype_report_filename}")
            write_csv_report_header(software_composition_analysis, args.sca_grype_csv_result_filename)

            parse_grype_data(args, experiment_information)
            sca_csv_report_files.append(args.sca_grype_csv_result_filename)
        else:
            log.error(f"Grype file not found: {args.sca_grype_report_filename}")
            sys.exit(1)

    # SCA - Snyk
    if args.sca_snyk_report_filename and args.sca_snyk_csv_result_filename:
        if os.path.isfile(args.sca_snyk_report_filename):
            log.info(f"Snyk report found: {args.sca_snyk_report_filename}")
            write_csv_report_header(software_composition_analysis, args.sca_snyk_csv_result_filename)

            parse_snyk_data(args, experiment_information)
            sca_csv_report_files.append(args.sca_snyk_csv_result_filename)
        else:
            log.error(f"Snyk file not found: {args.sca_snyk_report_filename}")
            sys.exit(1)

    # SCA - OWASP Dependency Check
    if args.sca_owasp_dependency_check_report_filename and args.sca_owasp_dependency_check_csv_result_filename:
        if os.path.isfile(args.sca_owasp_dependency_check_report_filename):
            log.info(f"OWASP Dependency Check report found: {args.sca_owasp_dependency_check_report_filename}")
            write_csv_report_header(software_composition_analysis, args.sca_owasp_dependency_check_csv_result_filename)

            parse_owasp_dependency_check_data(
                args,
                experiment_information,
            )
            sca_csv_report_files.append(args.sca_owasp_dependency_check_csv_result_filename)
        else:
            log.error(f"OWASP Dependency Check file not found: {args.sca_owasp_dependency_check_report_filename}")
            sys.exit(1)

    # Combine reports based on security testing tool category
    if len(sast_csv_report_files) > 0:
        combine_csv_reports(static_application_security_testing, sast_csv_report_files)

    if len(sca_csv_report_files) > 0:
        combine_csv_reports(software_composition_analysis, sca_csv_report_files)

    # Cleanup CWE caches for unit testing
    clear_cwe_caches()


if __name__ == "__main__":
    """
    The starting point of the application
    Script should be running in the root dir of project
    """
    log = logging.getLogger()
    log.setLevel(logging.NOTSET)

    logging_handler_out = logging.StreamHandler(sys.stdout)
    logging_handler_out.setLevel(logging.INFO)
    logging_handler_out.addFilter(LogFilter(logging.INFO))
    log.addHandler(logging_handler_out)

    logging_handler_err = logging.StreamHandler(sys.stderr)
    logging_handler_err.setLevel(logging.ERROR)
    logging_handler_err.addFilter(LogFilter(logging.ERROR))
    log.addHandler(logging_handler_err)

    main(get_args(sys.argv[1:]))
